{
  "openapi": "3.1.0",
  "info": {
    "title": "meilisearch",
    "description": "Meilisearch HTTP server",
    "contact": {
      "name": "Quentin de Quelen",
      "email": "quentin@dequelen.me"
    },
    "license": {
      "name": "MIT",
      "identifier": "MIT"
    },
    "version": "1.28.2"
  },
  "servers": [
    {
      "url": "/",
      "description": "Local server"
    }
  ],
  "paths": {
    "/batches": {
      "get": {
        "tags": [
          "Batches"
        ],
        "summary": "Get batches",
        "description": "List all batches, regardless of index. The batch objects are contained in the results array.\nBatches are always returned in descending order of uid. This means that by default, the most recently created batch objects appear first.\nBatch results are paginated and can be filtered with query parameters.",
        "operationId": "get_batches",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "u-int32",
              "default": 20,
              "minimum": 0
            },
            "example": 12
          },
          {
            "name": "from",
            "in": "query",
            "description": "Fetch the next set of results from the given uid.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "u-int32",
              "minimum": 0
            },
            "example": 12421
          },
          {
            "name": "reverse",
            "in": "query",
            "description": "The order you want to retrieve the objects.",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "example": true
          },
          {
            "name": "batchUids",
            "in": "query",
            "description": "Permits to filter tasks by their batch uid. By default, when the `batchUids` query parameter is not set, all task uids are returned. It's possible to specify several batch uids by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "u-int32",
              "minimum": 0
            },
            "example": 12421
          },
          {
            "name": "uids",
            "in": "query",
            "description": "Permits to filter tasks by their uid. By default, when the uids query parameter is not set, all task uids are returned. It's possible to specify several uids by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              231,
              423,
              598,
              "*"
            ]
          },
          {
            "name": "canceledBy",
            "in": "query",
            "description": "Permits to filter tasks using the uid of the task that canceled them. It's possible to specify several task uids by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              374,
              "*"
            ]
          },
          {
            "name": "types",
            "in": "query",
            "description": "Permits to filter tasks by their related type. By default, when `types` query parameter is not set, all task types are returned. It's possible to specify several types by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "example": [
              "documentAdditionOrUpdate",
              "*"
            ]
          },
          {
            "name": "statuses",
            "in": "query",
            "description": "Permits to filter tasks by their status. By default, when `statuses` query parameter is not set, all task statuses are returned. It's possible to specify several statuses by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Status"
              }
            },
            "example": [
              "succeeded",
              "failed",
              "canceled",
              "enqueued",
              "processing",
              "*"
            ]
          },
          {
            "name": "indexUids",
            "in": "query",
            "description": "Permits to filter tasks by their related index. By default, when `indexUids` query parameter is not set, the tasks of all the indexes are returned. It is possible to specify several indexes by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "example": [
              "movies",
              "theater",
              "*"
            ]
          },
          {
            "name": "afterEnqueuedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their enqueuedAt time. Matches tasks enqueued after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "beforeEnqueuedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their enqueuedAt time. Matches tasks enqueued before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "afterStartedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their startedAt time. Matches tasks started after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "beforeStartedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their startedAt time. Matches tasks started before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "afterFinishedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their finishedAt time. Matches tasks finished after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "beforeFinishedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their finishedAt time. Matches tasks finished before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          }
        ],
        "responses": {
          "200": {
            "description": "Return the batches",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AllBatches"
                },
                "example": {
                  "results": [
                    {
                      "uid": 2,
                      "details": {
                        "stopWords": [
                          "of",
                          "the"
                        ]
                      },
                      "progress": null,
                      "stats": {
                        "totalNbTasks": 1,
                        "status": {
                          "succeeded": 1
                        },
                        "types": {
                          "settingsUpdate": 1
                        },
                        "indexUids": {
                          "INDEX_NAME": 1
                        }
                      },
                      "duration": "PT0.110083S",
                      "startedAt": "2024-12-10T15:49:04.995321Z",
                      "finishedAt": "2024-12-10T15:49:05.105404Z"
                    }
                  ],
                  "total": 3,
                  "limit": 1,
                  "from": 2,
                  "next": 1
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "tasks.get",
              "tasks.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "Go",
            "source": "client.GetBatches();"
          },
          {
            "lang": "JS",
            "source": "client.batches.getBatches();"
          },
          {
            "lang": "PHP",
            "source": "$client->getBatches();"
          },
          {
            "lang": "Python",
            "source": "client.get_batches()"
          },
          {
            "lang": "Ruby",
            "source": "client.batches"
          },
          {
            "lang": "Rust",
            "source": "let mut query = meilisearch_sdk::batches::BatchesQuery::new(&client);\nquery.with_limit(20);\nlet batches: meilisearch_sdk::batches::BatchesResults =\n  client.get_batches_with(&query).await.unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'http://MEILISEARCH_URL/batches'"
          }
        ]
      }
    },
    "/batches/{batchUid}": {
      "get": {
        "tags": [
          "Batches"
        ],
        "summary": "Get one batch",
        "description": "Get a single batch.",
        "operationId": "get_batch",
        "parameters": [
          {
            "name": "batchUid",
            "in": "path",
            "description": "The unique batch id",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "8685"
          }
        ],
        "responses": {
          "200": {
            "description": "Return the batch",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchView"
                },
                "example": {
                  "uid": 1,
                  "details": {
                    "receivedDocuments": 1,
                    "indexedDocuments": 1
                  },
                  "progress": null,
                  "stats": {
                    "totalNbTasks": 1,
                    "status": {
                      "succeeded": 1
                    },
                    "types": {
                      "documentAdditionOrUpdate": 1
                    },
                    "indexUids": {
                      "INDEX_NAME": 1
                    }
                  },
                  "duration": "PT0.364788S",
                  "startedAt": "2024-12-10T15:48:49.672141Z",
                  "finishedAt": "2024-12-10T15:48:50.036929Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "tasks.get",
              "tasks.*",
              "*"
            ]
          }
        ]
      }
    },
    "/dumps": {
      "post": {
        "tags": [
          "Dumps"
        ],
        "summary": "Create a dump",
        "description": "Triggers a dump creation process. Once the process is complete, a dump is created in the\n[dump directory](https://www.meilisearch.com/docs/learn/self_hosted/configure_meilisearch_at_launch#dump-directory).\nIf the dump directory does not exist yet, it will be created.",
        "operationId": "create_dump",
        "responses": {
          "202": {
            "description": "Dump is being created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 0,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "DumpCreation",
                  "enqueuedAt": "2021-01-01T09:39:00.000000Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "dumps.create",
              "dumps.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.CreateDumpAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.createDump();"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.CreateDump()"
          },
          {
            "lang": "JS",
            "source": "client.createDump()"
          },
          {
            "lang": "Java",
            "source": "client.createDump();"
          },
          {
            "lang": "PHP",
            "source": "$client->createDump();"
          },
          {
            "lang": "Python",
            "source": "client.create_dump()"
          },
          {
            "lang": "Ruby",
            "source": "client.create_dump"
          },
          {
            "lang": "Rust",
            "source": "client\n  .create_dump()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.createDump { result in\n    switch result {\n    case .success(let dumpStatus):\n        print(dumpStatus)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/dumps'"
          }
        ]
      }
    },
    "/experimental-features": {
      "get": {
        "tags": [
          "Experimental features"
        ],
        "summary": "Get all experimental features",
        "description": "Get a list of all experimental features that can be activated via the /experimental-features route and whether or not they are currently activated.",
        "operationId": "get_features",
        "responses": {
          "200": {
            "description": "Experimental features are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RuntimeTogglableFeatures"
                },
                "example": {
                  "metrics": true,
                  "logsRoute": false,
                  "editDocumentsByFunction": false,
                  "containsFilter": false,
                  "network": false,
                  "getTaskDocumentsRoute": false,
                  "compositeEmbedders": false,
                  "chatCompletions": false,
                  "multimodal": false,
                  "vectorStoreSetting": false
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "experimental_features.get",
              "experimental_features.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "Go",
            "source": "client.ExperimentalFeatures().Get()"
          },
          {
            "lang": "Ruby",
            "source": "client.experimental_features"
          },
          {
            "lang": "Rust",
            "source": "let client = Client::new(\"http://localhost:7700\", Some(\"apiKey\"));\nlet features = ExperimentalFeatures::new(&client);\nlet res = features\n  .get()\n  .await\n  .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/experimental-features/'"
          }
        ]
      },
      "patch": {
        "tags": [
          "Experimental features"
        ],
        "summary": "Configure experimental features",
        "description": "Activate or deactivate experimental features.",
        "operationId": "patch_features",
        "responses": {
          "200": {
            "description": "Experimental features are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RuntimeTogglableFeatures"
                },
                "example": {
                  "metrics": true,
                  "logsRoute": false,
                  "editDocumentsByFunction": false,
                  "containsFilter": false,
                  "network": false,
                  "getTaskDocumentsRoute": false,
                  "compositeEmbedders": false,
                  "chatCompletions": false,
                  "multimodal": false,
                  "vectorStoreSetting": false
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "experimental_features.update",
              "experimental_features.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "Go",
            "source": "client.ExperimentalFeatures().SetMetrics(true).Update()"
          },
          {
            "lang": "Ruby",
            "source": "client.update_experimental_features(metrics: true)"
          },
          {
            "lang": "Rust",
            "source": "let client = Client::new(\"http://localhost:7700\", Some(\"apiKey\"));\nlet features = ExperimentalFeatures::new(&client);\nfeatures.set_metrics(true)\nlet res = features\n  .update()\n  .await\n  .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/experimental-features/' \\\n  -H 'Content-Type: application/json'  \\\n  --data-binary '{\n    \"metrics\": true\n  }'"
          }
        ]
      }
    },
    "/export": {
      "post": {
        "tags": [
          "Export"
        ],
        "operationId": "export",
        "responses": {
          "202": {
            "description": "Export successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 1,
                  "status": "enqueued",
                  "type": "export",
                  "enqueuedAt": "2021-08-11T09:25:53.000000Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "export",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "Java",
            "source": "Map<String, ExportIndexFilter> indexes = new HashMap<>();\nindexes.put(\"*\", ExportIndexFilter.builder().overrideSettings(true).build());\nExportRequest request = ExportRequest.builder().url(\"TARGET_INSTANCE_URL\").indexes(indexes).build();\nclient.export(request);"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/export' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"url\": \"TARGET_INSTANCE_URL\",\n    \"indexes\": {\n      \"*\": {\n        \"overrideSettings\": true\n      }\n    }\n  }'"
          }
        ]
      }
    },
    "/health": {
      "get": {
        "tags": [
          "Health"
        ],
        "summary": "Get Health",
        "description": "The health check endpoint enables you to periodically test the health of your Meilisearch instance.",
        "operationId": "get_health",
        "responses": {
          "200": {
            "description": "Instance is healthy",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HealthResponse"
                },
                "example": {
                  "status": "available"
                }
              }
            }
          }
        },
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.HealthAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.health();"
          },
          {
            "lang": "Go",
            "source": "client.Health()"
          },
          {
            "lang": "JS",
            "source": "client.health()"
          },
          {
            "lang": "Java",
            "source": "client.health();"
          },
          {
            "lang": "PHP",
            "source": "$client->health();"
          },
          {
            "lang": "Python",
            "source": "client.health()"
          },
          {
            "lang": "Ruby",
            "source": "client.health"
          },
          {
            "lang": "Rust",
            "source": "// health() return an Err() if the server is not healthy, so this example would panic due to the unwrap\nclient\n  .health()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.health { (result) in\n    switch result {\n    case .success:\n        print(\"Healthy!\")\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/health'"
          }
        ]
      }
    },
    "/indexes": {
      "get": {
        "tags": [
          "Indexes"
        ],
        "summary": "List indexes",
        "description": "List all indexes.",
        "operationId": "list_indexes",
        "parameters": [
          {
            "name": "offset",
            "in": "query",
            "description": "The number of indexes to skip before starting to retrieve anything",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0
            },
            "example": 100
          },
          {
            "name": "limit",
            "in": "query",
            "description": "The number of indexes to retrieve",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 20,
              "minimum": 0
            },
            "example": 1
          }
        ],
        "responses": {
          "200": {
            "description": "Indexes are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginationView_IndexView"
                },
                "example": {
                  "results": [
                    {
                      "uid": "movies",
                      "primaryKey": "movie_id",
                      "createdAt": "2019-11-20T09:40:33.711324Z",
                      "updatedAt": "2019-11-20T09:40:33.711324Z"
                    }
                  ],
                  "limit": 1,
                  "offset": 0,
                  "total": 1
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "indexes.get",
              "indexes.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.GetAllIndexesAsync(new IndexesQuery { Limit = 3 });"
          },
          {
            "lang": "Dart",
            "source": "await client.getIndexes(params: IndexesQuery(limit: 3));"
          },
          {
            "lang": "Go",
            "source": "client.GetIndexes(&meilisearch.IndexesQuery{\n  Limit: 3,\n})"
          },
          {
            "lang": "JS",
            "source": "client.getIndexes({ limit: 3 })"
          },
          {
            "lang": "Java",
            "source": "IndexesQuery query = new IndexesQuery().setLimit(3);\nclient.getIndexes(query);"
          },
          {
            "lang": "PHP",
            "source": "$client->getIndexes((new IndexesQuery())->setLimit(3));"
          },
          {
            "lang": "Python",
            "source": "client.get_indexes({'limit': 3})"
          },
          {
            "lang": "Ruby",
            "source": "client.indexes(limit: 3)"
          },
          {
            "lang": "Rust",
            "source": "let mut indexes = IndexesQuery::new(&client)\n  .with_limit(3)\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.getIndexes { (result) in\n    switch result {\n    case .success(let indexes):\n        print(indexes)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes?limit=3'"
          }
        ]
      },
      "post": {
        "tags": [
          "Indexes"
        ],
        "summary": "Create index",
        "description": "Create an index.",
        "operationId": "create_index",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IndexCreateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "indexCreation",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "indexes.create",
              "indexes.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "TaskInfo task = await client.CreateIndexAsync(\"movies\", \"id\");"
          },
          {
            "lang": "Dart",
            "source": "await client.createIndex('movies', primaryKey: 'id');"
          },
          {
            "lang": "Go",
            "source": "client.CreateIndex(&meilisearch.IndexConfig{\n  Uid: \"movies\",\n  PrimaryKey: \"id\",\n})"
          },
          {
            "lang": "JS",
            "source": "client.createIndex('movies', { primaryKey: 'id' })"
          },
          {
            "lang": "Java",
            "source": "client.createIndex(\"movies\", \"id\");"
          },
          {
            "lang": "PHP",
            "source": "$client->createIndex('movies', ['primaryKey' => 'id']);"
          },
          {
            "lang": "Python",
            "source": "client.create_index('movies', {'primaryKey': 'id'})"
          },
          {
            "lang": "Ruby",
            "source": "client.create_index('movies', primary_key: 'id')"
          },
          {
            "lang": "Rust",
            "source": "client.create_index(\"movies\", Some(\"id\"))\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.createIndex(uid: \"movies\", primaryKey: \"id\") { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"uid\": \"movies\",\n    \"primaryKey\": \"id\"\n  }'"
          }
        ]
      }
    },
    "/indexes/{indexUid}": {
      "get": {
        "tags": [
          "Indexes"
        ],
        "summary": "Get index",
        "description": "Get information about an index.",
        "operationId": "get_index",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "The index is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IndexView"
                },
                "example": {
                  "uid": "movies",
                  "primaryKey": "movie_id",
                  "createdAt": "2019-11-20T09:40:33.711324Z",
                  "updatedAt": "2019-11-20T09:40:33.711324Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "Index not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Index `movies` not found.",
                  "code": "index_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#index_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "indexes.get",
              "indexes.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.GetIndexAsync(\"movies\");"
          },
          {
            "lang": "Dart",
            "source": "await client.getIndex('movies');"
          },
          {
            "lang": "Go",
            "source": "client.GetIndex(\"movies\")"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').getRawInfo()"
          },
          {
            "lang": "Java",
            "source": "client.getIndex(\"movies\");"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->fetchRawInfo();"
          },
          {
            "lang": "Python",
            "source": "client.get_index('movies')"
          },
          {
            "lang": "Ruby",
            "source": "client.fetch_index('movies')"
          },
          {
            "lang": "Rust",
            "source": "let movies: Index = client\n  .get_index(\"movies\")\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.getIndex(\"movies\") { (result) in\n    switch result {\n    case .success(let index):\n        print(index)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Indexes"
        ],
        "summary": "Delete index",
        "description": "Delete an index.",
        "operationId": "delete_index",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "202": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 0,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "indexDeletion",
                  "enqueuedAt": "2021-01-01T09:39:00.000000Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "indexes.delete",
              "indexes.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.DeleteIndexAsync(\"movies\");"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').delete();"
          },
          {
            "lang": "Go",
            "source": "client.DeleteIndex(\"movies\")\n// OR\nclient.Index(\"movies\").Delete()"
          },
          {
            "lang": "JS",
            "source": "client.deleteIndex('movies')"
          },
          {
            "lang": "Java",
            "source": "client.deleteIndex(\"movies\");"
          },
          {
            "lang": "PHP",
            "source": "$client->deleteIndex('movies');"
          },
          {
            "lang": "Python",
            "source": "client.delete_index('movies')\n// OR\nclient.index('movies').delete()"
          },
          {
            "lang": "Ruby",
            "source": "client.delete_index('movies')"
          },
          {
            "lang": "Rust",
            "source": "client.index(\"movies\")\n  .delete()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").delete { (result) in\n    switch result {\n    case .success:\n        print(\"Index deleted\")\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies'"
          }
        ]
      },
      "patch": {
        "tags": [
          "Indexes"
        ],
        "summary": "Update index",
        "description": "Update the `primaryKey` of an index.\nReturn an error if the index doesn't exists yet or if it contains documents.",
        "operationId": "update_index",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateIndexRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 0,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "indexUpdate",
                  "enqueuedAt": "2021-01-01T09:39:00.000000Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "indexes.update",
              "indexes.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "TaskInfo task = await client.UpdateIndexAsync(\"movies\", \"id\");"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').update(primaryKey: 'id');"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").UpdateIndex(&meilisearch.UpdateIndexRequestParams{\n  PrimaryKey: \"id\",\n})"
          },
          {
            "lang": "JS",
            "source": "client.updateIndex('movies', { primaryKey: 'id' })"
          },
          {
            "lang": "Java",
            "source": "client.updateIndex(\"movies\", \"id\");"
          },
          {
            "lang": "PHP",
            "source": "$client->updateIndex('movies', ['primaryKey' => 'id']);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update(primary_key='id')"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update(primary_key: 'movie_id')"
          },
          {
            "lang": "Rust",
            "source": "let task = IndexUpdater::new(\"movies\", &client)\n  .with_primary_key(\"movie_review_id\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").update(primaryKey: \"id\") { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/movies' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{ \"primaryKey\": \"id\" }'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/compact": {
      "post": {
        "tags": [
          "Compact an index"
        ],
        "summary": "Compact an index",
        "operationId": "compact",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "202": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "documentDeletion",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "search",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "Java",
            "source": "client.index(\"INDEX_NAME\").compact();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').compact()"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"INDEX_UID\")\n  .compact()\n  .await\n  .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/INDEX_UID/compact'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/documents": {
      "get": {
        "tags": [
          "Documents"
        ],
        "summary": "Get documents",
        "description": "Get documents by batches.",
        "operationId": "get_documents",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0
            }
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0
            }
          },
          {
            "name": "fields",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "retrieveVectors",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "filter",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "popularity > 1000"
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The documents are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginationView_Value"
                },
                "example": {
                  "results": [
                    {
                      "id": 25684,
                      "title": "American Ninja 5",
                      "poster": "https://image.tmdb.org/t/p/w1280/iuAQVI4mvjI83wnirpD8GVNRVuY.jpg",
                      "overview": "When a scientists daughter is kidnapped, American Ninja, attempts to find her, but this time he teams up with a youngster he has trained in the ways of the ninja.",
                      "release_date": 725846400
                    },
                    {
                      "id": 45881,
                      "title": "The Bridge of San Luis Rey",
                      "poster": "https://image.tmdb.org/t/p/w500/4X7quIcdkc24Cveg5XdpfRqxtYA.jpg",
                      "overview": "The Bridge of San Luis Rey is American author Thornton Wilder's second novel, first published in 1927 to worldwide acclaim. It tells the story of several interrelated people who die in the collapse of an Inca rope-fiber suspension bridge in Peru, and the events that lead up to their being on the bridge.[ A friar who has witnessed the tragic accident then goes about inquiring into the lives of the victims, seeking some sort of cosmic answer to the question of why each had to die. The novel won the Pulitzer Prize in 1928.",
                      "release_date": 1072915200
                    }
                  ],
                  "limit": 20,
                  "offset": 0,
                  "total": 2
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "Index not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Index `movies` not found.",
                  "code": "index_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#index_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.get",
              "documents.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetDocumentsAsync<Movie>(new DocumentsQuery() { Limit = 2, Filter = \"genres = action\" });"
          },
          {
            "lang": "Go",
            "source": "var result meilisearch.DocumentsResult\n\nclient.Index(\"movies\").GetDocuments(&meilisearch.DocumentsQuery{\n  Limit: 2,\n  Filter: \"genres = action\",\n}, &result)"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').getDocuments({\n  limit: 2,\n  filter: 'genres = action'\n})"
          },
          {
            "lang": "Java",
            "source": "DocumentsQuery query = new DocumentsQuery().setLimit(2).setFilter(new String[] {\"genres = action\"});\nclient.index(\"movies\").getDocuments(query, TargetClassName.class);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->getDocuments((new DocumentsQuery())->setFilter('genres = action')->setLimit(2));"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').get_documents({\n  'limit':2, 'filter': 'genres=action',\n  'sort': ['rating:desc', 'release_date:asc']  # list format\n})"
          },
          {
            "lang": "ruby",
            "source": "client.index('movies').get_documents(limit: 2, filter: 'genres = action')"
          },
          {
            "lang": "Rust",
            "source": "let index = client.index(\"movies\");\nlet documents: DocumentsResults = DocumentsQuery::new(&index)\n  .with_filter(\"genres = action\")\n  .with_limit(2)\n  .execute::<Movies>()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").getDocuments(params: DocumentsQuery(limit: 2)) { (result: Result<DocumentsResults<Movie>, Swift.Error>) in\n    switch result {\n    case .success(let movies):\n        print(movies)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/documents?limit=2&filter=genres=action'"
          }
        ]
      },
      "put": {
        "tags": [
          "Documents"
        ],
        "summary": "Add or update documents",
        "description": "Add a list of documents or update them if they already exist.\nIf you send an already existing document (same id) the old document will be only partially updated according to the fields of the new document. Thus, any fields not present in the new document are kept and remained unchanged.\nTo completely overwrite a document, see Add or replace documents route.\n> info\n> If the provided index does not exist, it will be created.\n> info\n> Use the reserved `_geo` object to add geo coordinates to a document. `_geo` is an object made of `lat` and `lng` field.\n>\n> When the vectorStore feature is enabled you can use the reserved `_vectors` field in your documents.\n> It can accept an array of floats, multiple arrays of floats in an outer array or an object.\n> This object accepts keys corresponding to the different embedders defined your index settings.",
        "operationId": "update_documents",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          },
          {
            "name": "primaryKey",
            "in": "query",
            "description": "The primary key of the documents. primaryKey is optional. If you want to set the primary key of your index through this route,\nit only has to be done the first time you add documents to the index. After which it will be ignored if given.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "id"
          },
          {
            "name": "csvDelimiter",
            "in": "query",
            "description": "Customize the csv delimiter when importing CSV documents.",
            "required": true,
            "schema": {
              "type": "string",
              "default": ","
            },
            "example": ";"
          },
          {
            "name": "customMetadata",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "custom"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {}
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "documentAdditionOrUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.add",
              "documents.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "var movie = new[]\n{\n    new Movie { Id = \"287947\", Title = \"Shazam \", Genres = \"comedy\" }\n};\nawait index.UpdateDocumentsAsync(movie);"
          },
          {
            "lang": "Go",
            "source": "documents := []map[string]interface{}{\n  {\n    \"id\":     287947,\n    \"title\":  \"Shazam \",\n    \"genres\": \"comedy\",\n  },\n}\nclient.Index(\"movies\").UpdateDocuments(documents, nil)"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateDocuments([{\n    id: 287947,\n    title: 'Shazam ',\n    genres: 'comedy'\n}])"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").updateDocuments(\"[{\n  + \"\\\"id\\\": 287947,\"\n  + \"\\\"title\\\": \\\"Shazam \\\",\"\n  + \"\\\"genres\\\": \\\"comedy\\\"\"\n  + \"}]\"\n);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateDocuments([\n  [\n    'id' => 287947,\n    'title' => 'Shazam ',\n    'genres' => 'comedy'\n  ]\n]);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_documents([{\n    'id': 287947,\n    'title': 'Shazam ',\n    'genres': 'comedy'\n}])"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_documents([\n  {\n    id: 287947,\n    title: 'Shazam ',\n    genres: 'comedy'\n  }\n])"
          },
          {
            "lang": "Rust",
            "source": "// Define the type of our documents\n#[derive(Serialize, Deserialize)]\nstruct IncompleteMovie {\n  id: usize,\n  title: String,\n  genres: String\n}\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .add_or_update(&[\n    IncompleteMovie {\n      id: 287947,\n      title: \"Shazam \".to_string(),\n      genres: \"comedy\".to_string()\n    }\n  ], None)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let documentJsonString = \"\"\"\n[\n  {\n    \"reference_number\": 287947,\n    \"title\": \"Shazam \",\n    \"genres\": \"comedy\"\n  }\n]\n\"\"\"\nlet documents: Data = documentJsonString.data(using: .utf8)!\n\nclient.index(\"movies\").updateDocuments(documents: documents) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/documents' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    {\n      \"id\": 287947,\n      \"title\": \"Shazam \",\n      \"genres\": \"comedy\"\n    }\n  ]'"
          }
        ]
      },
      "post": {
        "tags": [
          "Documents"
        ],
        "summary": "Add or replace documents",
        "description": "Add a list of documents or replace them if they already exist.\n\nIf you send an already existing document (same id) the whole existing document will be overwritten by the new document. Fields previously in the document not present in the new document are removed.\n\nFor a partial update of the document see Add or update documents route.\n> info\n> If the provided index does not exist, it will be created.\n> info\n> Use the reserved `_geo` object to add geo coordinates to a document. `_geo` is an object made of `lat` and `lng` field.\n>\n> When the vectorStore feature is enabled you can use the reserved `_vectors` field in your documents.\n> It can accept an array of floats, multiple arrays of floats in an outer array or an object.\n> This object accepts keys corresponding to the different embedders defined your index settings.",
        "operationId": "replace_documents",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          },
          {
            "name": "primaryKey",
            "in": "query",
            "description": "The primary key of the documents. primaryKey is optional. If you want to set the primary key of your index through this route,\nit only has to be done the first time you add documents to the index. After which it will be ignored if given.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "id"
          },
          {
            "name": "csvDelimiter",
            "in": "query",
            "description": "Customize the csv delimiter when importing CSV documents.",
            "required": true,
            "schema": {
              "type": "string",
              "default": ","
            },
            "example": ";"
          },
          {
            "name": "customMetadata",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "custom"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {}
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "documentAdditionOrUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.add",
              "documents.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "var movie = new[]\n{\n    new Movie\n    {\n          Id = \"287947\",\n          Title = \"Shazam\",\n          Poster = \"https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg\",\n          Overview = \"A boy is given the ability to become an adult superhero in times of need with a single magic word.\",\n          ReleaseDate = \"2019-03-23\"\n    }\n};\nawait index.AddDocumentsAsync(movie);"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').addDocuments([\n  {\n    'id': 287947,\n    'title': 'Shazam',\n    'poster':\n        'https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg',\n    'overview':\n        'A boy is given the ability to become an adult superhero in times of need with a single magic word.',\n    'release_date': '2019-03-23'\n  }\n]);"
          },
          {
            "lang": "Go",
            "source": "documents := []map[string]interface{}{\n  {\n    \"id\":           287947,\n    \"title\":        \"Shazam\",\n    \"poster\":       \"https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg\",\n    \"overview\":     \"A boy is given the ability to become an adult superhero in times of need with a single magic word.\",\n    \"release_date\": \"2019-03-23\",\n  },\n}\nclient.Index(\"movies\").AddDocuments(documents, nil)"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').addDocuments([{\n    id: 287947,\n    title: 'Shazam',\n    poster: 'https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg',\n    overview: 'A boy is given the ability to become an adult superhero in times of need with a single magic word.',\n    release_date: '2019-03-23'\n}])"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").addDocuments(\"[{\"\n  + \"\\\"id\\\": 287947,\"\n  + \"\\\"title\\\": \\\"Shazam\\\",\"\n  + \"\\\"poster\\\": \\\"https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg\\\",\"\n  + \"\\\"overview\\\": \\\"A boy is given the ability to become an adult superhero in times of need with a single magic word.\\\",\"\n  + \"\\\"release_date\\\": \\\"2019-03-23\\\"\"\n  + \"}]\"\n);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->addDocuments([\n  [\n    'id' => 287947,\n    'title' => 'Shazam',\n    'poster' => 'https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg',\n    'overview' => 'A boy is given the ability to become an adult superhero in times of need with a single magic word.',\n    'release_date' => '2019-03-23'\n  ]\n]);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').add_documents([{\n  'id': 287947,\n  'title': 'Shazam',\n  'poster': 'https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg',\n  'overview': 'A boy is given the ability to become an adult superhero in times of need with a single magic word.',\n  'release_date': '2019-03-23'\n}])"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').add_documents([\n  {\n    id: 287947,\n    title: 'Shazam',\n    poster: 'https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg',\n    overview: 'A boy is given the ability to become an adult superhero in times of need with a single magic word.',\n    release_date: '2019-03-23'\n  }\n])"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .add_or_replace(&[\n    Movie {\n      id: 287947,\n      title: \"Shazam\".to_string(),\n      poster: \"https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg\".to_string(),\n      overview: \"A boy is given the ability to become an adult superhero in times of need with a single magic word.\".to_string(),\n      release_date: \"2019-03-23\".to_string(),\n    }\n  ], None)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let documentJsonString = \"\"\"\n[\n  {\n    \"reference_number\": 287947,\n    \"title\": \"Shazam\",\n    \"poster\": \"https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg\",\n    \"overview\": \"A boy is given the ability to become an adult superhero in times of need with a single magic word.\",\n    \"release_date\": \"2019-03-23\"\n  }\n]\n\"\"\"\nlet documents: Data = documentJsonString.data(using: .utf8)!\n\nclient.index(\"movies\").addDocuments(documents: documents) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/documents' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    {\n      \"id\": 287947,\n      \"title\": \"Shazam\",\n      \"poster\": \"https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg\",\n      \"overview\": \"A boy is given the ability to become an adult superhero in times of need with a single magic word.\",\n      \"release_date\": \"2019-03-23\"\n    }\n  ]'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Documents"
        ],
        "summary": "Delete all documents",
        "description": "Delete all documents in the specified index.",
        "operationId": "clear_all_documents",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "documentDeletion",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.delete",
              "documents.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").DeleteAllDocumentsAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').deleteAllDocuments();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").DeleteAllDocuments()"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').deleteAllDocuments()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").deleteAllDocuments();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->deleteAllDocuments();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').delete_all_documents()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').delete_all_documents"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .delete_all_documents()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").deleteAllDocuments() { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/documents'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/documents/delete": {
      "post": {
        "tags": [
          "Documents"
        ],
        "summary": "Delete documents by filter",
        "description": "Delete a set of documents based on a filter.",
        "operationId": "delete_documents_by_filter",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentDeletionByFilter"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "documentDeletion",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.delete",
              "documents.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").DeleteDocumentsAsync(new DeleteDocumentsQuery() { Filter = \"genres = action OR genres = adventure\" });"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").DeleteDocumentsByFilter(\"genres=action OR genres=adventure\")"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').deleteDocuments({\n  filter: 'genres = action OR genres = adventure'\n})"
          },
          {
            "lang": "Java",
            "source": "String filter = \"genres = action OR genres = adventure\";\nclient.index(\"movies\").deleteDocumentsByFilter(filter);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->deleteDocuments(['filter' => 'genres = action OR genres = adventure']);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').delete_documents(filter='genres=action OR genres=adventure')"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').delete_documents(filter: 'genres = action OR genres = adventure')"
          },
          {
            "lang": "Rust",
            "source": "let index = client.index(\"movies\");\nlet task = DocumentDeletionQuery::new(&index)\n  .with_filter(\"genres = action OR genres = adventure\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST MEILISEARCH_URL/indexes/movies/documents/delete \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"filter\": \"genres = action OR genres = adventure\"\n  }'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/documents/delete-batch": {
      "post": {
        "tags": [
          "Documents"
        ],
        "summary": "Delete documents by batch",
        "description": "Delete a set of documents based on an array of document ids.",
        "operationId": "delete_documents_batch",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {}
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "documentAdditionOrUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.delete",
              "documents.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").DeleteDocumentsAsync(new[] { \"23488\", \"153738\", \"437035\", \"363869\" });"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").DeleteDocuments([]string{\n  \"23488\",\n  \"153738\",\n  \"437035\",\n  \"363869\",\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').deleteDocuments([23488, 153738, 437035, 363869])"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").deleteDocuments(Arrays.asList(new String[]\n{\n  \"23488\",\n  \"153738\",\n  \"437035\",\n  \"363869\"\n}));"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->deleteDocuments([23488, 153738, 437035, 363869]);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').delete_documents([23488, 153738, 437035, 363869])"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').delete_documents([23488, 153738, 437035, 363869])"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .delete_documents(&[23488, 153738, 437035, 363869])\n  .await\n  .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/documents/delete-batch' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    23488,\n    153738,\n    437035,\n    363869\n  ]'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/documents/edit": {
      "post": {
        "tags": [
          "Documents"
        ],
        "summary": "Edit documents by function.",
        "description": "Use a [RHAI function](https://rhai.rs/book/engine/hello-world.html) to edit one or more documents directly in Meilisearch.",
        "operationId": "edit_documents_by_function",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentEditionByFunction"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "documentDeletion",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.*",
              "*"
            ]
          }
        ]
      }
    },
    "/indexes/{indexUid}/documents/fetch": {
      "post": {
        "tags": [
          "Documents"
        ],
        "summary": "Get documents with POST",
        "description": "Get a set of documents.",
        "operationId": "documents_by_query_post",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BrowseQuery"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginationView_Value"
                },
                "example": {
                  "results": [
                    {
                      "title": "The Travels of Ibn Battuta",
                      "genres": [
                        "Travel",
                        "Adventure"
                      ],
                      "language": "English",
                      "rating": 4.5
                    },
                    {
                      "title": "Pride and Prejudice",
                      "genres": [
                        "Classics",
                        "Fiction",
                        "Romance",
                        "Literature"
                      ],
                      "language": "English",
                      "rating": 4
                    }
                  ],
                  "offset": 0,
                  "limit": 2,
                  "total": 5
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.delete",
              "documents.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetDocumentsAsync<Movie>(new DocumentsQuery() {\n    Limit = 3,\n    Fields = new List<string> { \"title\", \"genres\", \"rating\", \"language\"},\n    Filter = \"(rating > 3 AND (genres=Adventure OR genres=Fiction)) AND language=English\"\n});"
          },
          {
            "lang": "Go",
            "source": "var result meilisearch.DocumentsResult\n\nclient.Index(\"books\").GetDocuments(&meilisearch.DocumentsQuery{\n  Fields: []string{\"title\", \"genres\", \"rating\", \"language\"},\n  Filter: \"(rating > 3 AND (genres = Adventure OR genres = Fiction)) AND language = English\",\n}, &result)"
          },
          {
            "lang": "JS",
            "source": "client.index('books').getDocuments({\n  filter: '(rating > 3 AND (genres = Adventure OR genres = Fiction)) AND language = English',\n  fields: ['title', 'genres', 'rating', 'language'],\n  limit: 3\n})"
          },
          {
            "lang": "Java",
            "source": "DocumentsQuery query = new DocumentsQuery()\n  .setFilter(new String[] {\"(rating > 3 AND (genres = Adventure OR genres = Fiction)) AND language = English\"})\n  .setFields(new String[] {\"title\", \"genres\", \"rating\", \"language\"})\n  .setLimit(3);\nclient.index(\"books\").getDocuments(query, TargetClassName.class);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->getDocuments(\n  (new DocumentsQuery())\n    ->setFilter('(rating > 3 AND (genres = Adventure OR genres = Fiction)) AND language = English')\n    ->setLimit(3)\n    ->setFields(['title', 'genres', 'rating', 'language'])\n);"
          },
          {
            "lang": "Python",
            "source": "client.index('books').get_documents({\n  'limit':3,\n  'fields': ['title', 'genres', 'rating', 'language'],\n  'filter': '(rating > 3 AND (genres=Adventure OR genres=Fiction)) AND language=English',\n  'sort': 'rating:desc, title:asc'  # comma-separated string format\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').get_documents(\n  filter: '(rating > 3 AND (genres = Adventure OR genres = Fiction)) AND language = English',\n  limit: 3,\n  fields: ['title', 'genres', 'rating', 'language']\n)"
          },
          {
            "lang": "Rust",
            "source": "let index = client.index(\"books\");\nlet documents: DocumentsResults = DocumentsQuery::new(&index)\n  .with_filter(\"(rating > 3 AND (genres = Adventure OR genres = Fiction)) AND language = English\")\n  .with_fields([\"title\", \"genres\", \"rating\", \"language\"])\n  .with_limit(2)\n  .execute::<Movies>()\n  .await\n  .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST MEILISEARCH_URL/indexes/books/documents/fetch \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"filter\": \"(rating > 3 AND (genres = Adventure OR genres = Fiction)) AND language = English\",\n    \"fields\": [\"title\", \"genres\", \"rating\", \"language\"],\n    \"limit\": 3\n  }'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/documents/{documentId}": {
      "get": {
        "tags": [
          "Documents"
        ],
        "summary": "Get one document",
        "description": "Get one document from its primary key.",
        "operationId": "get_document",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          },
          {
            "name": "documentId",
            "in": "path",
            "description": "The document identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "85087"
          },
          {
            "name": "fields",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "retrieveVectors",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The document is returned",
            "content": {
              "application/json": {
                "schema": {},
                "example": {
                  "id": 25684,
                  "title": "American Ninja 5",
                  "poster": "https://image.tmdb.org/t/p/w1280/iuAQVI4mvjI83wnirpD8GVNRVuY.jpg",
                  "overview": "When a scientists daughter is kidnapped, American Ninja, attempts to find her, but this time he teams up with a youngster he has trained in the ways of the ninja.",
                  "release_date": 725846400
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "Document not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Document `a` not found.",
                  "code": "document_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#document_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.get",
              "documents.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetDocumentAsync<Movie>(25684, new List<string> { \"id\", \"title\", \"poster\", \"release_date\" });"
          },
          {
            "lang": "Go",
            "source": "var a interface{}\nclient.Index(\"movies\").GetDocument(\"25684\",&meilisearch.DocumentQuery{\n  Fields: []string{\"id\", \"title\", \"poster\", \"release_date\"},\n}, &a)"
          },
          {
            "lang": "JS",
            "source": "client\n    .index('movies')\n    .getDocument(25684, { fields: ['id', 'title', 'poster', 'release_date'] })"
          },
          {
            "lang": "Java",
            "source": "DocumentQuery query = new DocumentQuery().setFields(new String[] {\"id\", \"title\", \"poster\", \"release_date\"});\nclient.index(\"movies\").getDocument(\"25684\", query);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->getDocument(25684, ['id', 'title', 'poster', 'release_date']);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').get_document(25684, {\n  'fields': ['id', 'title', 'poster', 'release_date']\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').document(25684, fields: ['id', 'title', 'poster', 'release_date'])"
          },
          {
            "lang": "Rust",
            "source": "let index = client\n  .index(\"movies\");\nlet document = DocumentQuery::new(&index)\n  .with_fields([\"id\", \"title\", \"poster\", \"release_date\"])\n  .execute::<Movie>(\"25684\")\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").getDocument(25684) { (result: Result<Movie, Swift.Error>) in\n    switch result {\n    case .success(let movie):\n        print(movie)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/documents/25684?fields=id,title,poster,release_date'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Documents"
        ],
        "summary": "Delete a document",
        "description": "Delete a single document by id.",
        "operationId": "delete_document",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          },
          {
            "name": "documentId",
            "in": "path",
            "description": "Document Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "853"
          }
        ],
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "documentAdditionOrUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.delete",
              "documents.*",
              "*"
            ]
          }
        ]
      }
    },
    "/indexes/{indexUid}/facet-search": {
      "post": {
        "tags": [
          "Facet Search"
        ],
        "summary": "Perform a facet search",
        "description": "Search for a facet value within a given facet.",
        "operationId": "search",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FacetSearchQuery"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The documents are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResult"
                },
                "example": {
                  "hits": [
                    {
                      "id": 2770,
                      "title": "American Pie 2",
                      "poster": "https://image.tmdb.org/t/p/w1280/q4LNgUnRfltxzp3gf1MAGiK5LhV.jpg",
                      "overview": "The whole gang are back and as close as ever. They decide to get even closer by spending the summer together at a beach house. They decide to hold the biggest",
                      "release_date": 997405200
                    },
                    {
                      "id": 190859,
                      "title": "American Sniper",
                      "poster": "https://image.tmdb.org/t/p/w1280/svPHnYE7N5NAGO49dBmRhq0vDQ3.jpg",
                      "overview": "U.S. Navy SEAL Chris Kyle takes his sole missionprotect his comradesto heart and becomes one of the most lethal snipers in American history. His pinpoint accuracy not only saves countless lives but also makes him a prime",
                      "release_date": 1418256000
                    }
                  ],
                  "offset": 0,
                  "limit": 2,
                  "estimatedTotalHits": 976,
                  "processingTimeMs": 35,
                  "query": "american "
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "Index not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Index `movies` not found.",
                  "code": "index_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#index_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "search",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "var query = new SearchFacetsQuery()\n{\n  FacetQuery = \"fiction\",\n  Filter = \"rating > 3\"\n};\nawait client.Index(\"books\").FacetSearchAsync(\"genres\", query);"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").FacetSearch(&meilisearch.FacetSearchRequest{\n  FacetQuery: \"fiction\",\n  FacetName: \"genres\",\n  Filter: \"rating > 3\",\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('books').searchForFacetValues({\n  facetQuery: 'fiction',\n  facetName: 'genres'\n  filter: 'rating > 3'\n})"
          },
          {
            "lang": "Java",
            "source": "FacetSearchRequest fsr = FacetSearchRequest.builder().facetName(\"genres\").facetQuery(\"fiction\").filter(new String[]{\"rating > 3\"}).build();\nclient.index(\"books\").facetSearch(fsr);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->facetSearch(\n  (new FacetSearchQuery())\n      ->setFacetQuery('fiction')\n      ->setFacetName('genres')\n      ->setFilter(['rating > 3'])\n);"
          },
          {
            "lang": "Python",
            "source": "client.index('books').facet_search('genres', 'fiction', {\n  'filter': 'rating > 3'\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').facet_search('genres', 'fiction', filter: 'rating > 3')"
          },
          {
            "lang": "Rust",
            "source": "let res = client.index(\"books\")\n  .facet_search(\"genres\")\n  .with_facet_query(\"fiction\")\n  .with_filter(\"rating > 3\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/books/facet-search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"facetQuery\": \"fiction\",\n    \"facetName\": \"genres\",\n    \"filter\": \"rating > 3\"\n  }'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/search": {
      "get": {
        "tags": [
          "Indexes",
          "Search"
        ],
        "summary": "Search an index with GET",
        "description": "Search for documents matching a specific query in the given index.",
        "operationId": "search_with_url_query",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          },
          {
            "name": "q",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "vector",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "number",
                "format": "float"
              }
            },
            "explode": false
          },
          {
            "name": "offset",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "default": 0,
              "minimum": 0
            }
          },
          {
            "name": "limit",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "default": 20,
              "minimum": 0
            }
          },
          {
            "name": "page",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0
            }
          },
          {
            "name": "hitsPerPage",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0
            }
          },
          {
            "name": "attributesToRetrieve",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "explode": false
          },
          {
            "name": "retrieveVectors",
            "in": "query",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "attributesToCrop",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "explode": false
          },
          {
            "name": "cropLength",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "default": 10,
              "minimum": 0
            }
          },
          {
            "name": "attributesToHighlight",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "explode": false
          },
          {
            "name": "filter",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "distinct",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "showMatchesPosition",
            "in": "query",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "showRankingScore",
            "in": "query",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "showRankingScoreDetails",
            "in": "query",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "facets",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "explode": false
          },
          {
            "name": "highlightPreTag",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "default": "<em>"
            }
          },
          {
            "name": "highlightPostTag",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "default": "</em>"
            }
          },
          {
            "name": "cropMarker",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "default": ""
            }
          },
          {
            "name": "matchingStrategy",
            "in": "query",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/MatchingStrategy"
            }
          },
          {
            "name": "attributesToSearchOn",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "explode": false
          },
          {
            "name": "hybridEmbedder",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "hybridSemanticRatio",
            "in": "query",
            "required": true,
            "schema": {
              "type": "number",
              "format": "float"
            }
          },
          {
            "name": "rankingScoreThreshold",
            "in": "query",
            "required": true,
            "schema": {
              "type": "number",
              "format": "float"
            }
          },
          {
            "name": "locales",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Locale"
              }
            },
            "explode": false
          },
          {
            "name": "personalizeUserContext",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The documents are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResult"
                },
                "example": {
                  "hits": [
                    {
                      "id": 2770,
                      "title": "American Pie 2",
                      "poster": "https://image.tmdb.org/t/p/w1280/q4LNgUnRfltxzp3gf1MAGiK5LhV.jpg",
                      "overview": "The whole gang are back and as close as ever. They decide to get even closer by spending the summer together at a beach house. They decide to hold the biggest",
                      "release_date": 997405200
                    },
                    {
                      "id": 190859,
                      "title": "American Sniper",
                      "poster": "https://image.tmdb.org/t/p/w1280/svPHnYE7N5NAGO49dBmRhq0vDQ3.jpg",
                      "overview": "U.S. Navy SEAL Chris Kyle takes his sole missionprotect his comradesto heart and becomes one of the most lethal snipers in American history. His pinpoint accuracy not only saves countless lives but also makes him a prime",
                      "release_date": 1418256000
                    }
                  ],
                  "offset": 0,
                  "limit": 2,
                  "estimatedTotalHits": 976,
                  "processingTimeMs": 35,
                  "query": "american "
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "Index not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Index `movies` not found.",
                  "code": "index_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#index_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "search",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "JS",
            "source": "client.index('movies').searchGet('American ninja')"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/search?q=american%20ninja'"
          }
        ]
      },
      "post": {
        "tags": [
          "Indexes",
          "Search"
        ],
        "summary": "Search with POST",
        "description": "Search for documents matching a specific query in the given index.",
        "operationId": "search_with_post",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SearchQuery"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The documents are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResult"
                },
                "example": {
                  "hits": [
                    {
                      "id": 2770,
                      "title": "American Pie 2",
                      "poster": "https://image.tmdb.org/t/p/w1280/q4LNgUnRfltxzp3gf1MAGiK5LhV.jpg",
                      "overview": "The whole gang are back and as close as ever. They decide to get even closer by spending the summer together at a beach house. They decide to hold the biggest",
                      "release_date": 997405200
                    },
                    {
                      "id": 190859,
                      "title": "American Sniper",
                      "poster": "https://image.tmdb.org/t/p/w1280/svPHnYE7N5NAGO49dBmRhq0vDQ3.jpg",
                      "overview": "U.S. Navy SEAL Chris Kyle takes his sole missionprotect his comradesto heart and becomes one of the most lethal snipers in American history. His pinpoint accuracy not only saves countless lives but also makes him a prime",
                      "release_date": 1418256000
                    }
                  ],
                  "offset": 0,
                  "limit": 2,
                  "estimatedTotalHits": 976,
                  "processingTimeMs": 35,
                  "query": "american "
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "Index not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Index `movies` not found.",
                  "code": "index_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#index_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "search",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").SearchAsync<Movie>(\"American ninja\");"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').search('American ninja');"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").Search(\"american ninja\", &meilisearch.SearchRequest{})"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').search('American ninja')"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").search(\"American ninja\");"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->search('american ninja');"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').search('American ninja')"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').search('american ninja')"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Movie> = client\n  .index(\"movies\")\n  .search()\n  .with_query(\"american ninja\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(query: \"American ninja\")\nclient.index(\"movies\").search(searchParameters) { (result: Result<Searchable<Movie>, Swift.Error>) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{ \"q\": \"american ninja\" }'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "All settings",
        "description": "This route allows you to retrieve, configure, or reset all of an index's settings at once.",
        "operationId": "get_all",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "Settings are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Settings_Unchecked"
                },
                "example": {}
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetSettingsAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').getSettings();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").GetSettings()"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').getSettings()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").getSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->getSettings();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').get_settings()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').settings"
          },
          {
            "lang": "Rust",
            "source": "let settings: Settings = client\n  .index(\"movies\")\n  .get_settings()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").getSettings { (result) in\n    switch result {\n    case .success(let setting):\n        print(setting)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/settings'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset settings",
        "description": "Reset all the settings of an index to their default value.",
        "operationId": "delete_all",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").ResetSettingsAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').resetSettings();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").ResetSettings()"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').resetSettings()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").resetSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->resetSettings();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').reset_settings()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').reset_settings"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .reset_settings()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").resetSettings { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/settings'"
          }
        ]
      },
      "patch": {
        "tags": [
          "Settings"
        ],
        "summary": "Update settings",
        "description": "Update the settings of an index.\nPassing null to an index setting will reset it to its default value.\nUpdates in the settings route are partial. This means that any parameters not provided in the body will be left unchanged.\nIf the provided index does not exist, it will be created.",
        "operationId": "update_all",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Settings_Unchecked"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "Settings newSettings = new Settings\n{\n  RankingRules = new string[]\n  {\n    \"words\",\n    \"typo\",\n    \"proximity\",\n    \"attribute\",\n    \"sort\",\n    \"exactness\",\n    \"release_date:desc\",\n    \"rank:desc\"\n  },\n  DistinctAttribute = \"movie_id\",\n  SearchableAttributes = new string[] { \"title\", \"overview\", \"genres\" },\n  DisplayedAttributes = new string[] { \"title\", \"overview\", \"genres\", \"release_date\" },\n  SortableAttributes = new string[] { \"title\", \"release_date\" },\n  StopWords = new string[] { \"the\", \"a\", \"an\" },\n  Synonyms = new Dictionary<string, IEnumerable<string>>\n  {\n      { \"wolverine\", new string[] { \"xmen\", \"logan\" } },\n      { \"logan\", new string[] { \"wolverine\" } },\n  },\n  FilterableAttributes = new string[] { },\n  TypoTolerance = new TypoTolerance\n  {\n      DisableOnAttributes = new string[] { \"title\" },\n      MinWordSizeForTypos = new TypoTolerance.TypoSize\n      {\n          OneTypo = 8,\n          TwoTypos = 10\n      }\n  },\n  SearchCutoffMs = 150\n};\nTaskInfo task = await client.Index(\"movies\").UpdateSettingsAsync(newFilters);"
          },
          {
            "lang": "Go",
            "source": "distinctAttribute := \"movie_id\"\nsettings := meilisearch.Settings{\n  RankingRules: []string{\n    \"words\",\n    \"typo\",\n    \"proximity\",\n    \"attribute\",\n    \"sort\",\n    \"exactness\",\n    \"release_date:desc\",\n    \"rank:desc\",\n  },\n  DistinctAttribute: &distinctAttribute,\n  SearchableAttributes: []string{\n    \"title\",\n    \"overview\",\n    \"genres\",\n  },\n  DisplayedAttributes: []string{\n    \"title\",\n    \"overview\",\n    \"genres\",\n    \"release_date\",\n  },\n  StopWords: []string{\n    \"the\",\n    \"a\",\n    \"an\",\n  },\n  SortableAttributes: []string{\n    \"title\",\n    \"release_date\",\n  },\n  Synonyms: map[string][]string{\n    \"wolverine\": []string{\"xmen\", \"logan\"},\n    \"logan\":     []string{\"wolverine\"},\n  },\n  TypoTolerance: &meilisearch.TypoTolerance{\n    MinWordSizeForTypos: meilisearch.MinWordSizeForTypos{\n      OneTypo:  8,\n      TwoTypos: 10,\n    },\n    DisableOnAttributes: []string{\"title\"},\n  },\n  Pagination: &meilisearch.Pagination{\n    MaxTotalHits: 5000,\n  },\n  Faceting: &meilisearch.Faceting{\n    MaxValuesPerFacet: 200,\n  },\n  SearchCutoffMs: 150,\n}\nclient.Index(\"movies\").UpdateSettings(&settings)"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateSettings({\n    rankingRules: [\n        'words',\n        'typo',\n        'proximity',\n        'attribute',\n        'sort',\n        'exactness',\n        'release_date:desc',\n        'rank:desc'\n    ],\n    distinctAttribute: 'movie_id',\n    searchableAttributes: [\n        'title',\n        'overview',\n        'genres'\n    ],\n    displayedAttributes: [\n        'title',\n        'overview',\n        'genres',\n        'release_date'\n    ],\n    stopWords: [\n        'the',\n        'a',\n        'an'\n    ],\n    sortableAttributes: [\n      'title',\n      'release_date'\n    ],\n    synonyms: {\n        'wolverine': ['xmen', 'logan'],\n        'logan': ['wolverine']\n    },\n    typoTolerance: {\n        'minWordSizeForTypos': {\n            'oneTypo': 8,\n            'twoTypos': 10\n        },\n        'disableOnAttributes': [\n            'title'\n        ]\n    },\n    pagination: {\n        maxTotalHits: 5000\n    },\n    faceting: {\n        maxValuesPerFacet: 200\n    },\n    searchCutoffMs: 150\n})"
          },
          {
            "lang": "Java",
            "source": "Settings settings = new Settings();\nsettings.setRankingRules(\n  new String[] {\n      \"words\",\n      \"typo\",\n      \"proximity\",\n      \"attribute\",\n      \"sort\",\n      \"exactness\",\n      \"release_date:desc\",\n      \"rank:desc\"\n  });\nsettings.setDistinctAttribute(\"movie_id\");\nsettings.setSearchableAttributes(\n  new String[] {\n    \"title\",\n    \"overview\",\n    \"genres\"\n  });\nsettings.setDisplayedAttributes(\n  new String[] {\n    \"title\",\n    \"overview\",\n    \"genres\",\n    \"release_date\"\n  });\nsettings.setStopWords(\n  new String[] {\n    \"the\",\n    \"a\",\n    \"an\"\n  });\nsettings.setSortableAttributes(\n  new String[] {\n    \"title\",\n    \"release_date\"\n  });\n\nHashMap<String, String[]> synonyms = new HashMap<String, String[]>();\nsynonyms.put(\"wolverine\", new String[] {\"xmen\", \"logan\"});\nsynonyms.put(\"logan\", new String[] {\"wolverine\"});\nsettings.setSynonyms(synonyms);\n\nHashMap<String, Integer> minWordSizeTypos =\n  new HashMap<String, Integer>() {\n    {\n      put(\"oneTypo\", 8);\n      put(\"twoTypos\", 10);\n    }\n  };\nTypoTolerance typoTolerance = new TypoTolerance();\ntypoTolerance.setMinWordSizeForTypos(minWordSizeTypos);\nsettings.setTypoTolerance(typoTolerance);\nsettings.setSearchCutoffMs(150);\nclient.index(\"movies\").updateSettings(settings);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateSettings([\n  'rankingRules' => [\n    'words',\n    'typo',\n    'proximity',\n    'attribute',\n    'sort',\n    'exactness',\n    'release_date:desc',\n    'rank:desc'\n  ],\n  'distinctAttribute' => 'movie_id',\n  'searchableAttributes' => [\n    'title',\n    'overview',\n    'genres'\n  ],\n  'displayedAttributes' => [\n    'title',\n    'overview',\n    'genres',\n    'release_date'\n  ],\n  'stopWords' => [\n    'the',\n    'a',\n    'an'\n  ],\n  'sortableAttributes' => [\n    'title',\n    'release_date'\n  ],\n  'synonyms' => [\n    'wolverine' => ['xmen', 'logan'],\n    'logan' => ['wolverine']\n  ],\n  'typoTolerance' => [\n      'minWordSizeForTypos' => [\n        'oneTypo' => 8,\n        'twoTypos' => 10\n      ],\n      'disableOnAttributes' => ['title']\n  ],\n  'pagination' => [\n    'maxTotalHits' => 5000\n  ],\n  'faceting' => [\n    'maxValuesPerFacet' => 200\n  ],\n  'searchCutoffMs' => 150\n]);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_settings({\n  'rankingRules': [\n    'words',\n    'typo',\n    'proximity',\n    'attribute',\n    'sort',\n    'exactness',\n    'release_date:desc',\n    'rank:desc'\n  ],\n  'distinctAttribute': 'movie_id',\n  'searchableAttributes': [\n    'title',\n    'overview',\n    'genres'\n  ],\n  'displayedAttributes': [\n    'title',\n    'overview',\n    'genres',\n    'release_date'\n  ],\n  'sortableAttributes': [\n    'title',\n    'release_date'\n  ],\n  'stopWords': [\n    'the',\n    'a',\n    'an'\n  ],\n  'synonyms': {\n    'wolverine': ['xmen', 'logan'],\n    'logan': ['wolverine']\n  },\n  'typoTolerance': {\n    'minWordSizeForTypos': {\n        'oneTypo': 8,\n        'twoTypos': 10\n    },\n    'disableOnAttributes': ['title']\n  },\n  'pagination': {\n    'maxTotalHits': 5000\n  },\n  'faceting': {\n    'maxValuesPerFacet': 200\n  },\n  'searchCutoffMs': 150\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_settings({\n  ranking_rules: [\n    'words',\n    'typo',\n    'proximity',\n    'attribute',\n    'sort',\n    'exactness',\n    'release_date:desc',\n    'rank:desc'\n  ],\n  distinct_attribute: 'movie_id',\n  searchable_attributes: [\n    'title',\n    'overview',\n    'genres'\n  ],\n  displayed_attributes: [\n    'title',\n    'overview',\n    'genres',\n    'release_date'\n  ],\n  stop_words: [\n    'the',\n    'a',\n    'an'\n  ],\n  sortable_attributes: [\n    'title',\n    'release_date'\n  ],\n  synonyms: {\n    wolverine: ['xmen', 'logan'],\n    logan: ['wolverine']\n  },\n  pagination: {\n    max_total_hits: 5000\n  },\n  faceting: {\n    max_values_per_facet: 200\n  },\n  search_cutoff_ms: 150\n})"
          },
          {
            "lang": "Rust",
            "source": "let mut synonyms = std::collections::HashMap::new();\nsynonyms.insert(String::from(\"wolverine\"), vec![\"xmen\", \"logan\"]);\nsynonyms.insert(String::from(\"logan\"), vec![\"wolverine\"]);\n\nlet min_word_size_for_typos = MinWordSizeForTypos {\n  one_typo: Some(4),\n  two_typos; Some(12)\n}\nlet typo_tolerance = TypoToleranceSettings {\n  enabled: Some(true),\n  disable_on_attributes: Some(vec![\"title\".to_string()]),\n  disable_on_words: Some(vec![])\n  min_word_size_for_typos: Some(min_word_size_for_typos),\n};\n\nlet settings = Settings::new()\n  .with_ranking_rules([\n    \"words\",\n    \"typo\",\n    \"proximity\",\n    \"attribute\",\n    \"sort\",\n    \"exactness\",\n    \"release_date:desc\",\n    \"rank:desc\"\n  ])\n  .with_distinct_attribute(Some(\"movie_id\"))\n  .with_searchable_attributes([\n    \"title\",\n    \"overview\",\n    \"genres\"\n  ])\n  .with_displayed_attributes([\n    \"title\",\n    \"overview\",\n    \"genres\",\n    \"release_date\"\n  ])\n  .with_stop_words([\n    \"the\",\n    \"a\",\n    \"an\"\n  ])\n  .with_sortable_attributes([\n    \"title\",\n    \"release_date\"\n  ])\n  .with_synonyms(synonyms)\n  .with_typo_tolerance(typo_tolerance)\n  .with_search_cutoff(150);\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_settings(&settings)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let settings = Setting(rankingRules: [\n    \"words\",\n    \"typo\",\n    \"proximity\",\n    \"attribute\",\n    \"sort\",\n    \"exactness\",\n    \"release_date:desc\",\n    \"rank:desc\"\n], searchableAttributes: [\n    \"title\",\n    \"overview\",\n    \"genres\"\n], displayedAttributes: [\n    \"title\",\n    \"overview\",\n    \"genres\",\n    \"release_date\"\n], stopWords: [\n    \"the\",\n    \"a\",\n    \"an\"\n], synonyms: [\n    \"wolverine\": [\"xmen\", \"logan\"],\n    \"logan\": [\"wolverine\"]\n], distinctAttribute: \"movie_id\",\nsortableAttributes: [\n    \"title\",\n    \"release_date\"\n])\nclient.index(\"movies\").updateSettings(settings) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/movies/settings' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"rankingRules\": [\n      \"words\",\n      \"typo\",\n      \"proximity\",\n      \"attribute\",\n      \"sort\",\n      \"exactness\",\n      \"release_date:desc\",\n      \"rank:desc\"\n    ],\n    \"distinctAttribute\": \"movie_id\",\n    \"searchableAttributes\": [\n      \"title\",\n      \"overview\",\n      \"genres\"\n    ],\n    \"displayedAttributes\": [\n      \"title\",\n      \"overview\",\n      \"genres\",\n      \"release_date\"\n    ],\n    \"stopWords\": [\n      \"the\",\n      \"a\",\n      \"an\"\n    ],\n    \"sortableAttributes\": [\n      \"title\",\n      \"release_date\"\n    ],\n    \"synonyms\": {\n      \"wolverine\": [\n        \"xmen\",\n        \"logan\"\n    ],\n      \"logan\": [\"wolverine\"]\n    },\n    \"typoTolerance\": {\n      \"minWordSizeForTypos\": {\n        \"oneTypo\": 8,\n        \"twoTypos\": 10\n      },\n      \"disableOnAttributes\": [\"title\"]\n    },\n    \"pagination\": {\n      \"maxTotalHits\": 5000\n    },\n    \"faceting\": {\n      \"maxValuesPerFacet\": 200\n    },\n    \"searchCutoffMs\": 150\n  }'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/chat": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get chat",
        "description": "Get an user defined chat",
        "operationId": "getchat",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "chat is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatSettings"
                },
                "example": {}
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset chat",
        "description": "Reset an index's chat to its default value",
        "operationId": "deletechat",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ]
      },
      "patch": {
        "tags": [
          "Settings"
        ],
        "summary": "Update chat",
        "description": "Update an index's user defined chat",
        "operationId": "patchchat",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/dictionary": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get dictionary",
        "description": "Get an user defined dictionary",
        "operationId": "getdictionary",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "dictionary is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "uniqueItems": true
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "var indexDictionary = await client.Index(\"books\").GetDictionaryAsync();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").GetDictionary()"
          },
          {
            "lang": "JS",
            "source": "client.index('books').getDictionary()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").getDictionarySettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->getDictionary();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').get_dictionary()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').dictionary"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index('books')\n  .get_dictionary()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"books\").getDictionary { result in\n  // handle result\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/books/settings/dictionary'"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update dictionary",
        "description": "Update an index's user defined dictionary",
        "operationId": "putdictionary",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "var newDictionary = new string[] { \"J. R. R.\", \"W. E. B.\" };\nawait client.Index(\"books\").UpdateDictionaryAsync(newDictionary);"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").UpdateDictionary([]string{\n  \"J. R. R.\",\n  \"W. E. B.\",\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('books').updateDictionary(['J. R. R.', 'W. E. B.'])"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").updateDictionarySettings(new String[] {\"J. R. R.\", \"W. E. B.\"});"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->updateDictionary(['J. R. R.', 'W. E. B.']);"
          },
          {
            "lang": "Python",
            "source": "client.index('books').update_dictionary([\"J. R. R.\", \"W. E. B.\"])"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').update_dictionary(['J. R. R.', 'W. E. B.'])"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index('books')\n  .set_dictionary(['J. R. R.', 'W. E. B.'])\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"books\").updateDictionary([\"J. R. R.\", \"W. E. B.\"]) { result in\n  // handle result\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/books/settings/dictionary' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"J. R. R.\",\n    \"W. E. B.\"\n  ]'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset dictionary",
        "description": "Reset an index's dictionary to its default value",
        "operationId": "deletedictionary",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"books\").ResetDictionaryAsync();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").ResetDictionary()"
          },
          {
            "lang": "JS",
            "source": "client.index('books').resetDictionary()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").resetDictionarySettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->resetDictionary();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').reset_dictionary()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').reset_dictionary"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index('books')\n  .reset_dictionary()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"books\").resetDictionary { result in\n  // handle result\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/books/settings/dictionary'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/displayed-attributes": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get displayedAttributes",
        "description": "Get an user defined displayedAttributes",
        "operationId": "getdisplayedAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "displayedAttributes is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetDisplayedAttributesAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').getDisplayedAttributes();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").GetDisplayedAttributes()"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').getDisplayedAttributes()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").getDisplayedAttributesSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->getDisplayedAttributes();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').get_displayed_attributes()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').get_displayed_attributes"
          },
          {
            "lang": "Rust",
            "source": "let displayed_attributes: Vec<String> = client\n  .index(\"movies\")\n  .get_displayed_attributes()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").getDisplayedAttributes { (result) in\n    switch result {\n    case .success(let displayedAttributes):\n        print(displayedAttributes)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/settings/displayed-attributes'"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update displayedAttributes",
        "description": "Update an index's user defined displayedAttributes",
        "operationId": "putdisplayedAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").UpdateDisplayedAttributesAsync(new[]\n{\n  \"title\",\n  \"overview\",\n  \"genres\",\n  \"release_date\"\n});"
          },
          {
            "lang": "Go",
            "source": "displayedAttributes := []string{\n  \"title\",\n  \"overview\",\n  \"genres\",\n  \"release_date\",\n}\nclient.Index(\"movies\").UpdateDisplayedAttributes(&displayedAttributes)"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateDisplayedAttributes([\n  'title',\n  'overview',\n  'genres',\n  'release_date'\n])"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").updateDisplayedAttributesSettings(new String[]\n{\n  \"title\",\n  \"overview\",\n  \"genres\",\n  \"release_date\"\n});"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateDisplayedAttributes([\n  'title',\n  'overview',\n  'genres',\n  'release_date'\n]);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_displayed_attributes([\n    'title',\n    'overview',\n    'genres',\n    'release_date'\n])"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_displayed_attributes([\n  'title',\n  'overview',\n  'genres',\n  'release_date'\n])"
          },
          {
            "lang": "Rust",
            "source": "let displayed_attributes = [\n  \"title\",\n  \"overview\",\n  \"genres\",\n  \"release_date\"\n];\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_displayed_attributes(&displayed_attributes)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let displayedAttributes: [String] = [\"title\", \"overview\", \"genres\", \"release_date\"]\nclient.index(\"movies\").updateDisplayedAttributes(displayedAttributes) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/displayed-attributes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"title\",\n    \"overview\",\n    \"genres\",\n    \"release_date\"\n  ]'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset displayedAttributes",
        "description": "Reset an index's displayedAttributes to its default value",
        "operationId": "deletedisplayedAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").ResetDisplayedAttributesAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').resetDisplayedAttributes();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").ResetDisplayedAttributes()"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').resetDisplayedAttributes()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").resetDisplayedAttributesSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->resetDisplayedAttributes();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').reset_displayed_attributes()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').reset_displayed_attributes"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .reset_displayed_attributes()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").resetDisplayedAttributes { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/settings/displayed-attributes'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/distinct-attribute": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get distinctAttribute",
        "description": "Get an user defined distinctAttribute",
        "operationId": "getdistinctAttribute",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "distinctAttribute is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                },
                "example": ""
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "string result = await client.Index(\"shoes\").GetDistinctAttributeAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('shoes').getDistinctAttribute();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"shoes\").GetDistinctAttribute()"
          },
          {
            "lang": "JS",
            "source": "client.index('shoes').getDistinctAttribute()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"shoes\").getDistinctAttributeSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('shoes')->getDistinctAttribute();"
          },
          {
            "lang": "Python",
            "source": "client.index('shoes').get_distinct_attribute()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('shoes').distinct_attribute"
          },
          {
            "lang": "Rust",
            "source": "let distinct_attribute: Option<String> = client\n  .index(\"shoes\")\n  .get_distinct_attribute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"shoes\").getDistinctAttribute { (result) in\n    switch result {\n    case .success(let distinctAttribute):\n        print(distinctAttribute)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/shoes/settings/distinct-attribute'"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update distinctAttribute",
        "description": "Update an index's user defined distinctAttribute",
        "operationId": "putdistinctAttribute",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "TaskInfo result = await client.Index(\"shoes\").UpdateDistinctAttributeAsync(\"skuid\");"
          },
          {
            "lang": "Dart",
            "source": "await client.index('shoes').updateDistinctAttribute('skuid');"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"shoes\").UpdateDistinctAttribute(\"skuid\")"
          },
          {
            "lang": "JS",
            "source": "client.index('shoes').updateDistinctAttribute('skuid')"
          },
          {
            "lang": "Java",
            "source": "client.index(\"shoes\").updateDistinctAttributeSettings(\"skuid\");"
          },
          {
            "lang": "PHP",
            "source": "$client->index('shoes')->updateDistinctAttribute('skuid');"
          },
          {
            "lang": "Python",
            "source": "client.index('shoes').update_distinct_attribute('skuid')"
          },
          {
            "lang": "Ruby",
            "source": "client.index('shoes').update_distinct_attribute('skuid')"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"shoes\")\n  .set_distinct_attribute(\"skuid\")\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"shoes\").updateDistinctAttribute(\"skuid\") { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/shoes/settings/distinct-attribute' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '\"skuid\"'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset distinctAttribute",
        "description": "Reset an index's distinctAttribute to its default value",
        "operationId": "deletedistinctAttribute",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "TaskInfo result = await client.Index(\"shoes\").ResetDistinctAttributeAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('shoes').resetDistinctAttribute();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"shoes\").ResetDistinctAttribute()"
          },
          {
            "lang": "JS",
            "source": "client.index('shoes').resetDistinctAttribute()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"shoes\").resetDistinctAttributeSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('shoes')->resetDistinctAttribute();"
          },
          {
            "lang": "Python",
            "source": "client.index('shoes').reset_distinct_attribute()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('shoes').reset_distinct_attribute"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"shoes\")\n  .reset_distinct_attribute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"shoes\").resetDistinctAttribute { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/shoes/settings/distinct-attribute'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/embedders": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get embedders",
        "description": "Get an user defined embedders",
        "operationId": "getembedders",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "embedders is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/SettingEmbeddingSettings"
                  },
                  "propertyNames": {
                    "type": "string"
                  }
                },
                "example": {}
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_NAME').embedders"
          },
          {
            "lang": "Rust",
            "source": "let embedders = index.get_embedders().await.unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/INDEX_NAME/settings/embedders'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset embedders",
        "description": "Reset an index's embedders to its default value",
        "operationId": "deleteembedders",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/SettingEmbeddingSettings"
                },
                "propertyNames": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_NAME').reset_embedders"
          },
          {
            "lang": "Rust",
            "source": "index.reset_embedders().await.unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/INDEX_NAME/settings/embedders'"
          }
        ]
      },
      "patch": {
        "tags": [
          "Settings"
        ],
        "summary": "Update embedders",
        "description": "Update an index's user defined embedders",
        "operationId": "patchembedders",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/SettingEmbeddingSettings"
                },
                "propertyNames": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').updateEmbedders({\n  default: {\n    source: 'openAi',\n    apiKey: 'OPEN_AI_API_KEY',\n    model: 'text-embedding-3-small',\n    documentTemplate: 'A document titled '{{doc.title}}' whose description starts with {{doc.overview|truncatewords: 20}}'\n  }\n});"
          },
          {
            "lang": "PHP",
            "source": "$client->updateEmbedders([\n  'default' => [\n    'source' => 'openAi',\n    'apiKey' => 'OPEN_AI_API_KEY',\n    'model' => 'text-embedding-3-small',\n    'documentTemplate' => 'A document titled '{{doc.title}}' whose description starts with {{doc.overview|truncatewords: 20}}'\n  ]\n]);"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_NAME').update_embedders(\n  default: {\n    source:  'openAi',\n    api_key: 'OPEN_AI_API_KEY',\n    model: 'text-embedding-3-small',\n    document_template: \"A document titled '{{doc.title}}' whose description starts with {{doc.overview|truncatewords: 20}}\"\n  }\n)"
          },
          {
            "lang": "Rust",
            "source": "let embedders = HashMap::from([(\n  String::from(\"default\"),\n  Embedder {\n    source: EmbedderSource::OpenAi,\n    api_key: Some(String::from(\"OPEN_AI_API_KEY\")),\n    model: Some(String::from(\"text-embedding-3-small\")),\n    document_template: Some(String::from(\"A document titled '{{doc.title}}' whose description starts with {{doc.overview|truncatewords: 20}}\")),\n    ..Embedder::default()\n  }\n)]);\nlet task = index\n  .set_embedders(&embedders)\n  .await\n  .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/INDEX_NAME/settings/embedders' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"default\": {\n      \"source\":  \"openAi\",\n      \"apiKey\": \"OPEN_AI_API_KEY\",\n      \"model\": \"text-embedding-3-small\",\n      \"documentTemplate\": \"A document titled '{{doc.title}}' whose description starts with {{doc.overview|truncatewords: 20}}\"\n    }\n  }'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/facet-search": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get facetSearch",
        "description": "Get an user defined facetSearch",
        "operationId": "getfacetSearch",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "facetSearch is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "boolean"
                },
                "example": false
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "Go",
            "source": "client.Index(\"books\").GetFacetSearch()"
          },
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').getFacetSearch();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('INDEX_NAME')->getFacetSearch();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').get_facet_search_settings()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_UID').facet_search_setting"
          },
          {
            "lang": "Rust",
            "source": "let facet_search: bool = client\n  .index(INDEX_UID)\n  .get_facet_search()\n  .await\n  .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/INDEX_UID/settings/facet-search'"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update facetSearch",
        "description": "Update an index's user defined facetSearch",
        "operationId": "putfacetSearch",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "text/plain": {
              "schema": {
                "type": "boolean"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "Go",
            "source": "client.Index(\"books\").UpdateFacetSearch(false)"
          },
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').updateFacetSearch(false);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('INDEX_NAME')->updateFacetSearch(false);"
          },
          {
            "lang": "Python",
            "source": "client.index('books').update_facet_search_settings(False)"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_UID').update_facet_search_setting(false)"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(INDEX_UID)\n  .set_facet_search(false)\n  .await\n  .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/INDEX_UID/settings/facet-search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary 'false'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset facetSearch",
        "description": "Reset an index's facetSearch to its default value",
        "operationId": "deletefacetSearch",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "text/plain": {
              "schema": {
                "type": "boolean"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "Go",
            "source": "client.Index(\"books\").ResetFacetSearch()"
          },
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').resetFacetSearch();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('INDEX_NAME')->resetFacetSearch();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').reset_facet_search_settings()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_UID').reset_facet_search_setting"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(INDEX_UID)\n  .reset_facet_search()\n  .await\n  .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/INDEX_UID/settings/facet-search'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/faceting": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get faceting",
        "description": "Get an user defined faceting",
        "operationId": "getfaceting",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "faceting is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FacetingSettings"
                },
                "example": {}
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetFacetingAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').getFaceting();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").GetFaceting()"
          },
          {
            "lang": "JS",
            "source": "client.index('books').getFaceting()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").getFacetingSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->getFaceting();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').get_faceting_settings()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').faceting"
          },
          {
            "lang": "Rust",
            "source": "let faceting: FacetingSettings = client\n  .index(\"books\")\n  .get_faceting()\n  .await\n  .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/books/settings/faceting'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset faceting",
        "description": "Reset an index's faceting to its default value",
        "operationId": "deletefaceting",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FacetingSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").ResetFacetingAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').resetFaceting();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").ResetFaceting()"
          },
          {
            "lang": "JS",
            "source": "client.index('books').resetFaceting()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").resetFacetingSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->resetFaceting();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').reset_faceting_settings()"
          },
          {
            "lang": "Ruby",
            "source": "index('books').reset_faceting"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"books\")\n  .reset_faceting()\n  .await\n  .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/books/settings/faceting'"
          }
        ]
      },
      "patch": {
        "tags": [
          "Settings"
        ],
        "summary": "Update faceting",
        "description": "Update an index's user defined faceting",
        "operationId": "patchfaceting",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FacetingSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "var faceting = new Faceting\n{\n    MaxValuesPerFacet = 2,\n    SortFacetValuesBy = new Dictionary<string, SortFacetValuesByType>\n    {\n        [\"*\"] = SortFacetValuesByType.Alpha,\n        [\"genres\"] = SortFacetValuesByType.Count\n    }\n};\nawait client.Index(\"books\").UpdateFacetingAsync(faceting);"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").UpdateFaceting(&meilisearch.Faceting{\n    MaxValuesPerFacet: 2,\n    SortFacetValuesBy: {\n       \"*\":      SortFacetTypeAlpha,\n       \"genres\": SortFacetTypeCount,\n    }\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('books').updateFaceting({\n  maxValuesPerFacet: 2\n  sortFacetValuesBy: {\n    '*': 'alpha',\n    genres: 'count'\n  }\n})"
          },
          {
            "lang": "Java",
            "source": "Faceting newFaceting = new Faceting();\nnewFaceting.setMaxValuesPerFacet(2);\nHashMap<String, FacetSortValue> facetSortValues = new HashMap<>();\nfacetSortValues.put(\"*\", FacetSortValue.ALPHA);\nfacetSortValues.put(\"genres\", FacetSortValue.COUNT);\nnewFaceting.setSortFacetValuesBy(facetSortValues);\nclient.index(\"books\").updateFacetingSettings(newFaceting);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->updateFaceting([\n  'maxValuesPerFacet' => 2,\n  'sortFacetValuesBy' => ['*' => 'alpha', 'genres' => 'count']\n]);"
          },
          {
            "lang": "Python",
            "source": "params = {\n  'maxValuesPerFacet': 2,\n  'sortFacetValuesBy': {\n      '*': 'count',\n      'genres': 'count'\n    }\n}\nclient.index('books').update_faceting_settings(params)"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').update_faceting({\n  max_values_per_facet: 2,\n  sort_facet_values_by: {\n    '*': 'alpha',\n    genres: 'count'\n  }\n})"
          },
          {
            "lang": "Rust",
            "source": "let mut facet_sort_setting = BTreeMap::new();\nfacet_sort_setting.insert(String::from(\"*\"), FacetSortValue::Alpha);\nfacet_sort_setting.insert(String::from(\"genres\"), FacetSortValue::Count);\nlet mut faceting = FacetingSettings {\n  max_values_per_facet: 2,\n  sort_facet_values_by: Some(facet_sort_setting),\n};\n\nlet task: TaskInfo = client\n  .index(\"books\")\n  .set_faceting(&faceting)\n  .await\n  .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/books/settings/faceting' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"maxValuesPerFacet\": 2,\n    \"sortFacetValuesBy\": {\n      \"*\": \"alpha\",\n      \"genres\": \"count\"\n    }\n  }'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/filterable-attributes": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get filterableAttributes",
        "description": "Get an user defined filterableAttributes",
        "operationId": "getfilterableAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "filterableAttributes is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/FilterableAttributesRule"
                  }
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "IEnumerable<string> attributes = await client.Index(\"movies\").GetFilterableAttributesAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').getFilterableAttributes();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").GetFilterableAttributes()"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').getFilterableAttributes()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").getFilterableAttributesSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->getFilterableAttributes();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').get_filterable_attributes()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').filterable_attributes"
          },
          {
            "lang": "Rust",
            "source": "let filterable_attributes: Vec<String> = client\n  .index(\"movies\")\n  .get_filterable_attributes()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").getFilterableAttributes { (result) in\n    switch result {\n    case .success(let attributes):\n        print(attributes)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/settings/filterable-attributes'"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update filterableAttributes",
        "description": "Update an index's user defined filterableAttributes",
        "operationId": "putfilterableAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/FilterableAttributesRule"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "List<string> attributes = new() { \"genres\", \"director\" };\nTaskInfo result = await client.Index(\"movies\").UpdateFilterableAttributesAsync(attributes);"
          },
          {
            "lang": "Go",
            "source": "filterableAttributes := []interface{}{\n  \"genres\",\n  \"director\",\n  AttributeRule{\n    AttributePatterns: []string{\"tag\"}\n    Features: AttributeFeatures{\n      FacetSearch: false,\n      Filter: FilterFeatures{\n        Equality:   true,\n        Comparison: false,\n      }\n    }\n  },\n  map[string]interface{}{\n    \"attributePatterns\": []interface{}{\"year\"}\n    \"features\": map[string]interface{}{\n      \"facetSearch\": false,\n      \"filter\": map[string]interface{}{\n        \"equality\":   true,\n        \"comparison\": true,\n      }\n    }\n  }\n}\nclient.Index(\"movies\").UpdateFilterableAttributes(&filterableAttributes)"
          },
          {
            "lang": "JS",
            "source": "client.index('movies')\n  .updateFilterableAttributes([\n    \"genres\",\n    {\n      attributePatterns: [\"genre\"],\n      features: {\n        facetSearch: true,\n        filter: { equality: true, comparison: false },\n      },\n    }\n  ])"
          },
          {
            "lang": "Java",
            "source": "Settings settings = new Settings();\nsettings.setFilterableAttributes(new String[] {\"genres\", \"director\"});\nclient.index(\"movies\").updateSettings(settings);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateFilterableAttributes([\n  'author',\n  [\n      'attributePatterns' => ['genres'],\n      'features' => [\n          'facetSearch' => true,\n          'filter' => [\n              'equality' => true,\n              'comparison' => false,\n          ],\n      ],\n  ],\n]);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_filterable_attributes([\n  'genres',\n  'director'\n])"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_filterable_attributes([\n  'genres',\n  'director'\n])"
          },
          {
            "lang": "Rust",
            "source": "let filterable_attributes = [\n  \"genres\",\n  \"director\"\n];\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_filterable_attributes(&filterable_attributes)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").updateFilterableAttributes([\"genre\", \"director\"]) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/filterable-attributes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"genres\",\n    \"director\",\n    {\n      \"attributePatterns\": [\"*_ratings\"],\n      \"features\": {\n        \"facetSearch\": false,\n        \"filter\": {\n          \"equality\": true,\n          \"comparison\": false\n        }\n      }\n    }\n  ]'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset filterableAttributes",
        "description": "Reset an index's filterableAttributes to its default value",
        "operationId": "deletefilterableAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/FilterableAttributesRule"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "TaskInfo result = await client.Index(\"movies\").ResetFilterableAttributesAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').resetFilterableAttributes();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").ResetFilterableAttributes()"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').resetFilterableAttributes()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").resetFilterableAttributesSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->resetFilterableAttributes();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').reset_filterable_attributes()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').reset_filterable_attributes"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .reset_filterable_attributes()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").resetFilterableAttributes { (result) in\n    switch result {\n    case .success(let attributes):\n        print(attributes)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/settings/filterable-attributes'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/localized-attributes": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get localizedAttributes",
        "description": "Get an user defined localizedAttributes",
        "operationId": "getlocalizedAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "localizedAttributes is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/LocalizedAttributesRuleView"
                  }
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "Go",
            "source": "client.index(\"INDEX_NAME\").GetLocalizedAttributes()"
          },
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').getLocalizedAttributes()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"INDEX_NAME\").getLocalizedAttributesSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('INDEX_NAME')->getLocalizedAttributes();"
          },
          {
            "lang": "Python",
            "source": "client.index('INDEX_NAME').get_localized_attributes()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_NAME').localized_attributes"
          },
          {
            "lang": "Rust",
            "source": "let localized_attributes: Option<Vec<LocalizedAttributes>> = client\n  .index(\"books\")\n  .get_localized_attributes()\n  .await\n  .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/INDEX_NAME/settings/localized-attributes'"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update localizedAttributes",
        "description": "Update an index's user defined localizedAttributes",
        "operationId": "putlocalizedAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/LocalizedAttributesRuleView"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "Go",
            "source": "client.index(\"INDEX_NAME\").UpdateLocalizedAttributes([]*LocalizedAttributes{\n    { AttributePatterns: [\"*_ja\"], Locales: [\"jpn\"] },\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').updateLocalizedAttributes([\n  { attributePatterns: ['*_ja'], locales: ['jpn'] },\n])"
          },
          {
            "lang": "Java",
            "source": "LocalizedAttribute attribute = new LocalizedAttribute();\nattribute.setAttributePatterns(new String[] {\"jpn\"});\nattribute.setLocales(new String[] {\"*_ja\"});\n\nclient.index(\"INDEX_NAME\").updateLocalizedAttributesSettings(\n  new LocalizedAttributes[] {attribute}\n);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('INDEX_NAME')->updateLocalizedAttributes([\n  'locales' => ['jpn'],\n  'attributePatterns' => ['*_ja']\n]);"
          },
          {
            "lang": "Python",
            "source": "client.index('INDEX_NAME').update_localized_attributes([\n  {'attribute_patterns': ['*_ja'], 'locales': ['jpn']}\n])"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_NAME').update_localized_attributes([\n  { attribute_patterns: ['*_ja'], locales: ['jpn'] },\n])"
          },
          {
            "lang": "Rust",
            "source": "let localized_attributes = vec![LocalizedAttributes {\n    locales: vec![\"jpn\".to_string()],\n    attribute_patterns: vec![\"*_ja\".to_string()],\n}];\nlet task: TaskInfo = client\n  .index(\"books\")\n  .set_localized_attributes(&localizced_attributes)\n  .await\n  .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/INDEX_NAME/settings/localized-attributes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    {\"locales\": [\"jpn\"], \"attributePatterns\": [\"*_ja\"]}\n  ]'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset localizedAttributes",
        "description": "Reset an index's localizedAttributes to its default value",
        "operationId": "deletelocalizedAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/LocalizedAttributesRuleView"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "Go",
            "source": "client.index(\"INDEX_NAME\").ResetLocalizedAttributes()"
          },
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').resetLocalizedAttributes()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"INDEX_NAME\").resetLocalizedAttributesSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('INDEX_NAME')->resetLocalizedAttributes();"
          },
          {
            "lang": "Python",
            "source": "client.index('INDEX_NAME').reset_localized_attributes()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_NAME').reset_localized_attributes"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"books\")\n  .reset_localized_attributes()\n  .await\n  .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/INDEX_NAME/settings/localized-attributes'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/non-separator-tokens": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get nonSeparatorTokens",
        "description": "Get an user defined nonSeparatorTokens",
        "operationId": "getnonSeparatorTokens",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "nonSeparatorTokens is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "uniqueItems": true
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetNonSeparatorTokensAsync();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"articles\").GetNonSeparatorTokens()"
          },
          {
            "lang": "JS",
            "source": "client.index('books').getNonSeparatorTokens()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"articles\").getNonSeparatorTokensSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('articles')->getNonSeparatorTokens();"
          },
          {
            "lang": "Python",
            "source": "client.index('articles').get_non_separator_tokens()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('articles').non_separator_tokens"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index('articles')\n  .get_non_separator_tokens()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"books\").getNonSeparatorTokens { result in\n  // handle result\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/articles/settings/non-separator-tokens'"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update nonSeparatorTokens",
        "description": "Update an index's user defined nonSeparatorTokens",
        "operationId": "putnonSeparatorTokens",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").UpdateNonSeparatorTokensAsync(new[] { \"@\", \"#\" });"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"articles\").UpdateNonSeparatorTokens([]string{\n  \"@\",\n  \"#\",\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('books').updateNonSeparatorTokens(['@', '#'])"
          },
          {
            "lang": "Java",
            "source": "String[] newSeparatorTokens = { \"@\", \"#\" };\nclient.index(\"articles\").updateNonSeparatorTokensSettings(newSeparatorTokens);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('articles')->updateNonSeparatorTokens(['@', '#']);"
          },
          {
            "lang": "Python",
            "source": "client.index('articles').update_non_separator_tokens([\"@\", \"#\"])"
          },
          {
            "lang": "Ruby",
            "source": "client.index('articles').update_non_separator_tokens(['@', '#'])"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index('articles')\n  .set_non_separator_tokens(&vec!['@'.to_string(), '#'.to_string()])\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"books\").updateNonSeparatorTokens([\"@\", \"#\"]) { result in\n  // handle result\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/articles/settings/non-separator-tokens' \\\n  -H 'Content-Type: application/json'  \\\n  --data-binary '[\"@\", \"#\"]'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset nonSeparatorTokens",
        "description": "Reset an index's nonSeparatorTokens to its default value",
        "operationId": "deletenonSeparatorTokens",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").ResetNonSeparatorTokensAsync();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"articles\").ResetNonSeparatorTokens()"
          },
          {
            "lang": "JS",
            "source": "client.index('books').resetNonSeparatorTokens()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"articles\").resetNonSeparatorTokensSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('articles')->resetNonSeparatorTokens();"
          },
          {
            "lang": "Python",
            "source": "client.index('articles').reset_non_separator_tokens()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('articles').reset_non_separator_tokens"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index('articles')\n  .reset_non_separator_tokens()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"books\").resetNonSeparatorTokens { result in\n  // handle result\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/articles/settings/non-separator-tokens'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/pagination": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get pagination",
        "description": "Get an user defined pagination",
        "operationId": "getpagination",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "pagination is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginationSettings"
                },
                "example": {}
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetPaginationAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').getPagination();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").GetPagination()"
          },
          {
            "lang": "JS",
            "source": "client.index('books').getPagination()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").getPaginationSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->getPagination();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').get_pagination_settings()"
          },
          {
            "lang": "Ruby",
            "source": "index('books').pagination"
          },
          {
            "lang": "Rust",
            "source": "let pagination: PaginationSetting = client\n  .index(\"books\")\n  .get_pagination()\n  .await\n  .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/books/settings/pagination'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset pagination",
        "description": "Reset an index's pagination to its default value",
        "operationId": "deletepagination",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PaginationSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").ResetPaginationAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').resetPagination();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").ResetPagination()"
          },
          {
            "lang": "JS",
            "source": "client.index('books').resetPagination()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").resetPaginationSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->resetPagination();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').reset_pagination_settings()"
          },
          {
            "lang": "Ruby",
            "source": "index('books').reset_pagination"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"books\")\n  .reset_pagination()\n  .await\n  .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/books/settings/pagination'"
          }
        ]
      },
      "patch": {
        "tags": [
          "Settings"
        ],
        "summary": "Update pagination",
        "description": "Update an index's user defined pagination",
        "operationId": "patchpagination",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PaginationSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "var pagination = new Pagination {\n  MaxTotalHits = 20\n};\nawait client.Index(\"movies\").UpdatePaginationAsync(pagination);"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").UpdatePagination(&meilisearch.Pagination{\n    MaxTotalHits: 100,\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('books').updateSettings({ pagination: { maxTotalHits: 100 }})"
          },
          {
            "lang": "Java",
            "source": "Pagination newPagination = new Pagination();\nnewPagination.setMaxTotalHits(100);\nclient.index(\"books\").updatePaginationSettings(newPagination);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->updateSettings([\n  'pagination' => [\n    'maxTotalHits' => 100\n  ]\n]);"
          },
          {
            "lang": "Python",
            "source": "client.index('books').update_pagination_settings({'maxTotalHits': 100})"
          },
          {
            "lang": "Ruby",
            "source": "index('books').update_pagination({ max_total_hits: 100 })"
          },
          {
            "lang": "Rust",
            "source": "let pagination = PaginationSetting {max_total_hits:100};\n\nlet task: TaskInfo = client\n  .index(\"books\")\n  .set_pagination(pagination)\n  .await\n  .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/books/settings/pagination' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"maxTotalHits\": 100\n  }'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/prefix-search": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get prefixSearch",
        "description": "Get an user defined prefixSearch",
        "operationId": "getprefixSearch",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "prefixSearch is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PrefixSearchSettings"
                },
                "example": "indexingTime"
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "Go",
            "source": "client.Index(\"books\").GetPrefixSearch()"
          },
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').getPrefixSearch();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('INDEX_NAME')->getPrefixSearch();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').get_prefix_search()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_UID').prefix_search"
          },
          {
            "lang": "Rust",
            "source": "let prefix_search: PrefixSearchSettings = client\n  .index(INDEX_UID)\n  .get_prefix_search()\n  .await\n  .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/INDEX_UID/settings/prefix-search'"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update prefixSearch",
        "description": "Update an index's user defined prefixSearch",
        "operationId": "putprefixSearch",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PrefixSearchSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "Go",
            "source": "client.Index(\"books\").UpdatePrefixSearch(\"disabled\")"
          },
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').updatePrefixSearch('disabled');"
          },
          {
            "lang": "PHP",
            "source": "$client->index('INDEX_NAME')->updatePrefixSearch('disabled');"
          },
          {
            "lang": "Python",
            "source": "client.index('books').update_prefix_search(PrefixSearch.DISABLED)"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_UID').update_prefix_search('disabled')"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(INDEX_UID)\n  .set_prefix_search(PrefixSearchSettings::Disabled)\n  .await\n  .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/INDEX_UID/settings/prefix-search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '\"disabled\"'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset prefixSearch",
        "description": "Reset an index's prefixSearch to its default value",
        "operationId": "deleteprefixSearch",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PrefixSearchSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "Go",
            "source": "client.Index(\"books\").ResetPrefixSearch()"
          },
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').resetPrefixSearch();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('INDEX_NAME')->resetPrefixSearch();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').reset_prefix_search()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_UID').reset_prefix_search"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(INDEX_UID)\n  .reset_prefix_search()\n  .await\n  .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/INDEX_UID/settings/prefix-search'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/proximity-precision": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get proximityPrecision",
        "description": "Get an user defined proximityPrecision",
        "operationId": "getproximityPrecision",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "proximityPrecision is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProximityPrecisionView"
                },
                "example": "byWord"
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"books\").GetProximityPrecisionAsync();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").GetProximityPrecision()"
          },
          {
            "lang": "JS",
            "source": "client.index('books').getProximityPrecision()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").getProximityPrecisionSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->getProximityPrecision();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').get_proximity_precision()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').proximity_precision"
          },
          {
            "lang": "Rust",
            "source": "let proximity_precision: String = client\n  .index(\"books\")\n  .get_proximity_precision()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let precisionValue = try await self.client.index(\"books\").getProximityPrecision()"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/books/settings/proximity-precision'"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update proximityPrecision",
        "description": "Update an index's user defined proximityPrecision",
        "operationId": "putproximityPrecision",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ProximityPrecisionView"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"books\").UpdateProximityPrecisionAsync(\"byAttribute\");"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").UpdateProximityPrecision(ByAttribute)"
          },
          {
            "lang": "JS",
            "source": "client.index('books').updateProximityPrecision('byAttribute')"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").updateProximityPrecisionSettings(\"byAttribute\");"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->updateProximityPrecision('byAttribute');"
          },
          {
            "lang": "Python",
            "source": "client.index('books').update_proximity_precision(ProximityPrecision.BY_ATTRIBUTE)"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').update_proximity_precision('byAttribute')"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"books\")\n  .set_proximity_precision(\"byAttribute\".to_string())\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let task = try await self.client.index(\"books\").updateProximityPrecision(.byWord)"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/books/settings/proximity-precision' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '\"byAttribute\"'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset proximityPrecision",
        "description": "Reset an index's proximityPrecision to its default value",
        "operationId": "deleteproximityPrecision",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ProximityPrecisionView"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"books\").ResetProximityPrecisionAsync();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").ResetProximityPrecision()"
          },
          {
            "lang": "JS",
            "source": "client.index('books').resetProximityPrecision()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").resetProximityPrecisionSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->resetProximityPrecision();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').reset_proximity_precision()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').reset_proximity_precision"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"books\")\n  .reset_proximity_precision()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let task = try await self.client.index(\"books\").resetProximityPrecision()"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/books/settings/proximity-precision'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/ranking-rules": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get rankingRules",
        "description": "Get an user defined rankingRules",
        "operationId": "getrankingRules",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "rankingRules is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RankingRuleView"
                  }
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetRankingRulesAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').getRankingRules();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").GetRankingRules()"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').getRankingRules()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").getRankingRulesSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->getRankingRules();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').get_ranking_rules()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').ranking_rules"
          },
          {
            "lang": "Rust",
            "source": "let ranking_rules: Vec<String> = client\n  .index(\"movies\")\n  .get_ranking_rules()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").getRankingRules { (result) in\n    switch result {\n    case .success(let rankingRules):\n        print(rankingRules)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/settings/ranking-rules'"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update rankingRules",
        "description": "Update an index's user defined rankingRules",
        "operationId": "putrankingRules",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/RankingRuleView"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").UpdateRankingRulesAsync(new[]\n{\n    \"words\",\n    \"typo\",\n    \"proximity\",\n    \"attribute\",\n    \"sort\",\n    \"exactness\",\n    \"release_date:asc\",\n    \"rank:desc\"\n});"
          },
          {
            "lang": "Go",
            "source": "rankingRules := []string{\n  \"words\",\n  \"typo\",\n  \"proximity\",\n  \"attribute\",\n  \"sort\",\n  \"exactness\",\n  \"release_date:asc\",\n  \"rank:desc\",\n}\nclient.Index(\"movies\").UpdateRankingRules(&rankingRules)"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateRankingRules([\n    'words',\n    'typo',\n    'proximity',\n    'attribute',\n    'sort',\n    'exactness',\n    'release_date:asc',\n    'rank:desc'\n])"
          },
          {
            "lang": "Java",
            "source": "Settings settings = new Settings();\nsettings.setRankingRules(new String[]\n{\n  \"words\",\n  \"typo\",\n  \"proximity\",\n  \"attribute\",\n  \"sort\",\n  \"exactness\",\n  \"release_date:asc\",\n  \"rank:desc\"\n});\nclient.index(\"movies\").updateSettings(settings);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateRankingRules([\n  'words',\n  'typo',\n  'proximity',\n  'attribute',\n  'sort',\n  'exactness',\n  'release_date:asc',\n  'rank:desc'\n]);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_ranking_rules([\n    'words',\n    'typo',\n    'proximity',\n    'attribute',\n    'sort',\n    'exactness',\n    'release_date:asc',\n    'rank:desc'\n])"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_ranking_rules([\n  'words',\n  'typo',\n  'proximity',\n  'attribute',\n  'sort',\n  'exactness',\n  'release_date:asc',\n  'rank:desc'\n])"
          },
          {
            "lang": "Rust",
            "source": "let ranking_rules = [\n  \"words\",\n  \"typo\",\n  \"proximity\",\n  \"attribute\",\n  \"sort\",\n  \"exactness\",\n  \"release_date:asc\",\n  \"rank:desc\",\n];\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_ranking_rules(&ranking_rules)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let rankingRules: [String] = [\n    \"words\",\n    \"typo\",\n    \"proximity\",\n    \"attribute\",\n    \"sort\",\n    \"exactness\",\n    \"release_date:asc\",\n    \"rank:desc\"\n]\nclient.index(\"movies\").updateRankingRules(rankingRules) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/ranking-rules' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"words\",\n    \"typo\",\n    \"proximity\",\n    \"attribute\",\n    \"sort\",\n    \"exactness\",\n    \"release_date:asc\",\n    \"rank:desc\"\n  ]'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset rankingRules",
        "description": "Reset an index's rankingRules to its default value",
        "operationId": "deleterankingRules",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/RankingRuleView"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").ResetRankingRulesAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').resetRankingRules();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").ResetRankingRules()"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').resetRankingRules()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").resetRankingRulesSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->resetRankingRules();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').reset_ranking_rules()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').reset_ranking_rules"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .reset_ranking_rules()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").resetRankingRules { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/settings/ranking-rules'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/search-cutoff-ms": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get searchCutoffMs",
        "description": "Get an user defined searchCutoffMs",
        "operationId": "getsearchCutoffMs",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "searchCutoffMs is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "integer",
                  "format": "u-int64",
                  "minimum": 0
                },
                "example": 0
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "var searchCutoff = await client.Index(\"movies\").GetSearchCutoffMsAsync();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").GetSearchCutoffMs()"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').getSearchCutoffMs()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").getSearchCutoffMsSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->getSearchCutoffMs();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').get_search_cutoff_ms()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').search_cutoff_ms"
          },
          {
            "lang": "Rust",
            "source": "let search_cutoff_ms: String = client\n  .index(\"movies\")\n  .get_search_cutoff_ms()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let precisionValue = try await self.client.index(\"books\").getSearchCutoffMs()"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/settings/search-cutoff-ms'"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update searchCutoffMs",
        "description": "Update an index's user defined searchCutoffMs",
        "operationId": "putsearchCutoffMs",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "text/plain": {
              "schema": {
                "type": "integer",
                "format": "u-int64",
                "minimum": 0
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").UpdateSearchCutoffMsAsync(150);"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").UpdateSearchCutoffMs(150)"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateSearchCutoffMs(150)"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").updateSearchCutoffMsSettings(150);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateSearchCutoffMs(150);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_search_cutoff_ms(150)"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_search_cutoff_ms(150)"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .set_search_cutoff_ms(Some(150))\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let task = try await self.client.index(\"books\").updateSearchCutoffMs(150)"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/search-cutoff-ms' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '150'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset searchCutoffMs",
        "description": "Reset an index's searchCutoffMs to its default value",
        "operationId": "deletesearchCutoffMs",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "text/plain": {
              "schema": {
                "type": "integer",
                "format": "u-int64",
                "minimum": 0
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").ResetSearchCutoffMsAsync();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").ResetSearchCutoffMs()"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').resetSearchCutoffMs()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").resetSearchCutoffMsSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->resetSearchCutoffMs();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').reset_search_cutoff_ms()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').reset_search_cutoff_ms"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .reset_search_cutoff_ms()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let task = try await self.client.index(\"books\").resetSearchCutoffMs()"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/settings/search-cutoff-ms'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/searchable-attributes": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get searchableAttributes",
        "description": "Get an user defined searchableAttributes",
        "operationId": "getsearchableAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "searchableAttributes is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetSearchableAttributesAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').getSearchableAttributes();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").GetSearchableAttributes()"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').getSearchableAttributes()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").getSearchableAttributesSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->getSearchableAttributes();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').get_searchable_attributes()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').searchable_attributes"
          },
          {
            "lang": "Rust",
            "source": "let searchable_attributes: Vec<String> = client\n  .index(\"movies\")\n  .get_searchable_attributes()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").getSearchableAttributes { (result) in\n    switch result {\n    case .success(let searchableAttributes):\n        print(searchableAttributes)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/settings/searchable-attributes'"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update searchableAttributes",
        "description": "Update an index's user defined searchableAttributes",
        "operationId": "putsearchableAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").UpdateSearchableAttributesAsync(new[] {\"title\", \"overview\", \"genres\"});"
          },
          {
            "lang": "Go",
            "source": "searchableAttributes := []string{\n  \"title\",\n  \"overview\",\n  \"genres\",\n}\nclient.Index(\"movies\").UpdateSearchableAttributes(&searchableAttributes)"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateSearchableAttributes([\n  'title',\n  'overview',\n  'genres'\n])"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").updateSearchableAttributesSettings(new String[]\n{\n  \"title\",\n  \"overview\",\n  \"genres\"\n});"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateSearchableAttributes([\n  'title',\n  'overview',\n  'genres'\n]);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_searchable_attributes([\n    'title',\n    'overview',\n    'genres'\n])"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_searchable_attributes([\n  'title',\n  'overview',\n  'genres'\n])"
          },
          {
            "lang": "Rust",
            "source": "let searchable_attributes = [\n  \"title\",\n  \"overview\",\n  \"genres\"\n];\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_searchable_attributes(&searchable_attributes)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let searchableAttributes: [String] = [\"title\", \"overview\", \"genres\"]\nclient.index(\"movies\").updateSearchableAttributes(searchableAttributes) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/searchable-attributes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"title\",\n    \"overview\",\n    \"genres\"\n  ]'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset searchableAttributes",
        "description": "Reset an index's searchableAttributes to its default value",
        "operationId": "deletesearchableAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").ResetSearchableAttributesAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').resetSearchableAttributes();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").ResetSearchableAttributes()"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').resetSearchableAttributes()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").resetSearchableAttributesSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->resetSearchableAttributes();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').reset_searchable_attributes()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').reset_searchable_attributes"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .reset_searchable_attributes()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").resetSearchableAttributes { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/settings/searchable-attributes'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/separator-tokens": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get separatorTokens",
        "description": "Get an user defined separatorTokens",
        "operationId": "getseparatorTokens",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "separatorTokens is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "uniqueItems": true
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetSeparatorTokensAsync();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"articles\").GetSeparatorTokens()"
          },
          {
            "lang": "JS",
            "source": "client.index('books').getSeparatorTokens()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"articles\").getSeparatorTokensSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('articles')->getSeparatorTokens();"
          },
          {
            "lang": "Python",
            "source": "client.index('articles').get_separator_tokens()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('articles').separator_tokens"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index('articles')\n  .get_separator_tokens()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"books\").getSeparatorTokens { result in\n  // handle result\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/articles/settings/separator-tokens'"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update separatorTokens",
        "description": "Update an index's user defined separatorTokens",
        "operationId": "putseparatorTokens",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").UpdateSeparatorTokensAsync(new[] { \"|\", \"&hellip;\" });"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"articles\").UpdateSeparatorTokens([]string{\n  \"|\",\n  \"&hellip;\",\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('books').updateSeparatorTokens(['|', '&hellip;'])"
          },
          {
            "lang": "Java",
            "source": "String[] newSeparatorTokens = { \"|\", \"&hellip;\" };\nclient.index(\"articles\").updateSeparatorTokensSettings(newSeparatorTokens);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('articles')->updateSeparatorTokens(['|', '&hellip;']);"
          },
          {
            "lang": "Python",
            "source": "client.index('articles').update_separator_tokens([\"|\", \"&hellip;\"])"
          },
          {
            "lang": "Ruby",
            "source": "client.index('articles').update_separator_tokens(['|', '&hellip;'])"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index('articles')\n  .set_separator_tokens(&vec!['|'.to_string(), '&hellip;'.to_string()])\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"books\").updateSeparatorTokens([\"|\", \"&hellip;\"]) { result in\n  // handle result\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/articles/settings/separator-tokens' \\\n  -H 'Content-Type: application/json'  \\\n  --data-binary '[\"|\", \"&hellip;\"]'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset separatorTokens",
        "description": "Reset an index's separatorTokens to its default value",
        "operationId": "deleteseparatorTokens",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").ResetSeparatorTokensAsync();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"articles\").ResetSeparatorTokens()"
          },
          {
            "lang": "JS",
            "source": "client.index('books').resetSeparatorTokens()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"articles\").resetSeparatorTokensSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('articles')->resetSeparatorTokens();"
          },
          {
            "lang": "Python",
            "source": "client.index('articles').reset_separator_tokens()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('articles').reset_separator_tokens"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index('articles')\n  .reset_separator_tokens()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"books\").resetSeparatorTokens { result in\n  // handle result\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/articles/settings/separator-tokens'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/sortable-attributes": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get sortableAttributes",
        "description": "Get an user defined sortableAttributes",
        "operationId": "getsortableAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "sortableAttributes is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "uniqueItems": true
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"books\").GetSortableAttributesAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('books').getSortableAttributes();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").GetSortableAttributes()"
          },
          {
            "lang": "JS",
            "source": "client.index('books').getSortableAttributes()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").getSortableAttributesSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->getSortableAttributes();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').get_sortable_attributes()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').sortable_attributes"
          },
          {
            "lang": "Rust",
            "source": "let sortable_attributes: Vec<String> = client\n  .index(\"books\")\n  .get_sortable_attributes()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"books\").getSortableAttributes { (result: Result<Searchable<Book>, Swift.Error>) in\n  switch result {\n  case .success(let attributes):\n    print(attributes)\n  case .failure(let error):\n    print(error)\n  }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/books/settings/sortable-attributes'"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update sortableAttributes",
        "description": "Update an index's user defined sortableAttributes",
        "operationId": "putsortableAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"books\").UpdateSortableAttributesAsync(new [] { \"price\", \"author\" });"
          },
          {
            "lang": "Go",
            "source": "sortableAttributes := []string{\n  \"price\",\n  \"author\",\n}\nclient.Index(\"books\").UpdateSortableAttributes(&sortableAttributes)"
          },
          {
            "lang": "JS",
            "source": "client.index('books')\n  .updateSortableAttributes([\n    'price',\n    'author'\n  ])"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").updateSortableAttributesSettings(new String[] {\"price\", \"author\"});"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->updateSortableAttributes([\n  'price',\n  'author'\n]);"
          },
          {
            "lang": "Python",
            "source": "client.index('books').update_sortable_attributes([\n  'price',\n  'author'\n])"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').update_sortable_attributes([\n  'price',\n  'author'\n])"
          },
          {
            "lang": "Rust",
            "source": "let sortable_attributes = [\n  \"price\",\n  \"author\"\n];\n\nlet task: TaskInfo = client\n  .index(\"books\")\n  .set_sortable_attributes(&sortable_attributes)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"books\").updateSortableAttributes([\"price\", \"author\"]) { (result) in\n  switch result {\n  case .success(let task):\n    print(task)\n  case .failure(let error):\n    print(error)\n  }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/books/settings/sortable-attributes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"price\",\n    \"author\"\n  ]'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset sortableAttributes",
        "description": "Reset an index's sortableAttributes to its default value",
        "operationId": "deletesortableAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"books\").ResetSortableAttributesAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('books').resetSortableAttributes();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").ResetSortableAttributes()"
          },
          {
            "lang": "JS",
            "source": "client.index('books').resetSortableAttributes()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").resetSortableAttributesSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->resetSortableAttributes();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').reset_sortable_attributes()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').reset_sortable_attributes"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"books\")\n  .reset_sortable_attributes()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"books\").resetSortableAttributes() { (result) in\n  switch result {\n  case .success(let attributes):\n    print(attributes)\n  case .failure(let error):\n    print(error)\n  }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/books/settings/sortable-attributes'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/stop-words": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get stopWords",
        "description": "Get an user defined stopWords",
        "operationId": "getstopWords",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "stopWords is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "uniqueItems": true
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetStopWordsAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').getStopWords();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").GetStopWords()"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').getStopWords()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").getStopWordsSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->getStopWords();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').get_stop_words()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').stop_words"
          },
          {
            "lang": "Rust",
            "source": "let stop_words: Vec<String> = client\n  .index(\"movies\")\n  .get_stop_words()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").getStopWords { (result) in\n    switch result {\n    case .success(let stopWords):\n        print(stopWords)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/settings/stop-words'"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update stopWords",
        "description": "Update an index's user defined stopWords",
        "operationId": "putstopWords",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").UpdateStopWordsAsync(new[] {\"of\", \"the\", \"to\"});"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').updateStopWords(['of', 'the', 'to']);"
          },
          {
            "lang": "Go",
            "source": "stopWords := []string{\"of\", \"the\", \"to\"}\nclient.Index(\"movies\").UpdateStopWords(&stopWords)"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateStopWords(['of', 'the', 'to'])"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").updateStopWordsSettings(new String[] {\"of\", \"the\", \"to\"});"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateStopWords(['the', 'of', 'to']);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_stop_words(['of', 'the', 'to'])"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_stop_words(['of', 'the', 'to'])"
          },
          {
            "lang": "Rust",
            "source": "let stop_words = [\"of\", \"the\", \"to\"];\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_stop_words(&stop_words)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let stopWords: [String] = [\"of\", \"the\", \"to\"]\nclient.index(\"movies\").updateStopWords(stopWords) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/stop-words' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"the\",\n    \"of\",\n    \"to\"\n  ]'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset stopWords",
        "description": "Reset an index's stopWords to its default value",
        "operationId": "deletestopWords",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").ResetStopWordsAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').resetStopWords();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").ResetStopWords()"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').resetStopWords()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").resetStopWordsSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->resetStopWords();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').reset_stop_words()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').reset_stop_words"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .reset_stop_words()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").resetStopWords { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/settings/stop-words'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/synonyms": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get synonyms",
        "description": "Get an user defined synonyms",
        "operationId": "getsynonyms",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "synonyms is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "propertyNames": {
                    "type": "string"
                  }
                },
                "example": {}
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetSynonymsAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').getSynonyms();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").GetSynonyms()"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').getSynonyms()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").getSynonymsSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->getSynonyms();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').get_synonyms()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').synonyms"
          },
          {
            "lang": "Rust",
            "source": "let synonyms: HashMap<String, Vec<String>> = client\n  .index(\"movies\")\n  .get_synonyms()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").getSynonyms { (result) in\n    switch result {\n    case .success(let synonyms):\n        print(synonyms)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/settings/synonyms'"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update synonyms",
        "description": "Update an index's user defined synonyms",
        "operationId": "putsynonyms",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "additionalProperties": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "propertyNames": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "var synonyms = new Dictionary<string, IEnumerable<string>>\n{\n    { \"wolverine\", new string[] { \"xmen\", \"logan\" } },\n    { \"logan\", new string[] { \"wolverine\", \"xmen\" } },\n    { \"wow\", new string[] { \"world of warcraft\" } }\n};\nawait client.Index(\"movies\").UpdateSynonymsAsync(synonyms);"
          },
          {
            "lang": "Go",
            "source": "synonyms := map[string][]string{\n  \"wolverine\": []string{\"xmen\", \"logan\"},\n  \"logan\":     []string{\"wolverine\", \"xmen\"},\n  \"wow\":       []string{\"world of warcraft\"},\n}\nclient.Index(\"movies\").UpdateSynonyms(&synonyms)"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateSynonyms({\n  wolverine: ['xmen', 'logan'],\n  logan: ['wolverine', 'xmen'],\n  wow: ['world of warcraft']\n})"
          },
          {
            "lang": "Java",
            "source": "HashMap<String, String[]> synonyms = new HashMap<String, String[]>();\nsynonyms.put(\"wolverine\", new String[] {\"xmen\", \"logan\"});\nsynonyms.put(\"logan\", new String[] {\"wolverine\"});\nclient.index(\"movies\").updateSynonymsSettings(synonyms);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateSynonyms([\n  'wolverine' => ['xmen', 'logan'],\n  'logan' => ['wolverine', 'xmen'],\n  'wow' => ['world of warcraft']\n]);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_synonyms({\n  'wolverine': ['xmen', 'logan'],\n  'logan': ['wolverine', 'xmen'],\n  'wow': ['world of warcraft']\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_synonyms({\n  wolverine: ['xmen', 'logan'],\n  logan: ['wolverine', 'xmen'],\n  wow: ['world of warcraft']\n})"
          },
          {
            "lang": "Rust",
            "source": "let mut synonyms = std::collections::HashMap::new();\nsynonyms.insert(String::from(\"wolverine\"), vec![String::from(\"xmen\"), String::from(\"logan\")]);\nsynonyms.insert(String::from(\"logan\"), vec![String::from(\"xmen\"), String::from(\"wolverine\")]);\nsynonyms.insert(String::from(\"wow\"), vec![String::from(\"world of warcraft\")]);\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_synonyms(&synonyms)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let synonyms: [String: [String]] = [\n    \"wolverine\": [\"xmen\", \"logan\"],\n    \"logan\": [\"wolverine\", \"xmen\"],\n    \"wow\": [\"world of warcraft\"]\n]\nclient.index(\"movies\").updateSynonyms(synonyms) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/synonyms' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"wolverine\": [\n      \"xmen\",\n      \"logan\"\n    ],\n    \"logan\": [\n      \"wolverine\",\n      \"xmen\"\n    ],\n    \"wow\": [\"world of warcraft\"]\n  }'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset synonyms",
        "description": "Reset an index's synonyms to its default value",
        "operationId": "deletesynonyms",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "additionalProperties": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "propertyNames": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").ResetSynonymsAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').resetSynonyms();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").ResetSynonyms()"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').resetSynonyms()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").resetSynonymsSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->resetSynonyms();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').reset_synonyms()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').reset_synonyms"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .reset_synonyms()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").resetSynonyms { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/settings/synonyms'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/typo-tolerance": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get typoTolerance",
        "description": "Get an user defined typoTolerance",
        "operationId": "gettypoTolerance",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "typoTolerance is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TypoSettings"
                },
                "example": {}
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "Dart",
            "source": "await client.index('books').getTypoTolerance();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").GetTypoTolerance()"
          },
          {
            "lang": "JS",
            "source": "client.index('books').getTypoTolerance()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->getTypoTolerance();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').get_typo_tolerance()"
          },
          {
            "lang": "Ruby",
            "source": "index('books').typo_tolerance"
          },
          {
            "lang": "Rust",
            "source": "let typo_tolerance: TypoToleranceSettings = client\n  .index(\"books\")\n  .get_typo_tolerance()\n  .await\n  .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/books/settings/typo-tolerance'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset typoTolerance",
        "description": "Reset an index's typoTolerance to its default value",
        "operationId": "deletetypoTolerance",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TypoSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"books\").ResetTypoToleranceAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('books').resetTypoTolerance();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").ResetTypoTolerance()"
          },
          {
            "lang": "JS",
            "source": "client.index('books').resetTypoTolerance()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").resetTypoToleranceSettings();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->resetTypoTolerance();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').reset_typo_tolerance()"
          },
          {
            "lang": "Ruby",
            "source": "index('books').reset_typo_tolerance"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"books\")\n  .reset_typo_tolerance()\n  .await\n  .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/books/settings/typo-tolerance'"
          }
        ]
      },
      "patch": {
        "tags": [
          "Settings"
        ],
        "summary": "Update typoTolerance",
        "description": "Update an index's user defined typoTolerance",
        "operationId": "patchtypoTolerance",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TypoSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "var typoTolerance = new TypoTolerance {\n  DisableOnAttributes = new string[] { \"title\" },\n  MinWordSizeTypos = new TypoTolerance.TypoSize {\n      OneTypo = 4,\n      TwoTypos = 10\n  }\n};\n\nawait client.Index(\"books\").UpdateTypoToleranceAsync(typoTolerance);"
          },
          {
            "lang": "Dart",
            "source": "final toUpdate = TypoTolerance(\n  minWordSizeForTypos: MinWordSizeForTypos(\n    oneTypo: 4,\n    twoTypos: 10,\n  ),\n  disableOnAttributes: ['title'],\n);\nawait client.index('books').updateTypoTolerance(toUpdate);"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").UpdateTypoTolerance(&meilisearch.TypoTolerance{\n  MinWordSizeForTypos: meilisearch.MinWordSizeForTypos{\n      OneTypo: 4,\n      TwoTypos: 10,\n    },\n    DisableOnAttributes: []string{\"title\"},\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('books').updateTypoTolerance({\n  minWordSizeForTypos: {\n      oneTypo: 4,\n      twoTypos: 10\n    },\n    disableOnAttributes: [\n      'title'\n  ]\n})"
          },
          {
            "lang": "Java",
            "source": "TypoTolerance typoTolerance = new TypoTolerance();\nHashMap<String, Integer> minWordSizeTypos =\n        new HashMap<String, Integer>() {\n            {\n                put(\"oneTypo\", 4);\n                put(\"twoTypos\", 10);\n            }\n        };\n\ntypoTolerance.setMinWordSizeForTypos(minWordSizeTypos);\ntypoTolerance.setDisableOnAttributes(new String[] {\"title\"});\n\nclient.index(\"books\").updateTypoToleranceSettings(typoTolerance);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->updateTypoTolerance([\n  'minWordSizeForTypos' => [\n      'oneTypo' => 4,\n      'twoTypos' => 10\n    ],\n    'disableOnAttributes' => [\n      'title'\n  ]\n]);"
          },
          {
            "lang": "Python",
            "source": "client.index('books').update_typo_tolerance({\n  'minWordSizeForTypos': {\n      'oneTypo': 4,\n      'twoTypos': 10\n    },\n    'disableOnAttributes': [\n       'title'\n    ]\n})"
          },
          {
            "lang": "Ruby",
            "source": "index('books').update_typo_tolerance({\n  min_word_size_for_typos: {\n    one_typo: 4,\n    two_typos: 10\n  },\n  disable_on_attributes: ['title']\n})"
          },
          {
            "lang": "Rust",
            "source": "let typo_tolerance = TypoToleranceSettings {\n  enabled: Some(false),\n  disable_on_attributes: None,\n  disable_on_words: None,\n  min_word_size_for_typos: None,\n};\n\nlet task: TaskInfo = client\n  .index(\"books\")\n  .set_typo_tolerance(&typo_tolerance)\n  .await\n  .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/books/settings/typo-tolerance' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"minWordSizeForTypos\": {\n      \"oneTypo\": 4,\n      \"twoTypos\": 10\n    },\n    \"disableOnAttributes\": [\"title\"]\n  }'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/vector-store": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get vectorStore",
        "description": "Get an user defined vectorStore",
        "operationId": "getvectorStore",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "vectorStore is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VectorStoreBackend"
                },
                "example": "stable"
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/INDEX_UID/settings/vector-store'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset vectorStore",
        "description": "Reset an index's vectorStore to its default value",
        "operationId": "deletevectorStore",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VectorStoreBackend"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/INDEX_UID/settings/vector-store'"
          }
        ]
      },
      "patch": {
        "tags": [
          "Settings"
        ],
        "summary": "Update vectorStore",
        "description": "Update an index's user defined vectorStore",
        "operationId": "patchvectorStore",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VectorStoreBackend"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/INDEX_UID/settings/vector-store' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '\"experimental\"'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/similar": {
      "get": {
        "tags": [
          "Similar documents"
        ],
        "summary": "Get similar documents with GET",
        "description": "Retrieve documents similar to a specific search result.",
        "operationId": "similar_get",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          },
          {
            "name": "id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "default": 0,
              "minimum": 0
            }
          },
          {
            "name": "limit",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "default": 20,
              "minimum": 0
            }
          },
          {
            "name": "attributes_to_retrieve",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "retrieve_vectors",
            "in": "query",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "show_ranking_score",
            "in": "query",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "show_ranking_score_details",
            "in": "query",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "ranking_score_threshold",
            "in": "query",
            "required": false,
            "schema": {
              "type": "number",
              "format": "float"
            }
          },
          {
            "name": "embedder",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The documents are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimilarResult"
                },
                "example": {
                  "hits": [
                    {
                      "id": 2770,
                      "title": "American Pie 2",
                      "poster": "https://image.tmdb.org/t/p/w1280/q4LNgUnRfltxzp3gf1MAGiK5LhV.jpg",
                      "overview": "The whole gang are back and as close as ever. They decide to get even closer by spending the summer together at a beach house. They decide to hold the biggest",
                      "release_date": 997405200
                    },
                    {
                      "id": 190859,
                      "title": "American Sniper",
                      "poster": "https://image.tmdb.org/t/p/w1280/svPHnYE7N5NAGO49dBmRhq0vDQ3.jpg",
                      "overview": "U.S. Navy SEAL Chris Kyle takes his sole missionprotect his comradesto heart and becomes one of the most lethal snipers in American history. His pinpoint accuracy not only saves countless lives but also makes him a prime",
                      "release_date": 1418256000
                    }
                  ],
                  "offset": 0,
                  "limit": 2,
                  "estimatedTotalHits": 976,
                  "processingTimeMs": 35,
                  "query": "american "
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "Index not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Index `movies` not found.",
                  "code": "index_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#index_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "search",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/INDEX_NAME/similar?id=TARGET_DOCUMENT_ID&embedder=EMBEDDER_NAME'"
          }
        ]
      },
      "post": {
        "tags": [
          "Similar documents"
        ],
        "summary": "Get similar documents with POST",
        "description": "Retrieve documents similar to a specific search result.",
        "operationId": "similar_post",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SimilarQuery"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The documents are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimilarResult"
                },
                "example": {
                  "hits": [
                    {
                      "id": 2770,
                      "title": "American Pie 2",
                      "poster": "https://image.tmdb.org/t/p/w1280/q4LNgUnRfltxzp3gf1MAGiK5LhV.jpg",
                      "overview": "The whole gang are back and as close as ever. They decide to get even closer by spending the summer together at a beach house. They decide to hold the biggest",
                      "release_date": 997405200
                    },
                    {
                      "id": 190859,
                      "title": "American Sniper",
                      "poster": "https://image.tmdb.org/t/p/w1280/svPHnYE7N5NAGO49dBmRhq0vDQ3.jpg",
                      "overview": "U.S. Navy SEAL Chris Kyle takes his sole missionprotect his comradesto heart and becomes one of the most lethal snipers in American history. His pinpoint accuracy not only saves countless lives but also makes him a prime",
                      "release_date": 1418256000
                    }
                  ],
                  "offset": 0,
                  "limit": 2,
                  "estimatedTotalHits": 976,
                  "processingTimeMs": 35,
                  "query": "american "
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "Index not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Index `movies` not found.",
                  "code": "index_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#index_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "search",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "Go",
            "source": "resp := new(meilisearch.SimilarDocumentResult)\nclient.Index(\"INDEX_NAME\").SearchSimilarDocuments(&meilisearch.SimilarDocumentQuery{\n  Id: \"TARGET_DOCUMENT_ID\",\n  Embedder: \"default\",\n}, resp)"
          },
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').searchSimilarDocuments({ id: 'TARGET_DOCUMENT_ID', embedder: 'default' })"
          },
          {
            "lang": "PHP",
            "source": "$similarQuery = new SimilarDocumentsQuery('TARGET_DOCUMENT_ID', 'default');\n$client->index('INDEX_NAME')->searchSimilarDocuments($similarQuery);"
          },
          {
            "lang": "Python",
            "source": "client.index(\"INDEX_NAME\").get_similar_documents({\"id\": \"TARGET_DOCUMENT_ID\", \"embedder\": \"default\"})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_NAME').search_similar_documents('TARGET_DOCUMENT_ID', embedder: 'default')"
          },
          {
            "lang": "Rust",
            "source": "let results = index\n  .similar_search(\"TARGET_DOCUMENT_ID\", \"EMBEDDER_NAME\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/INDEX_NAME/similar' \\\n  -H 'Content-Type: application/json' \\\n  -H 'Authorization: Bearer DEFAULT_SEARCH_API_KEY' \\\n  --data-binary '{\n    \"id\": TARGET_DOCUMENT_ID,\n    \"embedder\": \"EMBEDDER_NAME\"\n  }'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/stats": {
      "get": {
        "tags": [
          "Stats"
        ],
        "summary": "Get stats of index",
        "description": "Get the stats of an index.",
        "operationId": "get_index_stats",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "The stats of the index",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IndexStats"
                },
                "example": {
                  "numberOfDocuments": 10,
                  "rawDocumentDbSize": 10,
                  "avgDocumentSize": 10,
                  "numberOfEmbeddings": 10,
                  "numberOfEmbeddedDocuments": 10,
                  "isIndexing": true,
                  "fieldDistribution": {
                    "genre": 10,
                    "author": 9
                  }
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "Index not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Index `movies` not found.",
                  "code": "index_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#index_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "stats.get",
              "stats.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetStatsAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').getStats();"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").GetStats()"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').getStats()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").getStats();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->stats();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').get_stats()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').stats"
          },
          {
            "lang": "Rust",
            "source": "let stats: IndexStats = client\n  .index(\"movies\")\n  .get_stats()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").stats { (result) in\n    switch result {\n    case .success(let stats):\n        print(stats)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/stats'"
          }
        ]
      }
    },
    "/indexes{indexUid}/compact": {
      "post": {
        "tags": [
          "Compact an index"
        ],
        "summary": "Compact an index",
        "operationId": "compact",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "202": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "documentDeletion",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "search",
              "*"
            ]
          }
        ]
      }
    },
    "/keys": {
      "get": {
        "tags": [
          "Keys"
        ],
        "summary": "Get API Keys",
        "description": "List all API Keys",
        "operationId": "list_api_keys",
        "parameters": [
          {
            "name": "offset",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "default": 0,
              "minimum": 0
            }
          },
          {
            "name": "limit",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "default": 20,
              "minimum": 0
            }
          }
        ],
        "responses": {
          "202": {
            "description": "List of keys",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginationView_KeyView"
                },
                "example": {
                  "results": [
                    {
                      "uid": "01b4bc42-eb33-4041-b481-254d00cce834",
                      "key": "d0552b41536279a0ad88bd595327b96f01176a60c2243e906c52ac02375f9bc4",
                      "name": "An API Key",
                      "description": null,
                      "actions": [
                        "documents.add"
                      ],
                      "indexes": [
                        "movies"
                      ],
                      "expiresAt": "2022-11-12T10:00:00Z",
                      "createdAt": "2021-11-12T10:00:00Z",
                      "updatedAt": "2021-11-12T10:00:00Z"
                    }
                  ],
                  "limit": 20,
                  "offset": 0,
                  "total": 1
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "keys.get",
              "keys.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "ResourceResults<Key> keyResult = await client.GetKeysAsync(new KeysQuery { Limit = 3 });"
          },
          {
            "lang": "Dart",
            "source": "await client.getKeys(params: KeysQuery(limit: 3));"
          },
          {
            "lang": "Go",
            "source": "client.GetKeys(&meilisearch.KeysQuery{\n  Limit: 3\n});"
          },
          {
            "lang": "JS",
            "source": "client.getKeys({ limit: 3 })"
          },
          {
            "lang": "Java",
            "source": "KeysQuery query = new KeysQuery().setLimit(3);\nclient.getKeys(query);"
          },
          {
            "lang": "PHP",
            "source": "$client->getKeys((new KeysQuery())->setLimit(3));"
          },
          {
            "lang": "Python",
            "source": "client.get_keys({'limit': 3})"
          },
          {
            "lang": "Ruby",
            "source": "client.keys(limit: 3)"
          },
          {
            "lang": "Rust",
            "source": "let mut query = KeysQuery::new()\n  .with_limit(3)\n  .execute(&client)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.getKeys(params: KeysQuery(limit: 3)) { result in\n    switch result {\n    case .success(let keys):\n        print(keys)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/keys?limit=3' \\\n  -H 'Authorization: Bearer MASTER_KEY'"
          }
        ]
      },
      "post": {
        "tags": [
          "Keys"
        ],
        "summary": "Create an API Key",
        "description": "Create an API Key.",
        "operationId": "create_api_key",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateApiKey"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Key has been created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/KeyView"
                },
                "example": {
                  "uid": "01b4bc42-eb33-4041-b481-254d00cce834",
                  "key": "d0552b41536279a0ad88bd595327b96f01176a60c2243e906c52ac02375f9bc4",
                  "name": "Indexing Products API key",
                  "description": null,
                  "actions": [
                    "documents.add"
                  ],
                  "indexes": [
                    "products"
                  ],
                  "expiresAt": "2021-11-13T00:00:00Z",
                  "createdAt": "2021-11-12T10:00:00Z",
                  "updatedAt": "2021-11-12T10:00:00Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "keys.create",
              "keys.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "Key keyOptions = new Key\n{\n    Description = \"Add documents: Products API key\",\n    Actions = new KeyAction[] { KeyAction.DocumentsAdd },\n    Indexes = new string[] { \"products\" },\n    ExpiresAt = DateTime.Parse(\"2042-04-02T00:42:42Z\")\n};\nKey createdKey = await this.client.CreateKeyAsync(keyOptions);"
          },
          {
            "lang": "Go",
            "source": "client.CreateKey(&meilisearch.Key{\n  Description: \"Add documents: Products API key\",\n  Actions: []string{\"documents.add\"},\n  Indexes: []string{\"products\"},\n  ExpiresAt: time.Date(2042, time.April, 02, 0, 42, 42, 0, time.UTC),\n})"
          },
          {
            "lang": "JS",
            "source": "client.createKey({\n  description: 'Add documents: Products API key',\n  actions: ['documents.add'],\n  indexes: ['products'],\n  expiresAt: '2021-11-13T00:00:00Z'\n})"
          },
          {
            "lang": "Java",
            "source": "SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\");\nDate dateParsed = format.parse(\"2042-04-02T00:42:42Z\");\n\nKey keyInfo = new Key();\n\nkeyInfo.setDescription(\"Add documents: Products API key\");\nkeyInfo.setActions(new String[] {\"documents.add\"});\nkeyInfo.setIndexes(new String[] {\"products\"});\nkeyInfo.setExpiresAt(dateParsed);\n\nclient.createKey(keyInfo);"
          },
          {
            "lang": "PHP",
            "source": "$client->createKey([\n  'description' => 'Add documents: Products API key',\n  'actions' => ['documents.add'],\n  'indexes' => ['products'],\n  'expiresAt' => '2042-04-02T00:42:42Z',\n]);"
          },
          {
            "lang": "Python",
            "source": "client.create_key(options={\n  'description': 'Add documents: Products API key',\n  'actions': ['documents.add'],\n  'indexes': ['products'],\n  'expiresAt': '2042-04-02T00:42:42Z'\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.create_key(\n  description: 'Add documents: Products API key',\n  actions: ['documents.add'],\n  indexes: ['products'],\n  expires_at: '2042-04-02T00:42:42Z'\n)"
          },
          {
            "lang": "Rust",
            "source": "let mut key_options = KeyBuilder::new();\nkey_options\n  .with_name(\"Add documents: Products API key\")\n  .with_action(Action::DocumentsAdd)\n  .with_expires_at(time::macros::datetime!(2042 - 04 - 02 00:42:42 UTC))\n  .with_index(\"products\");\nlet new_key = client\n  .create_key(key_options)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let keyParams = KeyParams(\n  description: \"Add documents: Products API key\",\n  actions: [\"documents.add\"],\n  indexes: [\"products\"],\n  expiresAt: \"2042-04-02T00:42:42Z\"\n)\nclient.createKey(keyParams) { result in\n    switch result {\n    case .success(let key):\n        print(key)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/keys' \\\n  -H 'Authorization: Bearer MASTER_KEY' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"description\": \"Add documents: Products API key\",\n    \"actions\": [\"documents.add\"],\n    \"indexes\": [\"products\"],\n    \"expiresAt\": \"2042-04-02T00:42:42Z\"\n  }'"
          }
        ]
      }
    },
    "/keys/{uidOrKey}": {
      "get": {
        "tags": [
          "Keys"
        ],
        "summary": "Get an API Key",
        "description": "Get an API key from its `uid` or its `key` field.",
        "operationId": "get_api_key",
        "parameters": [
          {
            "name": "uidOrKey",
            "in": "path",
            "description": "The `uid` or `key` field of an existing API key",
            "required": true,
            "schema": {
              "type": "string",
              "format": "password"
            },
            "example": "7b198a7f-52a0-4188-8762-9ad93cd608b2"
          }
        ],
        "responses": {
          "200": {
            "description": "The key is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/KeyView"
                },
                "example": {
                  "uid": "01b4bc42-eb33-4041-b481-254d00cce834",
                  "key": "d0552b41536279a0ad88bd595327b96f01176a60c2243e906c52ac02375f9bc4",
                  "name": "An API Key",
                  "description": null,
                  "actions": [
                    "documents.add"
                  ],
                  "indexes": [
                    "movies"
                  ],
                  "expiresAt": "2022-11-12T10:00:00Z",
                  "createdAt": "2021-11-12T10:00:00Z",
                  "updatedAt": "2021-11-12T10:00:00Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "keys.get",
              "keys.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "Key key = await client.GetKeyAsync(\"d0552b41536279a0ad88bd595327b96f01176a60c2243e906c52ac02375f9bc4\");"
          },
          {
            "lang": "Dart",
            "source": "await client.getKey('6062abda-a5aa-4414-ac91-ecd7944c0f8d');"
          },
          {
            "lang": "Go",
            "source": "client.GetKey(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\")"
          },
          {
            "lang": "JS",
            "source": "client.getKey('6062abda-a5aa-4414-ac91-ecd7944c0f8d')"
          },
          {
            "lang": "Java",
            "source": "client.getKey(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\");"
          },
          {
            "lang": "PHP",
            "source": "$client->getKey('6062abda-a5aa-4414-ac91-ecd7944c0f8d');"
          },
          {
            "lang": "Python",
            "source": "client.get_key('6062abda-a5aa-4414-ac91-ecd7944c0f8d')"
          },
          {
            "lang": "Ruby",
            "source": "client.key('6062abda-a5aa-4414-ac91-ecd7944c0f8d')"
          },
          {
            "lang": "Rust",
            "source": "let key = client\n  .get_key(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\")\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.getKey(keyOrUid: \"6062abda-a5aa-4414-ac91-ecd7944c0f8d\") { result in\n    switch result {\n    case .success(let key):\n        print(key)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/keys/6062abda-a5aa-4414-ac91-ecd7944c0f8d' \\\n  -H 'Authorization: Bearer MASTER_KEY'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Keys"
        ],
        "summary": "Delete a key",
        "description": "Delete the specified API key.",
        "operationId": "delete_api_key",
        "parameters": [
          {
            "name": "uidOrKey",
            "in": "path",
            "description": "The `uid` or `key` field of an existing API key",
            "required": true,
            "schema": {
              "type": "string",
              "format": "password"
            },
            "example": "7b198a7f-52a0-4188-8762-9ad93cd608b2"
          }
        ],
        "responses": {
          "204": {
            "description": "The key have been removed"
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "keys.delete",
              "keys.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "client.DeleteKeyAsync(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\")"
          },
          {
            "lang": "Dart",
            "source": "await client.deleteKey('6062abda-a5aa-4414-ac91-ecd7944c0f8d');"
          },
          {
            "lang": "Go",
            "source": "client.DeleteKey(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\")"
          },
          {
            "lang": "JS",
            "source": "client.deleteKey('6062abda-a5aa-4414-ac91-ecd7944c0f8d')"
          },
          {
            "lang": "Java",
            "source": "client.deleteKey(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\")"
          },
          {
            "lang": "PHP",
            "source": "$client->deleteKey('6062abda-a5aa-4414-ac91-ecd7944c0f8d');"
          },
          {
            "lang": "Python",
            "source": "client.delete_key('6062abda-a5aa-4414-ac91-ecd7944c0f8d')"
          },
          {
            "lang": "Ruby",
            "source": "client.delete_key('6062abda-a5aa-4414-ac91-ecd7944c0f8d')"
          },
          {
            "lang": "Rust",
            "source": "let key = client\n  .get_key(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\")\n  .await\n  .unwrap();\nclient\n  .delete_key(&key)\n  .await?;"
          },
          {
            "lang": "Swift",
            "source": "client.deleteKey(keyOrUid: \"6062abda-a5aa-4414-ac91-ecd7944c0f8d\") { result in\n    switch result {\n    case .success:\n        print(\"success\")\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/keys/6062abda-a5aa-4414-ac91-ecd7944c0f8d' \\\n  -H 'Authorization: Bearer MASTER_KEY'"
          }
        ]
      },
      "patch": {
        "tags": [
          "Keys"
        ],
        "summary": "Update a Key",
        "description": "Update the name and description of an API key.\nUpdates to keys are partial. This means you should provide only the fields you intend to update, as any fields not present in the payload will remain unchanged.",
        "operationId": "patch_api_key",
        "parameters": [
          {
            "name": "uidOrKey",
            "in": "path",
            "description": "The `uid` or `key` field of an existing API key",
            "required": true,
            "schema": {
              "type": "string",
              "format": "password"
            },
            "example": "7b198a7f-52a0-4188-8762-9ad93cd608b2"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PatchApiKey"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The key have been updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/KeyView"
                },
                "example": {
                  "uid": "01b4bc42-eb33-4041-b481-254d00cce834",
                  "key": "d0552b41536279a0ad88bd595327b96f01176a60c2243e906c52ac02375f9bc4",
                  "name": "An API Key",
                  "description": null,
                  "actions": [
                    "documents.add"
                  ],
                  "indexes": [
                    "movies"
                  ],
                  "expiresAt": "2022-11-12T10:00:00Z",
                  "createdAt": "2021-11-12T10:00:00Z",
                  "updatedAt": "2021-11-12T10:00:00Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "keys.update",
              "keys.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.UpdateKeyAsync(\n  \"6062abda-a5aa-4414-ac91-ecd7944c0f8d\",\n  description: \"Manage documents: Products/Reviews API key\",\n  name: \"Products/Reviews API key\"\n)"
          },
          {
            "lang": "Go",
            "source": "client.UpdateKey(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\", &meilisearch.Key{\n  Description: \"Manage documents: Products/Reviews API key\",\n  Actions: []string{\"documents.add\", \"document.delete\"},\n  Indexes: []string{\"products\", \"reviews\"},\n  ExpiresAt: time.Date(2042, time.April, 02, 0, 42, 42, 0, time.UTC),\n})"
          },
          {
            "lang": "JS",
            "source": "client.updateKey('6062abda-a5aa-4414-ac91-ecd7944c0f8d', {\n    name: 'Products/Reviews API key',\n    description: 'Manage documents: Products/Reviews API key',\n})"
          },
          {
            "lang": "Java",
            "source": "KeyUpdate keyChanges = new KeyUpdate();\nkeyChanges.setName(\"Products/Reviews API key\");\nkeyChanges.setDescription(\"Manage documents: Products/Reviews API key\");\n\nclient.updateKey(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\", keyChanges);"
          },
          {
            "lang": "PHP",
            "source": "$client->updateKey('6062abda-a5aa-4414-ac91-ecd7944c0f8d',\n  [\n    'name' => 'Products/Reviews API key',\n    'description' => 'Manage documents: Products/Reviews API key'\n  ]);"
          },
          {
            "lang": "Python",
            "source": "client.update_key(key_or_uid='6062abda-a5aa-4414-ac91-ecd7944c0f8d',\n  options={\n    'name': 'Products/Reviews API key',\n    'description': 'Manage documents: Products/Reviews API key'\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.update_key(\n  '6062abda-a5aa-4414-ac91-ecd7944c0f8d',\n  {\n    description: 'Manage documents: Products/Reviews API key',\n    name: 'Products/Reviews API key'\n  }\n)"
          },
          {
            "lang": "Rust",
            "source": "let mut key = client\n  .get_key(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\")\n  .await\n  .unwrap();\nkey\n    .with_description(\"Manage documents: Products/Reviews API key\".to_string())\n    .with_name(\"Products/Reviews API key\".to_string())\n    .update(&client)\n    .await\n    .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let keyParams = KeyUpdateParams(\n  description: \"Manage documents: Products/Reviews API key\",\n  name: \"Products/Reviews API key\"\n)\n\nclient.updateKey(keyOrUid: \"6062abda-a5aa-4414-ac91-ecd7944c0f8d\", keyParams: keyParams) { result in\n  switch result {\n  case .success(let key):\n      print(key)\n  case .failure(let error):\n      print(error)\n  }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/keys/6062abda-a5aa-4414-ac91-ecd7944c0f8d' \\\n  -H 'Authorization: Bearer MASTER_KEY' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"name\": \"Products/Reviews API key\",\n    \"description\": \"Manage documents: Products/Reviews API key\"\n  }'"
          }
        ]
      }
    },
    "/logs/stderr": {
      "post": {
        "tags": [
          "Logs"
        ],
        "summary": "Update target of the console logs",
        "description": "This route lets you specify at runtime the level of the console logs outputted on stderr.",
        "operationId": "update_stderr_target",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateStderrLogs"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "The console logs have been updated"
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "metrics.get",
              "metrics.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST MEILISEARCH_URL/logs/stderr \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n      \"target\": \"milli=trace,index_scheduler=info,actix_web=off\"\n  }'"
          }
        ]
      }
    },
    "/logs/stream": {
      "post": {
        "tags": [
          "Logs"
        ],
        "summary": "Retrieve logs",
        "description": "Stream logs over HTTP. The format of the logs depends on the configuration specified in the payload.\nThe logs are sent as multi-part, and the stream never stops, so make sure your clients correctly handle that.\nTo make the server stop sending you logs, you can call the `DELETE /logs/stream` route.\n\nThere can only be one listener at a timeand an error will be returned if you call this route while it's being used by another client.",
        "operationId": "get_logs",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetLogs"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Logs are being returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                },
                "example": "\n2024-10-08T13:35:02.643750Z  WARN HTTP request{method=GET host=\"localhost:7700\" route=/metrics query_parameters= user_agent=HTTPie/3.2.3 status_code=400 error=Getting metrics requires enabling the `metrics` experimental feature. See https://github.com/meilisearch/product/discussions/625}: tracing_actix_web::middleware: Error encountered while processing the incoming HTTP request: ResponseError { code: 400, message: \"Getting metrics requires enabling the `metrics` experimental feature. See https://github.com/meilisearch/product/discussions/625\", error_code: \"feature_not_enabled\", error_type: \"invalid_request\", error_link: \"https://docs.meilisearch.com/errors#feature_not_enabled\" }\n2024-10-08T13:35:02.644191Z  INFO HTTP request{method=GET host=\"localhost:7700\" route=/metrics query_parameters= user_agent=HTTPie/3.2.3 status_code=400 error=Getting metrics requires enabling the `metrics` experimental feature. See https://github.com/meilisearch/product/discussions/625}: meilisearch: close time.busy=1.66ms time.idle=658s\n2024-10-08T13:35:18.564152Z  INFO HTTP request{method=PATCH host=\"localhost:7700\" route=/experimental-features query_parameters= user_agent=curl/8.6.0 status_code=200}: meilisearch: close time.busy=1.17ms time.idle=127s\n2024-10-08T13:35:23.094987Z  INFO HTTP request{method=GET host=\"localhost:7700\" route=/metrics query_parameters= user_agent=HTTPie/3.2.3 status_code=200}: meilisearch: close time.busy=2.12ms time.idle=595s\n"
              }
            }
          },
          "400": {
            "description": "The route is already being used",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The `/logs/stream` route is currently in use by someone else.",
                  "code": "bad_request",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#bad_request"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "metrics.get",
              "metrics.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST MEILISEARCH_URL/logs/stream \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"mode\": \"human\",\n    \"target\": \"index_scheduler=trace\"\n  }'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Logs"
        ],
        "summary": "Stop retrieving logs",
        "description": "Call this route to make the engine stops sending logs through the `POST /logs/stream` route.",
        "operationId": "cancel_logs",
        "responses": {
          "204": {
            "description": "Logs are being returned"
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "metrics.get",
              "metrics.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE MEILISEARCH_URL/logs/stream\n}'"
          }
        ]
      }
    },
    "/metrics": {
      "get": {
        "tags": [
          "Stats"
        ],
        "summary": "Get prometheus metrics",
        "description": "Retrieve metrics on the engine. See https://www.meilisearch.com/docs/learn/experimental/metrics\nCurrently, [the feature is experimental](https://www.meilisearch.com/docs/learn/experimental/overview)\nwhich means it must be enabled.",
        "operationId": "get_metrics",
        "responses": {
          "200": {
            "description": "The metrics of the instance",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                },
                "example": "\n# HELP meilisearch_db_size_bytes Meilisearch DB Size In Bytes\n# TYPE meilisearch_db_size_bytes gauge\nmeilisearch_db_size_bytes 1130496\n# HELP meilisearch_batch_running_progress_trace The currently running progress trace\n# TYPE meilisearch_batch_running_progress_trace gauge\nmeilisearch_batch_running_progress_trace{batch_uid=\"0\",step_name=\"document\"} 0.710618582519409\nmeilisearch_batch_running_progress_trace{batch_uid=\"0\",step_name=\"extracting word proximity\"} 0.2222222222222222\nmeilisearch_batch_running_progress_trace{batch_uid=\"0\",step_name=\"indexing\"} 0.6666666666666666\nmeilisearch_batch_running_progress_trace{batch_uid=\"0\",step_name=\"processing tasks\"} 0\n# HELP meilisearch_http_requests_total Meilisearch HTTP requests total\n# TYPE meilisearch_http_requests_total counter\nmeilisearch_http_requests_total{method=\"GET\",path=\"/metrics\",status=\"400\"} 1\nmeilisearch_http_requests_total{method=\"PATCH\",path=\"/experimental-features\",status=\"200\"} 1\n# HELP meilisearch_http_response_time_seconds Meilisearch HTTP response times\n# TYPE meilisearch_http_response_time_seconds histogram\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"0.005\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"0.01\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"0.025\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"0.05\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"0.075\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"0.1\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"0.25\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"0.5\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"0.75\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"1\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"2.5\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"5\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"7.5\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"10\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"+Inf\"} 0\nmeilisearch_http_response_time_seconds_sum{method=\"GET\",path=\"/metrics\"} 0\nmeilisearch_http_response_time_seconds_count{method=\"GET\",path=\"/metrics\"} 0\n# HELP meilisearch_last_finished_batches_progress_trace_ms The last few batches progress trace in milliseconds\n# TYPE meilisearch_last_finished_batches_progress_trace_ms gauge\nmeilisearch_last_finished_batches_progress_trace_ms{batch_uid=\"0\",step_name=\"processing tasks\"} 19360\nmeilisearch_last_finished_batches_progress_trace_ms{batch_uid=\"0\",step_name=\"processing tasks > computing document changes\"} 368\nmeilisearch_last_finished_batches_progress_trace_ms{batch_uid=\"0\",step_name=\"processing tasks > computing document changes > preparing payloads\"} 367\nmeilisearch_last_finished_batches_progress_trace_ms{batch_uid=\"0\",step_name=\"processing tasks > computing document changes > preparing payloads > payload\"} 367\nmeilisearch_last_finished_batches_progress_trace_ms{batch_uid=\"0\",step_name=\"processing tasks > indexing\"} 18970\n# HELP meilisearch_index_count Meilisearch Index Count\n# TYPE meilisearch_index_count gauge\nmeilisearch_index_count 1\n# HELP meilisearch_index_docs_count Meilisearch Index Docs Count\n# TYPE meilisearch_index_docs_count gauge\nmeilisearch_index_docs_count{index=\"mieli\"} 2\n# HELP meilisearch_is_indexing Meilisearch Is Indexing\n# TYPE meilisearch_is_indexing gauge\nmeilisearch_is_indexing 0\n# HELP meilisearch_last_update Meilisearch Last Update\n# TYPE meilisearch_last_update gauge\nmeilisearch_last_update 1726675964\n# HELP meilisearch_nb_tasks Meilisearch Number of tasks\n# TYPE meilisearch_nb_tasks gauge\nmeilisearch_nb_tasks{kind=\"indexes\",value=\"mieli\"} 39\nmeilisearch_nb_tasks{kind=\"statuses\",value=\"canceled\"} 0\nmeilisearch_nb_tasks{kind=\"statuses\",value=\"enqueued\"} 0\nmeilisearch_nb_tasks{kind=\"statuses\",value=\"failed\"} 4\nmeilisearch_nb_tasks{kind=\"statuses\",value=\"processing\"} 0\nmeilisearch_nb_tasks{kind=\"statuses\",value=\"succeeded\"} 35\nmeilisearch_nb_tasks{kind=\"types\",value=\"documentAdditionOrUpdate\"} 9\nmeilisearch_nb_tasks{kind=\"types\",value=\"documentDeletion\"} 0\nmeilisearch_nb_tasks{kind=\"types\",value=\"documentEdition\"} 0\nmeilisearch_nb_tasks{kind=\"types\",value=\"dumpCreation\"} 0\nmeilisearch_nb_tasks{kind=\"types\",value=\"indexCreation\"} 0\nmeilisearch_nb_tasks{kind=\"types\",value=\"indexDeletion\"} 8\nmeilisearch_nb_tasks{kind=\"types\",value=\"indexSwap\"} 0\nmeilisearch_nb_tasks{kind=\"types\",value=\"indexUpdate\"} 0\nmeilisearch_nb_tasks{kind=\"types\",value=\"settingsUpdate\"} 22\nmeilisearch_nb_tasks{kind=\"types\",value=\"snapshotCreation\"} 0\nmeilisearch_nb_tasks{kind=\"types\",value=\"taskCancelation\"} 0\nmeilisearch_nb_tasks{kind=\"types\",value=\"taskDeletion\"} 0\n# HELP meilisearch_used_db_size_bytes Meilisearch Used DB Size In Bytes\n# TYPE meilisearch_used_db_size_bytes gauge\nmeilisearch_used_db_size_bytes 409600\n"
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "metrics.get",
              "metrics.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/metrics'"
          }
        ]
      }
    },
    "/multi-search": {
      "post": {
        "tags": [
          "Multi-search"
        ],
        "summary": "Perform a multi-search",
        "description": "Bundle multiple search queries in a single API request. Use this endpoint to search through multiple indexes at once.",
        "operationId": "multi_search_with_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FederatedSearch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Federated multi-search",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FederatedSearchResult"
                },
                "example": {
                  "hits": [
                    {
                      "id": 42,
                      "title": "Batman returns",
                      "overview": "The overview of batman returns",
                      "_federation": {
                        "indexUid": "movies",
                        "queriesPosition": 0
                      }
                    },
                    {
                      "comicsId": "batman-killing-joke",
                      "description": "This comic is really awesome",
                      "title": "Batman: the killing joke",
                      "_federation": {
                        "indexUid": "comics",
                        "queriesPosition": 1
                      }
                    }
                  ],
                  "processingTimeMs": 0,
                  "limit": 20,
                  "offset": 0,
                  "estimatedTotalHits": 2,
                  "semanticHitCount": 0
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "search",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.MultiSearchAsync(new MultiSearchQuery()\n{\n    Queries = new System.Collections.Generic.List<SearchQuery>()\n    {\n        new SearchQuery() {\n          IndexUid = \"movies\",\n          Q = \"booh\",\n          Limit = 5\n        },\n        new SearchQuery() {\n          IndexUid = \"movies\",\n          Q = \"nemo\",\n          Limit = 5\n        },\n        new SearchQuery() {\n          IndexUid = \"movie_ratings\",\n          Q = \"us\",\n        },\n    }\n});"
          },
          {
            "lang": "Go",
            "source": "client.MultiSearch(&MultiSearchRequest{\n  Queries: []SearchRequest{\n    {\n      IndexUID: \"movies\",\n      Query:    \"pooh\",\n      Limit:    5,\n    },\n    {\n      IndexUID: \"movies\",\n      Query:    \"nemo\",\n      Limit:    5,\n    },\n    {\n      IndexUID: \"movie_ratings\",\n      Query:    \"us\",\n    },\n  },\n})"
          },
          {
            "lang": "JS",
            "source": "client.multiSearch({ queries: [\n  {\n    indexUid: 'movies',\n    q: 'pooh',\n    limit: 5,\n  },\n  {\n    indexUid: 'movies',\n    q: 'nemo',\n    limit: 5,\n  },\n  {\n    indexUid: 'movie_ratings',\n    q: 'us',\n  },\n]})"
          },
          {
            "lang": "Java",
            "source": "MultiSearchRequest multiSearchRequest = new MultiSearchRequest();\nmultiIndexSearch.addQuery(new IndexSearchRequest(\"movies\").setQuery(\"pooh\").setLimit(5));\nmultiIndexSearch.addQuery(new IndexSearchRequest(\"movies\").setQuery(\"nemo\").setLimit(5));\nmultiIndexSearch.addQuery(new IndexSearchRequest(\"movie_ratings\").setQuery(\"us\"));\n\nclient.multiSearch(multiSearchRequest);"
          },
          {
            "lang": "PHP",
            "source": "$client->multiSearch([\n    (new SearchQuery())\n        ->setIndexUid('movies')\n        ->setQuery('pooh')\n        ->setLimit(5),\n    (new SearchQuery())\n        ->setIndexUid('movies')\n        ->setQuery('nemo')\n        ->setLimit(5),\n    (new SearchQuery())\n        ->setIndexUid('movie_ratings')\n        ->setQuery('us')\n  ]);"
          },
          {
            "lang": "Python",
            "source": "client.multi_search(\n  [\n    {'indexUid': 'movies', 'q': 'pooh', 'limit': 5},\n    {'indexUid': 'movies', 'q': 'nemo', 'limit': 5},\n    {'indexUid': 'movie_ratings', 'q': 'us'}\n  ]\n)"
          },
          {
            "lang": "Ruby",
            "source": "client.multi_search([\n  { index_uid: 'books', q: 'prince' },\n  { index_uid: 'movies', q: 'pooh', limit: 5 }\n  { index_uid: 'movies', q: 'nemo', limit: 5 }\n  { index_uid: 'movie_ratings', q: 'us' }\n])"
          },
          {
            "lang": "Rust",
            "source": "let movie = client.index(\"movie\");\nlet movie_ratings = client.index(\"movie_ratings\");\n\nlet search_query_1 = SearchQuery::new(&movie)\n    .with_query(\"pooh\")\n    .with_limit(5)\n    .build();\nlet search_query_2 = SearchQuery::new(&movie)\n    .with_query(\"nemo\")\n    .with_limit(5)\n    .build();\nlet search_query_3 = SearchQuery::new(&movie_ratings)\n    .with_query(\"us\")\n    .build();\n\nlet response = client\n    .multi_search()\n    .with_search_query(search_query_1)\n    .with_search_query(search_query_2)\n    .with_search_query(search_query_3)\n    .execute::<Document>()\n    .await\n    .unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/multi-search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"queries\": [\n      {\n        \"indexUid\": \"movies\",\n        \"q\": \"pooh\",\n        \"limit\": 5\n      },\n      {\n        \"indexUid\": \"movies\",\n        \"q\": \"nemo\",\n        \"limit\": 5\n      },\n      {\n        \"indexUid\": \"movie_ratings\",\n        \"q\": \"us\"\n      }\n    ]\n  }'"
          }
        ]
      }
    },
    "/network": {
      "get": {
        "tags": [
          "Network"
        ],
        "summary": "Get network topology",
        "description": "Get a list of all Meilisearch instances currently known to this instance.",
        "operationId": "get_network",
        "responses": {
          "200": {
            "description": "Known nodes are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Network"
                },
                "example": {
                  "self": "ms-0",
                  "remotes": {
                    "ms-0": {
                      "url": "http://localhost:7700",
                      "searchApiKey": null,
                      "writeApiKey": null
                    },
                    "ms-1": {
                      "url": "http://localhost:7701",
                      "searchApiKey": "foo",
                      "writeApiKey": "bar"
                    },
                    "ms-2": {
                      "url": "http://localhost:7702",
                      "searchApiKey": "bar",
                      "writeApiKey": "foo"
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "network.get",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/network'"
          }
        ]
      },
      "patch": {
        "tags": [
          "Network"
        ],
        "summary": "Configure Network",
        "description": "Add or remove nodes from network.",
        "operationId": "patch_network",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Network"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "New network state is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Network"
                },
                "example": {
                  "self": "ms-0",
                  "remotes": {
                    "ms-0": {
                      "url": "http://localhost:7700",
                      "searchApiKey": null,
                      "writeApiKey": null
                    },
                    "ms-1": {
                      "url": "http://localhost:7701",
                      "searchApiKey": "foo",
                      "writeApiKey": "bar"
                    },
                    "ms-2": {
                      "url": "http://localhost:7702",
                      "searchApiKey": "bar",
                      "writeApiKey": "foo"
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "network.update",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/network' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"self\": \"ms-00\",\n    \"remotes\": {\n      \"ms-00\": {\n        \"url\": \"http://INSTANCE_URL\",\n        \"searchApiKey\": \"INSTANCE_API_KEY\"\n      },\n      \"ms-01\": {\n        \"url\": \"http://ANOTHER_INSTANCE_URL\",\n        \"searchApiKey\": \"ANOTHER_INSTANCE_API_KEY\"\n      }\n    }\n  }'"
          }
        ]
      }
    },
    "/snapshots": {
      "post": {
        "tags": [
          "Snapshots"
        ],
        "summary": "Create a snapshot",
        "description": "Triggers a snapshot creation process. Once the process is complete, a snapshot is created in the snapshot directory. If the snapshot directory does not exist yet, it will be created.",
        "operationId": "create_snapshot",
        "responses": {
          "202": {
            "description": "Snapshot is being created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 0,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "snapshotCreation",
                  "enqueuedAt": "2021-01-01T09:39:00.000000Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "snapshots.create",
              "snapshots.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.CreateSnapshotAsync();"
          },
          {
            "lang": "Go",
            "source": "client.CreateSnapshot()"
          },
          {
            "lang": "JS",
            "source": "client.createSnapshot()"
          },
          {
            "lang": "Java",
            "source": "client.createSnapshot();"
          },
          {
            "lang": "PHP",
            "source": "$client->createSnapshot();"
          },
          {
            "lang": "Python",
            "source": "client.create_snapshot()"
          },
          {
            "lang": "Ruby",
            "source": "client.create_snapshot"
          },
          {
            "lang": "Rust",
            "source": "client\n  .create_snapshot()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let task = try await self.client.createSnapshot()"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/snapshots'"
          }
        ]
      }
    },
    "/stats": {
      "get": {
        "tags": [
          "Stats"
        ],
        "summary": "Get stats of all indexes.",
        "description": "Get stats of all indexes.",
        "operationId": "get_stats",
        "responses": {
          "200": {
            "description": "The stats of the instance",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Stats"
                },
                "example": {
                  "databaseSize": 567,
                  "usedDatabaseSize": 456,
                  "lastUpdate": "2019-11-20T09:40:33.711324Z",
                  "indexes": {
                    "movies": {
                      "numberOfDocuments": 10,
                      "rawDocumentDbSize": 100,
                      "maxDocumentSize": 16,
                      "avgDocumentSize": 10,
                      "isIndexing": true,
                      "fieldDistribution": {
                        "genre": 10,
                        "author": 9
                      }
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "stats.get",
              "stats.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.GetStatsAsync();"
          },
          {
            "lang": "Dart",
            "source": "await client.getStats();"
          },
          {
            "lang": "Go",
            "source": "client.GetStats()"
          },
          {
            "lang": "JS",
            "source": "client.getStats()"
          },
          {
            "lang": "Java",
            "source": "client.getStats();"
          },
          {
            "lang": "PHP",
            "source": "$client->stats();"
          },
          {
            "lang": "Python",
            "source": "client.get_all_stats()"
          },
          {
            "lang": "Ruby",
            "source": "client.stats"
          },
          {
            "lang": "Rust",
            "source": "let stats: ClientStats = client\n  .get_stats()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.allStats { (result) in\n    switch result {\n    case .success(let stats):\n        print(stats)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/stats'"
          }
        ]
      }
    },
    "/swap-indexes": {
      "post": {
        "tags": [
          "Indexes"
        ],
        "summary": "Swap indexes",
        "description": "Swap the documents, settings, and task history of two or more indexes. You can only swap indexes in pairs. However, a single request can swap as many index pairs as you wish.\nSwapping indexes is an atomic transaction: either all indexes are successfully swapped, or none are.\nSwapping indexA and indexB will also replace every mention of indexA by indexB and vice-versa in the task history. enqueued tasks are left unmodified.",
        "operationId": "swap_indexes",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/SwapIndexesPayload"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 3,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "indexSwap",
                  "enqueuedAt": "2021-08-12T10:00:00.000000Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "search",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.SwapIndexesAsync(new List<IndexSwap> { new IndexSwap(\"indexA\", \"indexB\"), new IndexSwap(\"indexX\", \"indexY\") } });"
          },
          {
            "lang": "Go",
            "source": "client.SwapIndexes([]SwapIndexesParams{\n  {Indexes: []string{\"indexA\", \"indexB\"}},\n  {Indexes: []string{\"indexX\", \"indexY\"}},\n})"
          },
          {
            "lang": "JS",
            "source": "client.swapIndexes([\n  { 'indexes': ['indexA', 'indexB'] },\n  { 'indexes': ['indexX', 'indexY'] }\n])"
          },
          {
            "lang": "Java",
            "source": "SwapIndexesParams[] params =\n        new SwapIndexesParams[] {\n            new SwapIndexesParams().setIndexes(new String[] {\"indexA\", \"indexB\"}),\n            new SwapIndexesParams().setIndexes(new String[] {\"indexX\", \"indexY\"})\n        };\nTaskInfo task = client.swapIndexes(params);"
          },
          {
            "lang": "PHP",
            "source": "$client->swapIndexes([['indexA', 'indexB'], ['indexX', 'indexY']]);"
          },
          {
            "lang": "Python",
            "source": "client.swap_indexes([{'indexes': ['indexA', 'indexB']}, {'indexes': ['indexX', 'indexY']}])"
          },
          {
            "lang": "Ruby",
            "source": "client.swap_indexes(['indexA', 'indexB'], ['indexX', 'indexY'])"
          },
          {
            "lang": "Rust",
            "source": "client.swap_indexes([\n  &SwapIndexes {\n    indexes: (\n        \"indexA\".to_string(),\n        \"indexB\".to_string(),\n    ),\n  }, &SwapIndexes {\n    indexes: (\n        \"indexX\".to_string(),\n        \"indexY\".to_string(),\n    ),\n}])"
          },
          {
            "lang": "Swift",
            "source": "let task = try await self.client.swapIndexes([\n  (\"indexA\", \"indexB\"),\n  (\"indexX\", \"indexY\")\n])"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/swap-indexes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    {\n      \"indexes\": [\n        \"indexA\",\n        \"indexB\"\n      ]\n    },\n    {\n      \"indexes\": [\n        \"indexX\",\n        \"indexY\"\n      ]\n    }\n  ]'"
          }
        ]
      }
    },
    "/tasks": {
      "get": {
        "tags": [
          "Tasks"
        ],
        "summary": "Get all tasks",
        "description": "Get all [tasks](https://docs.meilisearch.com/learn/advanced/asynchronous_operations.html)",
        "operationId": "get_tasks",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "u-int32",
              "default": 20,
              "minimum": 0
            },
            "example": 12
          },
          {
            "name": "from",
            "in": "query",
            "description": "Fetch the next set of results from the given uid.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "u-int32",
              "minimum": 0
            },
            "example": 12421
          },
          {
            "name": "reverse",
            "in": "query",
            "description": "The order you want to retrieve the objects.",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "example": true
          },
          {
            "name": "batchUids",
            "in": "query",
            "description": "Permits to filter tasks by their batch uid. By default, when the `batchUids` query parameter is not set, all task uids are returned. It's possible to specify several batch uids by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "u-int32",
              "minimum": 0
            },
            "example": 12421
          },
          {
            "name": "uids",
            "in": "query",
            "description": "Permits to filter tasks by their uid. By default, when the uids query parameter is not set, all task uids are returned. It's possible to specify several uids by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              231,
              423,
              598,
              "*"
            ]
          },
          {
            "name": "canceledBy",
            "in": "query",
            "description": "Permits to filter tasks using the uid of the task that canceled them. It's possible to specify several task uids by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              374,
              "*"
            ]
          },
          {
            "name": "types",
            "in": "query",
            "description": "Permits to filter tasks by their related type. By default, when `types` query parameter is not set, all task types are returned. It's possible to specify several types by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "example": [
              "documentAdditionOrUpdate",
              "*"
            ]
          },
          {
            "name": "statuses",
            "in": "query",
            "description": "Permits to filter tasks by their status. By default, when `statuses` query parameter is not set, all task statuses are returned. It's possible to specify several statuses by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Status"
              }
            },
            "example": [
              "succeeded",
              "failed",
              "canceled",
              "enqueued",
              "processing",
              "*"
            ]
          },
          {
            "name": "indexUids",
            "in": "query",
            "description": "Permits to filter tasks by their related index. By default, when `indexUids` query parameter is not set, the tasks of all the indexes are returned. It is possible to specify several indexes by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "example": [
              "movies",
              "theater",
              "*"
            ]
          },
          {
            "name": "afterEnqueuedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their enqueuedAt time. Matches tasks enqueued after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "beforeEnqueuedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their enqueuedAt time. Matches tasks enqueued before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "afterStartedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their startedAt time. Matches tasks started after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "beforeStartedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their startedAt time. Matches tasks started before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "afterFinishedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their finishedAt time. Matches tasks finished after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "beforeFinishedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their finishedAt time. Matches tasks finished before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          }
        ],
        "responses": {
          "200": {
            "description": "Get all tasks",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AllTasks"
                },
                "example": {
                  "results": [
                    {
                      "uid": 144,
                      "indexUid": "mieli",
                      "status": "succeeded",
                      "type": "settingsUpdate",
                      "canceledBy": null,
                      "details": {
                        "settings": {
                          "filterableAttributes": [
                            "play_count"
                          ]
                        }
                      },
                      "error": null,
                      "duration": "PT0.009330S",
                      "enqueuedAt": "2024-08-08T09:01:13.348471Z",
                      "startedAt": "2024-08-08T09:01:13.349442Z",
                      "finishedAt": "2024-08-08T09:01:13.358772Z"
                    }
                  ],
                  "total": 1,
                  "limit": 1,
                  "from": 144,
                  "next": null
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "tasks.get",
              "tasks.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "Dart",
            "source": "await client.getTasks();"
          },
          {
            "lang": "Go",
            "source": "client.GetTasks(nil);"
          },
          {
            "lang": "JS",
            "source": "client.tasks.getTasks()"
          },
          {
            "lang": "Java",
            "source": "client.getTasks();"
          },
          {
            "lang": "PHP",
            "source": "$client->getTasks();"
          },
          {
            "lang": "Python",
            "source": "client.get_tasks()"
          },
          {
            "lang": "Ruby",
            "source": "client.tasks"
          },
          {
            "lang": "Rust",
            "source": "let tasks: TasksResults = client\n  .get_tasks()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.getTasks { (result) in\n    switch result {\n    case .success(let tasks):\n        print(tasks)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/tasks'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Tasks"
        ],
        "summary": "Delete tasks",
        "description": "Delete [tasks](https://docs.meilisearch.com/learn/advanced/asynchronous_operations.html) on filter",
        "operationId": "delete_tasks",
        "parameters": [
          {
            "name": "uids",
            "in": "query",
            "description": "Permits to filter tasks by their uid. By default, when the `uids` query parameter is not set, all task uids are returned. It's possible to specify several uids by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              231,
              423,
              598,
              "*"
            ]
          },
          {
            "name": "batchUids",
            "in": "query",
            "description": "Lets you filter tasks by their `batchUid`.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              231,
              423,
              598,
              "*"
            ]
          },
          {
            "name": "canceledBy",
            "in": "query",
            "description": "Permits to filter tasks using the uid of the task that canceled them. It's possible to specify several task uids by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              374,
              "*"
            ]
          },
          {
            "name": "types",
            "in": "query",
            "description": "Permits to filter tasks by their related type. By default, when `types` query parameter is not set, all task types are returned. It's possible to specify several types by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Kind"
              }
            },
            "example": [
              "documentDeletion",
              "*"
            ]
          },
          {
            "name": "statuses",
            "in": "query",
            "description": "Permits to filter tasks by their status. By default, when `statuses` query parameter is not set, all task statuses are returned. It's possible to specify several statuses by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Status"
              }
            },
            "example": [
              "succeeded",
              "failed",
              "canceled",
              "*"
            ]
          },
          {
            "name": "indexUids",
            "in": "query",
            "description": "Permits to filter tasks by their related index. By default, when `indexUids` query parameter is not set, the tasks of all the indexes are returned. It is possible to specify several indexes by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "example": [
              "movies",
              "theater",
              "*"
            ]
          },
          {
            "name": "afterEnqueuedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their enqueuedAt time. Matches tasks enqueued after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "beforeEnqueuedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their enqueuedAt time. Matches tasks enqueued before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "afterStartedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their startedAt time. Matches tasks started after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "beforeStartedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their startedAt time. Matches tasks started before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "afterFinishedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their finishedAt time. Matches tasks finished after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "beforeFinishedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their finishedAt time. Matches tasks finished before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          }
        ],
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "taskDeletion",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "400": {
            "description": "A filter is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Query parameters to filter the tasks to delete are missing. Available query parameters are: `uids`, `indexUids`, `statuses`, `types`, `canceledBy`, `beforeEnqueuedAt`, `afterEnqueuedAt`, `beforeStartedAt`, `afterStartedAt`, `beforeFinishedAt`, `afterFinishedAt`.",
                  "code": "missing_task_filters",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#missing_task_filters"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "The task uid does not exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Task :taskUid not found.",
                  "code": "task_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors/#task_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "tasks.delete",
              "tasks.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.DeleteTasksAsync(new DeleteTasksQuery { Uids = new List<int> { 1, 2 } });"
          },
          {
            "lang": "Dart",
            "source": "await client.deleteTasks(params: DeleteTasksQuery(uids: [1, 2]));"
          },
          {
            "lang": "Go",
            "source": "client.DeleteTaks(&meilisearch.DeleteTasksQuery{\n  UIDS: []int64{1, 2},\n});"
          },
          {
            "lang": "JS",
            "source": "client.tasks.deleteTasks({ uids: [1, 2] })"
          },
          {
            "lang": "Java",
            "source": "DeleteTasksQuery query = new DeleteTasksQuery().setUids(new int[] {1, 2})\nclient.deleteTasks(query);"
          },
          {
            "lang": "PHP",
            "source": "$client->deleteTasks((new DeleteTasksQuery())->setUids([1, 2]));"
          },
          {
            "lang": "Python",
            "source": "client.delete_tasks({'uids': ['1', '2']})"
          },
          {
            "lang": "Ruby",
            "source": "client.delete_tasks(uids: [1, 2])"
          },
          {
            "lang": "Rust",
            "source": "let mut query = tasks::TasksDeleteQuery::new(&client);\nquery.with_uids([1, 2]);\n\nlet res = client.delete_tasks_with(&query).await.unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.deleteTasks(filter: DeleteTasksQuery(uids: [1, 2])) { (result) in\n    switch result {\n    case .success(let taskInfo):\n        print(taskInfo)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/tasks?uids=1,2'"
          }
        ]
      }
    },
    "/tasks/cancel": {
      "post": {
        "tags": [
          "Tasks"
        ],
        "summary": "Cancel tasks",
        "description": "Cancel enqueued and/or processing [tasks](https://www.meilisearch.com/docs/learn/async/asynchronous_operations)",
        "operationId": "cancel_tasks",
        "parameters": [
          {
            "name": "uids",
            "in": "query",
            "description": "Permits to filter tasks by their uid. By default, when the `uids` query parameter is not set, all task uids are returned. It's possible to specify several uids by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              231,
              423,
              598,
              "*"
            ]
          },
          {
            "name": "batchUids",
            "in": "query",
            "description": "Lets you filter tasks by their `batchUid`.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              231,
              423,
              598,
              "*"
            ]
          },
          {
            "name": "canceledBy",
            "in": "query",
            "description": "Permits to filter tasks using the uid of the task that canceled them. It's possible to specify several task uids by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              374,
              "*"
            ]
          },
          {
            "name": "types",
            "in": "query",
            "description": "Permits to filter tasks by their related type. By default, when `types` query parameter is not set, all task types are returned. It's possible to specify several types by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Kind"
              }
            },
            "example": [
              "documentDeletion",
              "*"
            ]
          },
          {
            "name": "statuses",
            "in": "query",
            "description": "Permits to filter tasks by their status. By default, when `statuses` query parameter is not set, all task statuses are returned. It's possible to specify several statuses by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Status"
              }
            },
            "example": [
              "succeeded",
              "failed",
              "canceled",
              "*"
            ]
          },
          {
            "name": "indexUids",
            "in": "query",
            "description": "Permits to filter tasks by their related index. By default, when `indexUids` query parameter is not set, the tasks of all the indexes are returned. It is possible to specify several indexes by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "example": [
              "movies",
              "theater",
              "*"
            ]
          },
          {
            "name": "afterEnqueuedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their enqueuedAt time. Matches tasks enqueued after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "beforeEnqueuedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their enqueuedAt time. Matches tasks enqueued before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "afterStartedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their startedAt time. Matches tasks started after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "beforeStartedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their startedAt time. Matches tasks started before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "afterFinishedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their finishedAt time. Matches tasks finished after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "beforeFinishedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their finishedAt time. Matches tasks finished before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          }
        ],
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "taskCancelation",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "400": {
            "description": "A filter is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Query parameters to filter the tasks to cancel are missing. Available query parameters are: `uids`, `indexUids`, `statuses`, `types`, `canceledBy`, `beforeEnqueuedAt`, `afterEnqueuedAt`, `beforeStartedAt`, `afterStartedAt`, `beforeFinishedAt`, `afterFinishedAt`.",
                  "code": "missing_task_filters",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#missing_task_filters"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "The task uid does not exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Task :taskUid not found.",
                  "code": "task_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors/#task_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "tasks.cancel",
              "tasks.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.CancelTasksAsync(new CancelTasksQuery { Uids = new List<int> { 1, 2 } });"
          },
          {
            "lang": "Dart",
            "source": "await client.cancelTasks(params: CancelTasksQuery(uids: [1, 2]));"
          },
          {
            "lang": "Go",
            "source": "client.CancelTasks(&meilisearch.CancelTasksQuery{\n  UIDS: []int64{1, 2},\n});"
          },
          {
            "lang": "JS",
            "source": "client.tasks.cancelTasks({ uids: [1, 2] })"
          },
          {
            "lang": "Java",
            "source": "CancelTasksQuery query = new CancelTasksQuery().setUids(new int[] {1, 2})\nclient.cancelTasks(query);"
          },
          {
            "lang": "PHP",
            "source": "$client->cancelTasks((new CancelTasksQuery())->setUids([1, 2]));"
          },
          {
            "lang": "Python",
            "source": "client.cancel_tasks({'uids': ['1', '2']})"
          },
          {
            "lang": "Ruby",
            "source": "client.cancel_tasks(uids: [1, 2])"
          },
          {
            "lang": "Rust",
            "source": "let mut query = tasks::TasksCancelQuery::new(&client);\nquery.with_uids([1, 2]);\n\nlet res = client.cancel_task_with(&query).await.unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.cancelTasks(filter: CancelTasksQuery(uids: [1, 2])) { (result) in\n    switch result {\n    case .success(let taskInfo):\n        print(taskInfo)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/tasks/cancel?uids=1,2'"
          }
        ]
      }
    },
    "/tasks/{taskUid}": {
      "get": {
        "tags": [
          "Tasks"
        ],
        "summary": "Get a task",
        "description": "Get a [task](https://www.meilisearch.com/docs/learn/async/asynchronous_operations)",
        "operationId": "get_task",
        "parameters": [
          {
            "name": "taskUid",
            "in": "path",
            "description": "The task identifier",
            "required": true,
            "schema": {
              "type": "string",
              "format": "u-int32"
            },
            "example": 0
          }
        ],
        "responses": {
          "200": {
            "description": "Task successfully retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskView"
                },
                "example": {
                  "uid": 1,
                  "indexUid": "movies",
                  "status": "succeeded",
                  "type": "documentAdditionOrUpdate",
                  "canceledBy": null,
                  "details": {
                    "receivedDocuments": 79000,
                    "indexedDocuments": 79000
                  },
                  "error": null,
                  "duration": "PT1S",
                  "enqueuedAt": "2021-01-01T09:39:00.000000Z",
                  "startedAt": "2021-01-01T09:39:01.000000Z",
                  "finishedAt": "2021-01-01T09:39:02.000000Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "The task uid does not exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Task :taskUid not found.",
                  "code": "task_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors/#task_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "tasks.get",
              "tasks.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "ResourceResults<TaskInfo> taskResult = await client.GetTasksAsync(new TasksQuery { Limit = 2, From = 10 });"
          },
          {
            "lang": "C#",
            "source": "ResourceResults<TaskInfo> taskResult = await client.GetTasksAsync(new TasksQuery { Limit = 2, From = 8 });"
          },
          {
            "lang": "Dart",
            "source": "await client.getTask(1);"
          },
          {
            "lang": "Dart",
            "source": "await client.getTasks(params: TasksQuery(limit: 2, from: 10));"
          },
          {
            "lang": "Dart",
            "source": "await client.getTasks(params: TasksQuery(limit: 2, from: 8));"
          },
          {
            "lang": "Go",
            "source": "client.GetTask(1);"
          },
          {
            "lang": "Go",
            "source": "client.GetTasks(&meilisearch.TasksQuery{\n  Limit: 2,\n  From: 10,\n});"
          },
          {
            "lang": "Go",
            "source": "client.GetTasks(&meilisearch.TasksQuery{\n  Limit: 2,\n  From: 8,\n});"
          },
          {
            "lang": "JS",
            "source": "client.tasks.getTask(1)"
          },
          {
            "lang": "JS",
            "source": "client.tasks.getTasks({ limit: 2, from: 10 })"
          },
          {
            "lang": "JS",
            "source": "client.tasks.getTasks({ limit: 2, from: 8 })"
          },
          {
            "lang": "Java",
            "source": "client.getTask(1);"
          },
          {
            "lang": "Java",
            "source": "TasksQuery query = new TasksQuery()\n      .setLimit(2)\n      .setFrom(10);\n\nclient.index(\"movies\").getTasks(query);"
          },
          {
            "lang": "Java",
            "source": "TasksQuery query = new TasksQuery()\n      .setLimit(2)\n      .setFrom(8);\n\nclient.index(\"movies\").getTasks(query);"
          },
          {
            "lang": "PHP",
            "source": "$client->getTask(1);"
          },
          {
            "lang": "PHP",
            "source": "$taskQuery = (new TasksQuery())->setLimit(2)->setFrom(10));\n$client->getTasks($taskQuery);"
          },
          {
            "lang": "PHP",
            "source": "$taskQuery = (new TasksQuery())->setLimit(2)->setFrom(8));\n$client->getTasks($taskQuery);"
          },
          {
            "lang": "Python",
            "source": "client.get_task(1)"
          },
          {
            "lang": "Python",
            "source": "client.get_tasks({\n  'limit': 2,\n  'from': 10\n})"
          },
          {
            "lang": "Python",
            "source": "client.get_tasks({\n  'limit': 2,\n  'from': 8\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.task(1)"
          },
          {
            "lang": "Ruby",
            "source": "client.tasks(limit: 2, from: 10)"
          },
          {
            "lang": "Ruby",
            "source": "client.tasks(limit: 2, from: 8)"
          },
          {
            "lang": "Rust",
            "source": "let task: Task = client\n  .get_task(1)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let mut query = TasksSearchQuery::new(&client)\n    .with_limit(2)\n    .with_from(10)\n    .execute()\n    .await\n    .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let mut query = TasksSearchQuery::new(&client)\n    .with_limit(2)\n    .from(8)\n    .execute()\n    .await\n    .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.getTask(taskUid: 1) { (result) in\n      switch result {\n      case .success(let task):\n          print(task)\n      case .failure(let error):\n          print(error)\n      }\n  }"
          },
          {
            "lang": "Swift",
            "source": "client.getTasks(params: TasksQuery(limit: 2, from: 10)) { result in\n  switch result {\n  case .success(let taskResult):\n    print(taskResult)\n  case .failure(let error):\n    print(error)\n  }\n}"
          },
          {
            "lang": "Swift",
            "source": "client.getTasks(params: TasksQuery(limit: 2, from: 8)) { result in\n  switch result {\n  case .success(let taskResult):\n    print(taskResult)\n  case .failure(let error):\n    print(error)\n  }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/tasks/1'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/tasks?limit=2&from=10"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/tasks?limit=2&from=8"
          }
        ]
      }
    },
    "/version": {
      "get": {
        "tags": [
          "Version"
        ],
        "summary": "Get version",
        "description": "Current version of Meilisearch.",
        "operationId": "get_version",
        "responses": {
          "200": {
            "description": "Instance is healthy",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VersionResponse"
                },
                "example": {
                  "commitSha": "b46889b5f0f2f8b91438a08a358ba8f05fc09fc1",
                  "commitDate": "2021-07-08",
                  "pkgVersion": "0.23.0"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "version",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "C#",
            "source": "await client.GetVersionAsync();"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"jackets\").UpdateDistinctAttributeAsync(\"product_id\");"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").UpdateSearchableAttributesAsync(new[]\n{\n    \"title\",\n    \"overview\",\n    \"genres\"\n});"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").UpdateDisplayedAttributesAsync(new[]\n{\n    \"title\",\n    \"overview\",\n    \"genres\",\n    \"release_date\"\n});"
          },
          {
            "lang": "C#",
            "source": "SearchQuery filters = new SearchQuery() { Filter = \"release_date > \\\"795484800\\\"\" };\nvar movies = await client.Index(\"movie_ratings\").SearchAsync<Movie>(\"Avengers\", filters);"
          },
          {
            "lang": "C#",
            "source": "SearchQuery filters = new SearchQuery() { Filter = \"release_date > 795484800 AND (director =\n\\\"Tim Burton\\\" OR director = \\\"Christopher Nolan\\\")\" };\nvar movies = await client.Index(\"movie_ratings\").SearchAsync<Movie>(\"Batman\", filters);"
          },
          {
            "lang": "C#",
            "source": "SearchQuery filters = new SearchQuery() { Filter = \"release_date > 1577884550 AND (NOT director = \\\"Tim Burton\\\")\" };\nvar movies = await client.Index(\"movie_ratings\").SearchAsync<Movie>(\"Planet of the Apes\", filters);"
          },
          {
            "lang": "C#",
            "source": "var filters = new SearchQuery() { Filter = \"rating.users >= 90\" };\nvar movies = await client.Index(\"movie_ratings\").SearchAsync<MovieRating>(\"thriller\", filters);"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").SearchAsync<Movie>(\"shifu\");"
          },
          {
            "lang": "C#",
            "source": "var sq = new SearchQuery\n{\n    Offset = 1\n};\nvar result = await client.Index(\"movies\").SearchAsync<Movie>(\"shifu\", sq);\nif(result is SearchResult<Movie> pagedResults)\n{\n}"
          },
          {
            "lang": "C#",
            "source": "var sq = new SearchQuery\n{\n    Limit = 2\n};\nvar result = await client.Index(\"movies\").SearchAsync<Movie>(\"shifu\", sq);\nif(result is SearchResult<Movie> pagedResults)\n{\n}"
          },
          {
            "lang": "C#",
            "source": "var result = await client.Index(\"movies\").SearchAsync<Movie>(\"\", new SearchQuery { HitsPerPage = 15 });\nif(result is PaginatedSearchResult<Movie> pagedResults)\n{\n}"
          },
          {
            "lang": "C#",
            "source": "var result = await client.Index(\"movies\").SearchAsync<Movie>(\"\", new SearchQuery { Page = 2 });\nif(result is PaginatedSearchResult<Movie> pagedResults)\n{\n}"
          },
          {
            "lang": "C#",
            "source": "var sq = new SearchQuery\n{\n    AttributesToRetrieve = new[] {\"overview\", \"title\"}\n};\nawait client.Index(\"movies\").SearchAsync<Movie>(\"shifu\", sq);"
          },
          {
            "lang": "C#",
            "source": "var sq = new SearchQuery\n{\n    AttributesToCrop = new[] {\"overview\"},\n    CropLength = 5\n};\nawait client.Index(\"movies\").SearchAsync<Movie>(\"shifu\", sq);"
          },
          {
            "lang": "C#",
            "source": "var sq = new SearchQuery\n{\n    AttributesToCrop = new[] {\"overview\"},\n    CropMarker = \"[...]\"\n};\nawait client.Index(\"movies\").SearchAsync<Movie>(\"shifu\", sq);"
          },
          {
            "lang": "C#",
            "source": "var sq = new SearchQuery\n{\n    AttributesToHighlight = new[] {\"overview\"}\n};\nawait client.Index(\"movies\").SearchAsync<Movie>(\"winter feast\", sq);"
          },
          {
            "lang": "C#",
            "source": "var sq = new SearchQuery\n{\n    AttributesToHighlight = new[] {\"overview\"},\n    HighlightPreTag = \"<span class=\\\"highlight\\\">\",\n    HighlightPostTag = \"</span>\"\n};\nawait client.Index(\"movies\").SearchAsync<Movie>(\"winter feast\", sq);"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").SearchAsync<T>(\n  \"winter feast\",\n  new SearchQuery\n  {\n      ShowMatchesPosition = True,\n  });"
          },
          {
            "lang": "C#",
            "source": "// Make sure to add this using to your code\nusing System.IO;\n\nvar jsonDocuments = await File.ReadAllTextAsync(\"movies.json\");\nawait client.Index(\"movies\").AddDocumentsJsonAsync(jsonDocuments);"
          },
          {
            "lang": "C#",
            "source": "// In the command line:\n// dotnet add package Meilisearch\n\n// In your .cs file:\nusing System.IO;\nusing System.Text.Json;\nusing Meilisearch;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\n\nnamespace Meilisearch_demo\n{\n    public class Movie\n    {\n        public string Id { get; set; }\n        public string Title { get; set; }\n        public string Poster { get; set; }\n        public string Overview { get; set; }\n        public IEnumerable<string> Genres { get; set; }\n    }\n\n    internal class Program\n    {\n        static async Task Main(string[] args)\n        {\n            MeilisearchClient client = new MeilisearchClient(\"http://localhost:7700\", \"aSampleMasterKey\");\n            var options = new JsonSerializerOptions\n            {\n                PropertyNameCaseInsensitive = true\n            };\n\n            string jsonString = await File.ReadAllTextAsync(\"movies.json\");\n            var movies = JsonSerializer.Deserialize<IEnumerable<Movie>>(jsonString, options);\n\n            var index = client.Index(\"movies\");\n            await index.AddDocumentsAsync<Movie>(movies);\n        }\n    }\n}"
          },
          {
            "lang": "C#",
            "source": "TaskInfo task = await client.GetTaskAsync(0);"
          },
          {
            "lang": "C#",
            "source": "MeilisearchClient client = new MeilisearchClient(\"http://localhost:7700\", \"masterKey\");\nvar index = client.Index(\"movies\");\n\nvar movies = await index.SearchAsync<Movie>(\"botman\");\nforeach (var movie in movies.Hits)\n{\n    Console.WriteLine(movie.Title);\n}"
          },
          {
            "lang": "C#",
            "source": "MeilisearchClient client = new MeilisearchClient(\"http://localhost:7700\", \"masterKey\");\nvar options = new JsonSerializerOptions\n{\n    PropertyNameCaseInsensitive = true\n};\n\nstring jsonString = await File.ReadAllTextAsync(\"meteorites.json\");\nvar meteorites = JsonSerializer.Deserialize<IEnumerable<Meteorite>>(jsonString, options);\n\nvar index = client.Index(\"meteorites\");\nawait index.AddDocumentsAsync<Meteorite>(meteorites);"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").UpdateRankingRulesAsync(new string[] {\n  \"exactness\",\n  \"words\",\n  \"typo\",\n  \"proximity\",\n  \"attribute\",\n  \"sort\",\n  \"release_date:asc\",\n  \"rank:desc\"\n});"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").UpdateDisplayedAttributesAsync(new string[] {\n  \"title\",\n  \"overview\",\n  \"poster\"\n});"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").UpdateSearchableAttributesAsync(new string[] {\n  \"title\"\n});"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").UpdateStopWordsAsync(new string[] {\n  \"the\"\n});"
          },
          {
            "lang": "C#",
            "source": "var newSynonyms = new Dictionary<string, IEnumerable<string>>\n{\n    { \"winnie\", new string[] { \"piglet\" } },\n    { \"piglet\", new string[] { \"winnie\" } },\n};\nawait client.Index(\"movies\").UpdateSynonymsAsync(newSynonyms);"
          },
          {
            "lang": "C#",
            "source": "SearchQuery filter = new SearchQuery() { Filter = \"mass < 200\" };\nawait client.Index(\"meteorites\").SearchAsync<Meteorite>(\"\", filter);"
          },
          {
            "lang": "C#",
            "source": "SearchQuery filter = new SearchQuery() { Filter = \"_geoRadius(46.9480, 7.4474, 210000)\" };\nawait client.Index(\"meteorites\").SearchAsync<Meteorite>(\"\", filter);"
          },
          {
            "lang": "C#",
            "source": "SearchQuery sort = new SearchQuery() { Sort = new string[] { \"_geoPoint(48.8583701,2.2922926):asc\" }};\nawait client.Index(\"meteorites\").SearchAsync<Meteorite>(\"\", sort);"
          },
          {
            "lang": "C#",
            "source": "SearchQuery searchQuery = new SearchQuery() {\n  Sort = new string[] { \"mass:asc\" },\n  Filter = \"mass < 200\",\n};\nawait client.Index(\"meteorites\").SearchAsync<Meteorite>(\"\", searchQuery);"
          },
          {
            "lang": "C#",
            "source": "var newSettings = new Settings\n{\n    FilterableAttributes = new string[] { \"mass\", \"_geo\" },\n    SortableAttributes = new string[] { \"mass\", \"_geo\" },\n};\nawait client.Index(\"meteorites\").UpdateSettingsAsync(newSettings);"
          },
          {
            "lang": "C#",
            "source": "var sq = new SearchQuery\n{\n    Filter = \"(genre = 'Horror' AND genre = 'Mystery') OR director = 'Jordan Peele'\"\n};\nawait client.Index(\"movies\").SearchAsync<Movie>(\"thriller\", sq);"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").SearchAsync<Movie>(\"\\\"african american\\\" horror\");"
          },
          {
            "lang": "C#",
            "source": "MeilisearchClient client = new MeilisearchClient(\"http://localhost:7700\", \"masterKey\");\nvar keys = await client.GetKeysAsync();"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"books\").UpdateSortableAttributesAsync(new [] { \"price\", \"author\" });"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"books\").UpdateRankingRulesAsync(new[]\n{\n    \"words\",\n    \"sort\",\n    \"typo\",\n    \"proximity\",\n    \"attribute\",\n    \"exactness\"\n});"
          },
          {
            "lang": "C#",
            "source": "SearchQuery sort = new SearchQuery() { Sort = new string[] { \"rating.users:asc\" }};\nawait client.Index(\"books\").SearchAsync<Book>(\"science fiction\", sort);"
          },
          {
            "lang": "C#",
            "source": "var sq = new SearchQuery\n{\n  Sort = new[] { \"price:asc\" },\n};\nawait client.Index(\"books\").SearchAsync<Book>(\"science fiction\", sq);"
          },
          {
            "lang": "C#",
            "source": "var sq = new SearchQuery\n{\n  Sort = new[] { \"author:desc\" },\n};\nawait client.Index(\"books\").SearchAsync<Book>(\"butler\", sq);"
          },
          {
            "lang": "C#",
            "source": "var sq = new SearchQuery\n{\n  Sort = new[] { \"price:asc\" },\n};\nawait client.Index(\"books\").SearchAsync<Book>(\"science fiction\", sq);"
          },
          {
            "lang": "C#",
            "source": "List<string> attributes = new() { \"_geo\" };\nTaskInfo result = await client.Index(\"movies\").UpdateFilterableAttributesAsync(attributes);"
          },
          {
            "lang": "C#",
            "source": "SearchQuery filters = new SearchQuery() { Filter = \"_geoRadius(45.472735, 9.184019, 2000)\" };\nvar restaurants = await client.Index(\"restaurants\").SearchAsync<Restaurant>(\"\", filters);"
          },
          {
            "lang": "C#",
            "source": "SearchQuery filters = new SearchQuery()\n{\n    Filter = new string[] { \"_geoRadius(45.472735, 9.184019, 2000) AND type = pizza\" }\n};\n\nvar restaurants = await client.Index(\"restaurants\").SearchAsync<Restaurant>(\"restaurants\", filters);"
          },
          {
            "lang": "C#",
            "source": "SearchQuery filters = new SearchQuery()\n{\n    Filter = \"_geoBoundingBox([45.494181, 9.214024], [45.449484, 9.179175])\"\n};\nvar restaurants = await client.Index(\"restaurants\").SearchAsync<Restaurant>(\"restaurants\", filters);"
          },
          {
            "lang": "C#",
            "source": "List<string> attributes = new() { \"_geo\" };\nTaskInfo result = await client.Index(\"restaurants\").UpdateSortableAttributesAsync(attributes);"
          },
          {
            "lang": "C#",
            "source": "SearchQuery filters = new SearchQuery()\n{\n    Sort = new string[] { \"_geoPoint(48.8561446,2.2978204):asc\" }\n};\n\nvar restaurants = await client.Index(\"restaurants\").SearchAsync<Restaurant>(\"\", filters);"
          },
          {
            "lang": "C#",
            "source": "SearchQuery filters = new SearchQuery()\n{\n    Sort = new string[] {\n          \"_geoPoint(48.8561446,2.2978204):asc\",\n          \"rating:desc\"\n    }\n};\n\nvar restaurants = await client.Index(\"restaurants\").SearchAsync<Restaurant>(\"restaurants\", filters);"
          },
          {
            "lang": "C#",
            "source": "MeilisearchClient client = new MeilisearchClient(\"http://localhost:7700\", \"apiKey\");\nvar searchResult = await client.Index(\"patient_medical_records\").SearchAsync<Patient>();"
          },
          {
            "lang": "C#",
            "source": "MeilisearchClient client = new MeilisearchClient(\"http://localhost:7700\", \"masterKey\");\nawait client.UpdateKeyAsync(\"74c9c733-3368-4738-bbe5-1d18a5fecb37\", description: \"Default Search API Key\");"
          },
          {
            "lang": "C#",
            "source": "MeilisearchClient client = new MeilisearchClient(\"http://localhost:7700\", \"masterKey\");\nKey keyOptions = new Key\n{\n    Description = \"Search patient records key\",\n    Actions = new string[] { \"search\" },\n    Indexes = new string[] { \"patient_medical_records\" },\n    ExpiresAt = DateTime.Parse(\"2023-01-01T00:00:00Z\")\n};\nKey createdKey = await this.client.CreateKeyAsync(keyOptions);"
          },
          {
            "lang": "C#",
            "source": "MeilisearchClient client = new MeilisearchClient(\"http://localhost:7700\", \"masterKey\");\nResourceResults<Key> keyResult = await client.GetKeysAsync();\nvar keys = keyResult.Result;"
          },
          {
            "lang": "C#",
            "source": "MeilisearchClient client = new MeilisearchClient(\"http://localhost:7700\", \"masterKey\");\nclient.DeleteKeyAsync(\"ac5cd97d-5a4b-4226-a868-2d0eb6d197ab\")"
          },
          {
            "lang": "C#",
            "source": "TaskInfo task = await client.CreateIndexAsync(\"books\", \"reference_number\");"
          },
          {
            "lang": "C#",
            "source": "await index.AddDocumentsAsync(\n  new[] {\n      new Book {\n          ReferenceNumber = 287947,\n          Title = \"Diary of a Wimpy Kid\",\n          Author = \"Jeff Kinney\",\n          Genres = new string[] { \"comedy\", \"humor\" },\n          Price = 5.00\n      }\n  },\n  \"reference_number\");"
          },
          {
            "lang": "C#",
            "source": "TaskInfo task = await client.UpdateIndexAsync(\"books\", \"title\");"
          },
          {
            "lang": "C#",
            "source": "var typoTolerance = new TypoTolerance {\n  Enabled = false\n};\nawait client.Index(\"movies\").UpdateTypoToleranceAsync(typoTolerance);"
          },
          {
            "lang": "C#",
            "source": "var typoTolerance = new TypoTolerance {\n  DisableOnAttributes = new string[] { \"title\" }\n};\nawait client.Index(\"movies\").UpdateTypoToleranceAsync(typoTolerance);"
          },
          {
            "lang": "C#",
            "source": "var typoTolerance = new TypoTolerance {\n  DisableOnWords = new string[] { \"shrek\" }\n};\nawait client.Index(\"movies\").UpdateTypoToleranceAsync(typoTolerance);"
          },
          {
            "lang": "C#",
            "source": "var typoTolerance = new TypoTolerance {\n  MinWordSizeTypos = new TypoTolerance.TypoSize {\n    OneTypo = 4,\n    TwoTypos = 10\n  }\n};\n\nawait client.Index(\"movies\").UpdateTypoToleranceAsync(typoTolerance);"
          },
          {
            "lang": "C#",
            "source": "var typoTolerance = new TypoTolerance {\n  MinWordSizeTypos = new TypoTolerance.TypoSize {\n    OneTypo = 4\n  }\n};\n\nawait client.Index(\"movies\").UpdateTypoToleranceAsync(typoTolerance);"
          },
          {
            "lang": "C#",
            "source": "var synonyms = new Dictionary<string, IEnumerable<string>>\n{\n    { \"great\", new string[] { \"fantastic\" } },\n    { \"fantastic\", new string[] { \"great\" } }\n};\nawait client.Index(\"movies\").UpdateSynonymsAsync(synonyms);"
          },
          {
            "lang": "C#",
            "source": "var faceting = new Faceting\n{\n    MaxValuesPerFacet = 2,\n    SortFacetValuesBy = new Dictionary<string, SortFacetValuesByType>\n    {\n        [\"*\"] = SortFacetValuesByType.Count\n    }\n};\nawait client.Index(\"movies\").UpdateFacetingAsync(faceting);"
          },
          {
            "lang": "C#",
            "source": "var pagination = new Pagination {\n  MaxTotalHits = 500\n};\nawait client.Index(\"movies\").UpdatePaginationAsync(pagination);"
          },
          {
            "lang": "C#",
            "source": "SearchQuery params = new SearchQuery() { MatchingStrategy = \"last\" };\nawait client.Index(\"movies\").SearchAsync<Game>(\"big fat liar\", params);"
          },
          {
            "lang": "C#",
            "source": "SearchQuery params = new SearchQuery() { MatchingStrategy = \"all\" };\nawait client.Index(\"movies\").SearchAsync<Game>(\"big fat liar\", params);"
          },
          {
            "lang": "C#",
            "source": "string jsonString = await File.ReadAllTextAsync(\"games.json\");\nvar games = JsonSerializer.Deserialize<IEnumerable<Movie>>(jsonString, options);\nvar index = client.Index(\"games\");\nawait index.AddDocumentsAsync<Movie>(games);"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"games\").UpdateFilterableAttributesAsync(new string[] { \"release_timestamp\" });"
          },
          {
            "lang": "C#",
            "source": "var filters = new SearchQuery() { Filter = \"release_timestamp >= 1514761200 AND release_timestamp < 1672527600\" };\nvar games = await client.Index(\"games\").SearchAsync<Game>(\"\", filters);"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"games\").UpdateSortableAttributesAsync(new string[] { \"release_timestamp\" });"
          },
          {
            "lang": "C#",
            "source": "SearchQuery sort = new SearchQuery() { Sort = new string[] { \"release_timestamp:desc\" }};\nawait client.Index(\"games\").SearchAsync<Game>(\"\", sort);"
          },
          {
            "lang": "C#",
            "source": "await client.GetTasksAsync(new TasksQuery { Statuses = new List<TaskInfoStatus> { TaskInfoStatus.Failed, TaskInfoStatus.Canceled } });"
          },
          {
            "lang": "C#",
            "source": "var query = new TasksQuery { IndexUids = new List<string> { \"movies\" }, Types = new List<TaskInfo> { TaskInfo.DocumentAdditionOrUpdate, TaskInfo.DocumentDeletion }, Statuses = new List<TaskInfoStatus> { TaskInfoStatus.Processing } };\n\nawait client.GetTasksAsync(query);"
          },
          {
            "lang": "C#",
            "source": "List<string> attributes = new() { \"genres\", \"rating\", \"language\" };\nTaskInfo result = await client.Index(\"movie_ratings\").UpdateFilterableAttributesAsync(attributes);"
          },
          {
            "lang": "C#",
            "source": "var sq = new SearchQuery\n{\n    Facets = new string[] { \"genres\", \"rating\", \"language\" }\n};\nawait client.Index(\"books\").SearchAsync<Book>(\"classic\", sq);"
          },
          {
            "lang": "C#",
            "source": "var sq = new SearchQuery\n{\n  Facets = new string[] { \"genres\", \"rating\" }\n};\nawait client.Index(\"movie_ratings\").SearchAsync<Movie>(\"Batman\", sq);"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").UpdateFilterableAttributesAsync(new [] { \"director\", \"genres\" });"
          },
          {
            "lang": "C#",
            "source": "var newFaceting = new Faceting\n{\n    SortFacetValuesBy = new Dictionary<string, SortFacetValuesByType>\n    {\n        [\"genres\"] = SortFacetValuesByType.Count\n    }\n};\nawait client.Index(\"books\").UpdateFacetingAsync(newFaceting);"
          },
          {
            "lang": "C#",
            "source": "var query = new SearchFacetsQuery()\n{\n  FacetQuery = \"c\",\n  ExhaustiveFacetCount: true\n};\nawait client.Index(\"books\").FacetSearchAsync(\"genres\", query);"
          },
          {
            "lang": "C#",
            "source": "var params = new SearchQuery()\n{\n  ShowRankingScore = true\n};\nawait client.Index(\"movies\").SearchAsync<MovieWithRankingScore>(\"dragon\", params);"
          },
          {
            "lang": "C#",
            "source": "var params = new SearchQuery()\n{\n  ShowRankingScoreDetails = true\n};\nawait client.Index(\"movies\").SearchAsync<MovieWithRankingScoreDetails>(\"dragon\", params);"
          },
          {
            "lang": "C#",
            "source": "var searchQuery = new SearchQuery\n{\n  AttributesToSearchOn = new[] { \"overview\" }\n};\nawait client.Index(\"movies\").SearchAsync<Movie>(\"adventure\", searchQuery);"
          },
          {
            "lang": "C#",
            "source": "var params = new SearchQuery()\n{\n  Distinct = \"ATTRIBUTE_A\"\n};\nawait client.Index(\"INDEX_NAME\").SearchAsync<T>(\"QUERY TERMS\", params);"
          },
          {
            "lang": "C#",
            "source": "List<string> attributes = new() { \"product_id\", \"sku\", \"url\" };\nTaskInfo result = await client.Index(\"products\").UpdateFilterableAttributesAsync(attributes);"
          },
          {
            "lang": "C#",
            "source": "var params = new SearchQuery()\n{\n  Distinct = \"sku\"\n};\nawait client.Index(\"products\").SearchAsync<Product>(\"white shirt\", params);"
          },
          {
            "lang": "Dart",
            "source": "await client.getVersion();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('jackets').updateDistinctAttribute('product_id');"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').search('shifu');"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').search('shifu', SearchQuery(offset: 1));"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').search('shifu', SearchQuery(limit: 2));"
          },
          {
            "lang": "Dart",
            "source": "await client.getTask(0);"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').search('botman');"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').updateStopWords(['the']);"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').search('\"african american\" horror');"
          },
          {
            "lang": "Dart",
            "source": "var client = MeiliSearchClient('http://localhost:7700', 'masterKey');\nawait client.getKeys();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('books').updateSortableAttributes(['author', 'price']);"
          },
          {
            "lang": "Dart",
            "source": "await client.index('restaurants').updateFilterableAttributes(['_geo']);"
          },
          {
            "lang": "Dart",
            "source": "await client.index('restaurants').updateSortableAttributes(['_geo']);"
          },
          {
            "lang": "Dart",
            "source": "var client = MeiliSearchClient('http://localhost:7700', 'apiKey');\nawait client.index('patient_medical_records').search('');"
          },
          {
            "lang": "Dart",
            "source": "var client = MeiliSearchClient('http://localhost:7700', 'masterKey');\nawait client.createKey(\n  description: 'Search patient records key',\n  actions: ['search'],\n  indexes: ['patient_medical_records'],\n  expiresAt: DateTime(2023, 01, 01),\n);"
          },
          {
            "lang": "Dart",
            "source": "var client = MeiliSearchClient('http://localhost:7700', 'masterKey');\nawait client.getKeys();"
          },
          {
            "lang": "Dart",
            "source": "var client = MeiliSearchClient('http://localhost:7700', 'masterKey');\nawait client.deleteKey('ac5cd97d-5a4b-4226-a868-2d0eb6d197ab');"
          },
          {
            "lang": "Dart",
            "source": "await client.createIndex('books', primaryKey: 'reference_number');"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').addDocuments([\n  {\n    'reference_number': 287947,\n    'title': 'Diary of a Wimpy Kid',\n    'author': 'Jeff Kinney',\n    'genres': ['comedy', 'humor'],\n    'price': 5.00\n  }\n], primaryKey: 'reference_number');"
          },
          {
            "lang": "Dart",
            "source": "await client.updateIndex('books', 'title');"
          },
          {
            "lang": "Dart",
            "source": "final toUpdate = TypoTolerance(enabled: false);\nawait client.index('movies').updateTypoTolerance(toUpdate);"
          },
          {
            "lang": "Dart",
            "source": "final toUpdate = TypoTolerance(\n  disableOnAttributes: ['title'],\n);\nawait client.index('movies').updateTypoTolerance(toUpdate);"
          },
          {
            "lang": "Dart",
            "source": "final toUpdate = TypoTolerance(\n  disableOnWords: ['shrek'],\n);\nawait client.index('movies').updateTypoTolerance(toUpdate);"
          },
          {
            "lang": "Dart",
            "source": "final toUpdate = TypoTolerance(\n  minWordSizeForTypos: MinWordSizeForTypos(\n    oneTypo: 4,\n    twoTypos: 10,\n  ),\n);\nawait client.index('movies').updateTypoTolerance(toUpdate);"
          },
          {
            "lang": "Dart",
            "source": "final toUpdate = TypoTolerance(\n  minWordSizeForTypos: MinWordSizeForTypos(oneTypo: 4),\n);\nawait client.index('movies').updateTypoTolerance(toUpdate);"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').updateFilterableAttributes([\n  'director',\n  'genres',\n]);"
          },
          {
            "lang": "Go",
            "source": "client.GetVersion()"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"jackets\").UpdateDistinctAttribute(\"product_id\")"
          },
          {
            "lang": "Go",
            "source": "searchableAttributes := []string{\n  \"title\",\n  \"overview\",\n  \"genres\",\n}\nclient.Index(\"movies\").UpdateSearchableAttributes(&searchableAttributes)"
          },
          {
            "lang": "Go",
            "source": "displayedAttributes := []string{\n  \"title\",\n  \"overview\",\n  \"genres\",\n  \"release_date\",\n}\nclient.Index(\"movies\").UpdateDisplayedAttributes(&displayedAttributes)"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"movie_ratings\").Search(\"Avengers\", &meilisearch.SearchRequest{\n  Filter: \"release_date > \\\"795484800\\\"\",\n})"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"movie_ratings\").Search(\"Batman\", &meilisearch.SearchRequest{\n  Filter: \"release_date > 795484800 AND (director = \\\"Tim Burton\\\" OR director = \\\"Christopher Nolan\\\")\",\n})"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"movie_ratings\").Search(\"Planet of the Apes\", &meilisearch.SearchRequest{\n  Filter: \"release_date > 1577884550 AND (NOT director = \\\"Tim Burton\\\")\",\n})"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"movie_ratings\").Search(\"thriller\", &meilisearch.SearchRequest{\n  Filter: \"rating.users >= 90\",\n})"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"movies\").Search(\"shifu\", &meilisearch.SearchRequest{})"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"movies\").Search(\"shifu\", &meilisearch.SearchRequest{\n  Offset: 1,\n})"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"movies\").Search(\"shifu\", &meilisearch.SearchRequest{\n  Limit: 2,\n})"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").Search(\"\", &meilisearch.SearchRequest{\n  HitsPerPage: 15,\n})"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").Search(\"\", &meilisearch.SearchRequest{\n  Page: 2,\n})"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"movies\").Search(\"shifu\", &meilisearch.SearchRequest{\n  AttributesToRetrieve: []string{\"overview\", \"title\"},\n})"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"movies\").Search(\"shifu\", &meilisearch.SearchRequest{\n  AttributesToCrop: []string{\"overview\"},\n  CropLength:       5,\n})"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"movies\").Search(\"shifu\", &meilisearch.SearchRequest{\n  AttributesToCrop: []string{\"overview\"},\n  CropMarker:       \"[]\",\n})"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"movies\").Search(\"winter feast\", &meilisearch.SearchRequest{\n  AttributesToHighlight: []string{\"overview\"},\n})"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"movies\").Search(\"winter feast\", &meilisearch.SearchRequest{\n  AttributesToHighlight: []string{\"overview\"},\n  HighlightPreTag: \"<span class=\\\"highlight\\\">\",\n  HighlightPostTag: \"</span>\",\n})"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"movies\").Search(\"winter feast\", &meilisearch.SearchRequest{\n  ShowMatchesPosition:    true,\n})"
          },
          {
            "lang": "Go",
            "source": "import (\n  \"encoding/json\"\n  \"os\"\n)\n\nfile, _ := os.ReadFile(\"movies.json\")\n\nvar movies interface{}\njson.Unmarshal([]byte(file), &movies)\n\nclient.Index(\"movies\").AddDocuments(&movies, nil)"
          },
          {
            "lang": "Go",
            "source": "// In the command line:\n// go get -u github.com/meilisearch/meilisearch-go\n\n// In your .go file:\npackage main\n\nimport (\n  \"os\"\n  \"encoding/json\"\n  \"io\"\n\n  \"github.com/meilisearch/meilisearch-go\"\n)\n\nfunc main() {\n  client := meilisearch.New(\"http://localhost:7700\", meilisearch.WithAPIKey(\"masterKey\"))\n\n  jsonFile, _ := os.Open(\"movies.json\")\n  defer jsonFile.Close()\n\n  byteValue, _ := io.ReadAll(jsonFile)\n  var movies []map[string]interface{}\n  json.Unmarshal(byteValue, &movies)\n\n  _, err := client.Index(\"movies\").AddDocuments(movies, nil)\n  if err != nil {\n      panic(err)\n  }\n}"
          },
          {
            "lang": "Go",
            "source": "client.GetTask(0)"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").Search(\"botman\", &meilisearch.SearchRequest{})"
          },
          {
            "lang": "Go",
            "source": "client := meilisearch.New(\"http://localhost:7700\")\n\njsonFile, _ := os.Open(\"meteorites.json\")\ndefer jsonFile.Close()\n\nbyteValue, _ := io.ReadAll(jsonFile)\nvar meteorites []map[string]interface{}\njson.Unmarshal(byteValue, &meteorites)\n\nclient.Index(\"meteorites\").AddDocuments(meteorites, nil)"
          },
          {
            "lang": "Go",
            "source": "rankingRules := []string{\n  \"exactness\",\n  \"words\",\n  \"typo\",\n  \"proximity\",\n  \"attribute\",\n  \"sort\",\n  \"release_date:asc\",\n  \"rank:desc\",\n}\nclient.Index(\"movies\").UpdateRankingRules(&rankingRules)"
          },
          {
            "lang": "Go",
            "source": "displayedAttributes := []string{\n  \"title\",\n  \"overview\",\n  \"poster\",\n}\nclient.Index(\"movies\").UpdateDisplayedAttributes(&displayedAttributes)"
          },
          {
            "lang": "Go",
            "source": "searchableAttributes := []string{\n  \"title\",\n}\nclient.Index(\"movies\").UpdateSearchableAttributes(&searchableAttributes)"
          },
          {
            "lang": "Go",
            "source": "stopWords := []string{\"the\"}\nclient.Index(\"movies\").UpdateStopWords(&stopWords)"
          },
          {
            "lang": "Go",
            "source": "synonyms := map[string][]string{\n  \"winnie\":  []string{\"piglet\"},\n  \"piglet\":  []string{\"winnie\"},\n}\nclient.Index(\"movies\").UpdateSynonyms(&synonyms)"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"meteorites\").Search(\"\", &meilisearch.SearchRequest{\n  Filter: \"mass < 200\",\n})"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"meteorites\").Search(\"\", &meilisearch.SearchRequest{\n  Filter: \"_geoRadius(46.9480, 7.4474, 210000)\",\n})"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"meteorites\").Search(\"\", &meilisearch.SearchRequest{\n  Sort: []string{\n    \"_geoPoint(48.8583701,2.2922926):asc\",\n  },\n})"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"meteorites\").Search(\"\", &meilisearch.SearchRequest{\n  Filter: \"mass < 200\",\n  Sort: []string{\n    \"mass:asc\",\n  },\n})"
          },
          {
            "lang": "Go",
            "source": "settings := meilisearch.Settings{\n  FilterableAttributes: []string{\n    \"mass\",\n    \"_geo\",\n  },\n  SortableAttributes: []string{\n    \"mass\",\n    \"_geo\",\n  },\n}\nclient.Index(\"meteorites\").UpdateSettings(&settings)"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"movies\").Search(\"thriller\", &meilisearch.SearchRequest{\n  Filter: [][]string{\n    []string{\"genres = Horror\", \"genres = Mystery\"},\n    []string{\"director = \\\"Jordan Peele\\\"\"},\n  },\n})"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"movies\").Search(\"\\\"african american\\\" horror\", &meilisearch.SearchRequest{})"
          },
          {
            "lang": "Go",
            "source": "client := meilisearch.New(\"http://localhost:7700\", meilisearch.WithAPIKey(\"masterKey\"))\nclient.GetKeys(nil);"
          },
          {
            "lang": "Go",
            "source": "sortableAttributes := []string{\n  \"author\",\n  \"price\",\n}\nclient.Index(\"books\").UpdateSortableAttributes(&sortableAttributes)"
          },
          {
            "lang": "Go",
            "source": "rankingRules := []string{\n  \"words\",\n  \"sort\",\n  \"typo\",\n  \"proximity\",\n  \"attribute\",\n  \"exactness\",\n}\nclient.Index(\"books\").UpdateRankingRules(&rankingRules)"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"books\").Search(\"science fiction\", &meilisearch.SearchRequest{\n  Sort: []string{\n    \"rating.users:asc\",\n  },\n})"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"books\").Search(\"science fiction\", &meilisearch.SearchRequest{\n  Sort: []string{\n    \"price:asc\",\n  },\n})"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"books\").Search(\"butler\", &meilisearch.SearchRequest{\n  Sort: []string{\n    \"author:desc\",\n  },\n})"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"books\").Search(\"science fiction\", &meilisearch.SearchRequest{\n  Sort: []string{\n    \"price:asc\",\n  },\n})"
          },
          {
            "lang": "Go",
            "source": "filterableAttributes := []interface{}{\n  \"_geo\",\n}\nclient.Index(\"restaurants\").UpdateFilterableAttributes(&filterableAttributes)"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"restaurants\").Search(\"\", &meilisearch.SearchRequest{\n  Filter: \"_geoRadius(45.472735, 9.184019, 2000)\",\n})"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"restaurants\").Search(\"\", &meilisearch.SearchRequest{\n  Filter: \"_geoRadius(45.472735, 9.184019, 2000) AND type = pizza\",\n})"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"restaurants\").Search(\"\", &meilisearch.SearchRequest{\n  Filter: \"_geoBoundingBox([45.494181, 9.214024], [45.449484, 9.179175])\",\n})"
          },
          {
            "lang": "Go",
            "source": "sortableAttributes := []string{\n  \"_geo\",\n}\nclient.Index(\"restaurants\").UpdateSortableAttributes(&sortableAttributes)"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"restaurants\").Search(\"\", &meilisearch.SearchRequest{\n  Sort: []string{\n    \"_geoPoint(48.8561446,2.2978204):asc\",\n  },\n})"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"restaurants\").Search(\"\", &meilisearch.SearchRequest{\n  Sort: []string{\n    \"_geoPoint(48.8561446,2.2978204):asc\",\n    \"rating:desc\",\n  },\n})"
          },
          {
            "lang": "Go",
            "source": "client := meilisearch.New(\"http://localhost:7700\", meilisearch.WithAPIKey(\"masterKey\"))\nclient.Index(\"patient_medical_records\").Search();"
          },
          {
            "lang": "Go",
            "source": "client := meilisearch.New(\"http://localhost:7700\", meilisearch.WithAPIKey(\"masterKey\"))\n\nclient.UpdateKey(\"74c9c733-3368-4738-bbe5-1d18a5fecb37\", &meilisearch.Key{\n  Indexes: []string{\"doctors\"},\n})"
          },
          {
            "lang": "Go",
            "source": "client := meilisearch.New(\"http://localhost:7700\", meilisearch.WithAPIKey(\"masterKey\"))\n\nclient.CreateKey(&meilisearch.Key{\n  Description: \"Search patient records key\",\n  Actions: []string{\"search\"},\n  Indexes: []string{\"patient_medical_records\"},\n  ExpiresAt: time.Date(2042, time.April, 02, 0, 42, 42, 0, time.UTC),\n})"
          },
          {
            "lang": "Go",
            "source": "client := meilisearch.New(\"http://localhost:7700\", meilisearch.WithAPIKey(\"masterKey\"))\nclient.GetKeys(nil);"
          },
          {
            "lang": "Go",
            "source": "client := meilisearch.New(\"http://localhost:7700\", meilisearch.WithAPIKey(\"masterKey\"))\nclient.DeleteKey(\"74c9c733-3368-4738-bbe5-1d18a5fecb37\");"
          },
          {
            "lang": "Go",
            "source": "client.CreateIndex(&meilisearch.IndexConfig{\n  Uid: \"books\",\n  PrimaryKey: \"reference_number\",\n})"
          },
          {
            "lang": "Go",
            "source": "documents := []map[string]interface{}{\n  {\n    \"reference_number\": 287947,\n    \"title\":            \"Diary of a Wimpy Kid\",\n    \"author\":           \"Jeff Kinney\",\n    \"genres\":           []string{\"comedy\", \"humor\"},\n    \"price\":            5.00,\n  },\n}\nrefrenceNumber := \"reference_number\"\nclient.Index(\"books\").AddDocuments(documents, &refrenceNumber)"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").UpdateIndex(&meilisearch.UpdateIndexRequestParams{\n  PrimaryKey: \"title\",\n})"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").UpdateTypoTolerance(&meilisearch.TypoTolerance{\n  Enabled: false,\n})"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").UpdateTypoTolerance(&meilisearch.TypoTolerance{\n  DisableOnAttributes: []string{\"title\"},\n})"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").UpdateTypoTolerance(&meilisearch.TypoTolerance{\n  DisableOnWords: []string{\"shrek\"},\n})"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").UpdateTypoTolerance(&meilisearch.TypoTolerance{\n  MinWordSizeForTypos: meilisearch.MinWordSizeForTypos{\n    OneTypo: 4,\n    TwoTypos: 10,\n  },\n})"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").UpdateTypoTolerance(&meilisearch.TypoTolerance{\n  DisableOnNumbers: true\n})"
          },
          {
            "lang": "Go",
            "source": "client.index(\"movies\").UpdateTypoTolerance({\n  MinWordSizeForTypos: meilisearch.MinWordSizeForTypos{\n    OneTypo: 4,\n  },\n})"
          },
          {
            "lang": "Go",
            "source": "synonyms := map[string][]string{\n  \"great\":      []string{\"fantastic\"},\n  \"fantastic\":  []string{\"great\"},\n}\nclient.Index(\"movies\").UpdateSynonyms(&synonyms)"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").UpdateFaceting(&meilisearch.Faceting{\n    MaxValuesPerFacet: 2,\n    SortFacetValuesBy: {\n       \"*\": SortFacetTypeCount,\n    }\n})"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").UpdatePagination(&meilisearch.Pagination{\n    MaxTotalHits: 500,\n})"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"movies\").Search(\"big fat liar\", &meilisearch.SearchRequest{\n  MatchingStrategy:    Last,\n})"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"movies\").Search(\"big fat liar\", &meilisearch.SearchRequest{\n  MatchingStrategy:    All,\n})"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").Search(\"white shirt\", &meilisearch.SearchRequest{\n  MatchingStrategy: Frequency,\n})"
          },
          {
            "lang": "Go",
            "source": "jsonFile, _ := os.Open(\"games.json\")\ndefer jsonFile.Close()\n\nbyteValue, _ := io.ReadAll(jsonFile)\nvar games []map[string]interface{}\njson.Unmarshal(byteValue, &games)\n\nclient.Index(\"games\").AddDocuments(games, nil)"
          },
          {
            "lang": "Go",
            "source": "filterableAttributes := []interface{}{\"release_timestamp\"}\nclient.Index(\"games\").UpdateFilterableAttributes(&filterableAttributes)"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"games\").Search(\"\", &meilisearch.SearchRequest{\n  Filter: \"release_timestamp >= 1514761200 AND release_timestamp < 1672527600\",\n})"
          },
          {
            "lang": "Go",
            "source": "sortableAttributes := []string{\"release_timestamp\",\"author\"}\nclient.Index(\"games\").UpdateSortableAttributes(&sortableAttributes)"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"games\").Search(\"\", &meilisearch.SearchRequest{\n  Sort: []string{\n    \"release_timestamp:desc\",\n  },\n})"
          },
          {
            "lang": "Go",
            "source": "client.GetTasks(&meilisearch.TasksQuery{\n  Statuses: []meilisearch.TaskStatus{\n    meilisearch.TaskStatusFailed,\n    meilisearch.TaskStatusCanceled,\n  },\n})"
          },
          {
            "lang": "Go",
            "source": "client.GetTasks(&meilisearch.TasksQuery{\n  IndexUIDS: []string{\"movie\"},\n  Types:     []meilisearch.TaskType{\n    meilisearch.TaskTypeDocumentAdditionOrUpdate,\n    meilisearch.TaskTypeDocumentDeletion,\n  },\n  Statuses:  []meilisearch.TaskStatus{\n    meilisearch.TaskStatusProcessing,\n  },\n})"
          },
          {
            "lang": "Go",
            "source": "filterableAttributes := []interface{}{\n  \"genres\",\n  \"rating\",\n  \"language\",\n}\nclient.Index(\"movie_ratings\").UpdateFilterableAttributes(&filterableAttributes)"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"books\").Search(\"classic\", &meilisearch.SearchRequest{\n  Facets: []string{\n    \"genres\",\n    \"rating\",\n    \"language\",\n  },\n})"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movie_ratings\").Search(\"Batman\", &meilisearch.SearchRequest{\n  Facets: []string{\n    \"genres\",\n    \"rating\",\n  },\n})"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"movies\").UpdateFilterableAttributes(&[]interface{}{\n  \"director\",\n  \"genres\",\n})"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").UpdateFaceting(&meilisearch.Faceting{\n    SortFacetValuesBy: {\n       \"genres\": SortFacetTypeCount,\n    }\n})"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").FacetSearch(&meilisearch.FacetSearchRequest{\n  FacetQuery: \"c\",\n  FacetName: \"genres\",\n  ExhaustiveFacetCount: true\n})"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"movies\").Search(\"dragon\", &meilisearch.SearchRequest{\n  showRankingScore:    true,\n})"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"movies\").Search(\"dragon\", &meilisearch.SearchRequest{\n  showRankingScoreDetails:    true,\n})"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.Index(\"movies\").Search(\"adventure\", &meilisearch.SearchRequest{\n  AttributesToSearchOn: []string{\"overview\"},\n})"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"INDEX_NAME\").Search(\"QUERY TERMS\", &meilisearch.SearchRequest{\n  Distinct: \"ATTRIBUTE_A\",\n})"
          },
          {
            "lang": "Go",
            "source": "filterableAttributes := []interface{}{\n  \"product_id\",\n  \"sku\",\n  \"url\",\n}\nclient.Index(\"products\").UpdateFilterableAttributes(&filterableAttributes)"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"products\").Search(\"white shirt\", &meilisearch.SearchRequest{\n  Distinct: \"sku\",\n})"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"INDEX_NAME\").Search(\"badman\", &meilisearch.SearchRequest{\n  RankingScoreThreshold: 0.2,\n})"
          },
          {
            "lang": "Go",
            "source": "client.index(\"INDEX_NAME\").Search(\"QUERY TEXT IN JAPANESE\", &meilisearch.SearchRequest{\n    Locales: []string{\"jpn\"}\n})"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"INDEX_NAME\").Search(\"\", &meilisearch.SearchRequest{\n  Hybrid: &meilisearch.SearchRequestHybrid{\n    Embedder: \"EMBEDDER_NAME\",\n  },\n  Media: map[string]any{\n    \"FIELD_A\": \"VALUE_A\",\n    \"FIELD_B\": map[string]any{\n      \"FIELD_C\": \"VALUE_B\",\n      \"FIELD_D\": \"VALUE_C\",\n    },\n  },\n});"
          },
          {
            "lang": "JS",
            "source": "client.getVersion()"
          },
          {
            "lang": "JS",
            "source": "client.index('jackets').updateDistinctAttribute('product_id')"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateSearchableAttributes([\n    'title',\n    'overview',\n    'genres',\n  ]\n)"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateDisplayedAttributes([\n    'title',\n    'overview',\n    'genres',\n    'release_date',\n  ]\n)"
          },
          {
            "lang": "JS",
            "source": "client.index('movie_ratings').search('Avengers', {\n  filter: 'release_date > 795484800'\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movie_ratings').search('Batman', {\n  filter: 'release_date > 795484800 AND (director = \"Tim Burton\" OR director = \"Christopher Nolan\")'\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movie_ratings').search('Planet of the Apes', {\n  filter: \"release_date > 1577884550 AND (NOT director = \\\"Tim Burton\\\")\"\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movie_ratings').search('thriller', {\n  filter: 'rating.users >= 90'\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').search('shifu')"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').search('shifu', {\n  offset: 1\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').search('shifu', {\n  limit: 2\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').search('', {\n  hitsPerPage: 15\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').search('', {\n  page: 2\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').search('shifu', {\n  attributesToRetrieve: ['overview', 'title']\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').search('shifu', {\n  attributesToCrop: ['overview'],\n  cropLength: 5\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').search('shifu', {\n  attributesToCrop: ['overview'],\n  cropMarker: '[]'\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').search('winter feast', {\n  attributesToHighlight: ['overview']\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').search('winter feast', {\n  attributesToHighlight: ['overview'],\n  highlightPreTag: '<span class=\"highlight\">',\n  highlightPostTag: '</span>'\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').search('winter feast', {\n  showMatchesPosition: true\n})"
          },
          {
            "lang": "JS",
            "source": "const movies = require('./movies.json')\nclient.index('movies').addDocuments(movies).then((res) => console.log(res))"
          },
          {
            "lang": "JS",
            "source": "// With npm:\n// npm install meilisearch\n\n// Or with yarn:\n// yarn add meilisearch\n\n// In your .js file:\n// With the `require` syntax:\nconst { MeiliSearch } = require('meilisearch')\nconst movies = require('./movies.json')\n// With the `import` syntax:\nimport { MeiliSearch } from 'meilisearch'\nimport movies from './movies.json'\n\nconst client = new MeiliSearch({\n  host: 'http://localhost:7700',\n  apiKey: 'aSampleMasterKey'\n})\nclient.index('movies').addDocuments(movies)\n  .then((res) => console.log(res))"
          },
          {
            "lang": "JS",
            "source": "client.tasks.getTask(0)"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').search('botman').then((res) => console.log(res))"
          },
          {
            "lang": "JS",
            "source": "const meteorites = require('./meteorites.json')\n\nclient.index('meteorites').addDocuments(meteorites)"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateRankingRules([\n  'exactness',\n  'words',\n  'typo',\n  'proximity',\n  'attribute',\n  'sort',\n  'release_date:asc',\n  'rank:desc'\n])"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateDisplayedAttributes([\n  'title',\n  'overview',\n  'poster'\n])"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateSearchableAttributes([\n  'title'\n])"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateStopWords(['the'])"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateSynonyms({\n  winnie: ['piglet'],\n  piglet: ['winnie']\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('meteorites').search('', { filter: 'mass < 200' })"
          },
          {
            "lang": "JS",
            "source": "client.index('meteorites').search('', { filter: '_geoRadius(46.9480, 7.4474, 210000)' })"
          },
          {
            "lang": "JS",
            "source": "client.index('meteorites').search('', { sort: ['_geoPoint(48.8583701, 2.2922926):asc'] })"
          },
          {
            "lang": "JS",
            "source": "client.index('meteorites').search('', {\n  sort: ['mass:asc'],\n  filter: 'mass < 200'\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('meteorites').updateSettings({\n  filterableAttributes: ['mass', '_geo'],\n  sortableAttributes: ['mass', '_geo']\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movies')\n  .search('thriller', {\n    filter: [['genres = Horror', 'genres = Mystery'], 'director = \"Jordan Peele\"']\n  })"
          },
          {
            "lang": "JS",
            "source": "client.index('movies')\n  .search('\"african american\" horror')"
          },
          {
            "lang": "JS",
            "source": "const client = new MeiliSearch({ host: 'http://localhost:7700', apiKey: 'masterKey' })\nclient.getKeys()"
          },
          {
            "lang": "JS",
            "source": "client.index('books').updateSortableAttributes([\n    'author',\n    'price'\n  ])"
          },
          {
            "lang": "JS",
            "source": "client.index('books').updateRankingRules([\n  'words',\n  'sort',\n  'typo',\n  'proximity',\n  'attribute',\n  'exactness'\n])"
          },
          {
            "lang": "JS",
            "source": "client.index('books').search('science fiction', {\n  'sort': ['rating.users:asc'],\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('books').search('science fiction', {\n  sort: ['price:asc'],\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('books').search('butler', {\n  sort: ['author:desc'],\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('books').search('science fiction', {\n  sort: ['price:asc'],\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('restaurants')\n.updateFilterableAttributes([\n  '_geo'\n])"
          },
          {
            "lang": "JS",
            "source": "client.index('restaurants').search('', {\n  filter: ['_geoRadius(45.472735, 9.184019, 2000)'],\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('restaurants').search('', {\n  filter: ['_geoRadius(45.472735, 9.184019, 2000) AND type = pizza'],\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('restaurants').search('', {\n  filter: ['_geoBoundingBox([45.494181, 9.214024], [45.449484, 9.179175])'],\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('restaurants').updateSortableAttributes([\n  '_geo'\n])"
          },
          {
            "lang": "JS",
            "source": "client.index('restaurants').search('', {\n  sort: ['_geoPoint(48.8561446, 2.2978204):asc'],\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('restaurants').search('', {\n  sort: ['_geoPoint(48.8561446, 2.2978204):asc', 'rating:desc'],\n})"
          },
          {
            "lang": "JS",
            "source": "const client = new MeiliSearch({ host: 'http://localhost:7700', apiKey: 'apiKey' })\nclient.index('patient_medical_records').search()"
          },
          {
            "lang": "JS",
            "source": "const client = new MeiliSearch({ host: 'http://localhost:7700', apiKey: 'masterKey' })\nclient.updateKey('74c9c733-3368-4738-bbe5-1d18a5fecb37', {\n  description: 'Default Search API Key'\n})"
          },
          {
            "lang": "JS",
            "source": "const client = new MeiliSearch({ host: 'http://localhost:7700', apiKey: 'masterKey' })\nclient.createKey({\n  description: 'Search patient records key',\n  actions: ['search'],\n  indexes: ['patient_medical_records'],\n  expiresAt: '2023-01-01T00:00:00Z'\n})"
          },
          {
            "lang": "JS",
            "source": "const client = new MeiliSearch({ host: 'http://localhost:7700', apiKey: 'masterKey' })\nclient.getKeys()"
          },
          {
            "lang": "JS",
            "source": "const client = new MeiliSearch({ host: 'http://localhost:7700', apiKey: 'masterKey' })\nclient.deleteKey('ac5cd97d-5a4b-4226-a868-2d0eb6d197ab')"
          },
          {
            "lang": "JS",
            "source": "client.createIndex('books', { primaryKey: 'reference_number' })"
          },
          {
            "lang": "JS",
            "source": "client.index('books').addDocuments([\n  {\n    reference_number: 287947,\n    title: 'Diary of a Wimpy Kid',\n    author: 'Jeff Kinney',\n    genres: ['comedy','humor'],\n    price: 5.00\n  }\n], { primaryKey: 'reference_number' })"
          },
          {
            "lang": "JS",
            "source": "client.updateIndex('books', {\n  primaryKey: 'title'\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateTypoTolerance({\n  enabled: false\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateTypoTolerance({\n  disableOnAttributes: ['title']\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateTypoTolerance({\n  disableOnWords: ['shrek']\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateTypoTolerance({\n  minWordSizeForTypos: {\n    oneTypo: 4,\n    twoTypos: 10\n  }\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateTypoTolerance({\n  disableOnNumbers: true\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateTypoTolerance({\n  minWordSizeForTypos: {\n      oneTypo: 4\n  }\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateSynonyms({\n  'great': ['fantastic'],\n  'fantastic': ['great']\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateFaceting({\n  maxValuesPerFacet: 2,\n  sortFacetValuesBy: {\n    '*': 'count'\n  }\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updatePagination({ maxTotalHits: 500 })"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').search('big fat liar', {\n  matchingStrategy: 'last'\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').search('big fat liar', {\n  matchingStrategy: 'all'\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').search('white shirt', {\n  matchingStrategy: 'frequency'\n})"
          },
          {
            "lang": "JS",
            "source": "const games = require('./games.json')\nclient.index('games').addDocuments(games).then((res) => console.log(res))"
          },
          {
            "lang": "JS",
            "source": "client.index('games').updateFilterableAttributes(['release_timestamp'])"
          },
          {
            "lang": "JS",
            "source": "client.index('games').search('', {\n  filter: 'release_timestamp >= 1514761200 AND release_timestamp < 1672527600'\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('games').updateSortableAttributes(['release_timestamp'])"
          },
          {
            "lang": "JS",
            "source": "client.index('games').search('', {\n  sort: ['release_timestamp:desc'],\n})"
          },
          {
            "lang": "JS",
            "source": "client.tasks.getTasks({ statuses: ['failed', 'canceled'] })"
          },
          {
            "lang": "JS",
            "source": "client.tasks.getTasks({\n  indexUids: ['movies'],\n  types: ['documentAdditionOrUpdate','documentDeletion'],\n  statuses: ['processing']\n})"
          },
          {
            "lang": "JS",
            "source": "client.multiSearch({\n  federation: {},\n  queries: [\n    {\n      indexUid: 'movies',\n      q: 'batman',\n    },\n    {\n      indexUid: 'comics',\n      q: 'batman',\n    },\n  ]\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movie_ratings').updateFilterableAttributes(['genres', 'rating', 'language'])"
          },
          {
            "lang": "JS",
            "source": "client.index('books').search('classic', { facets: ['genres', 'rating', 'language'] })"
          },
          {
            "lang": "JS",
            "source": "client.index('movie_ratings').search('Batman', { facets: ['genres', 'rating'] })"
          },
          {
            "lang": "JS",
            "source": "client.index('movies')\n  .updateFilterableAttributes([\n    'director',\n    'genres'\n  ])"
          },
          {
            "lang": "JS",
            "source": "client.index('books').updateFaceting({\n  sortFacetValuesBy: {\n    genres: 'count'\n  }\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('books').searchForFacetValues({\n  facetQuery: 'c',\n  facetName: 'genres'\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').search('dragon', {\n  showRankingScore: true\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').search('dragon', { showRankingScoreDetails: true })"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').search('adventure', {\n  attributesToSearchOn: ['overview']\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').search('-escape')"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').search('-\"escape\"')"
          },
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').search('QUERY TERMS', { distinct: 'ATTRIBUTE_A' })"
          },
          {
            "lang": "JS",
            "source": "client.index('products').updateFilterableAttributes(['product_id', 'sku', 'url'])"
          },
          {
            "lang": "JS",
            "source": "client.index('products').search('white shirt', { distinct: 'sku' })"
          },
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').search('badman', { rankingScoreThreshold: 0.2 })"
          },
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').search('QUERY TEXT IN JAPANESE', { locales: ['jpn'] })"
          },
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').search('kitchen utensils', {\n  hybrid: {\n    semanticRatio: 0.9,\n    embedder: 'EMBEDDER_NAME'\n  }\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').search('kitchen utensils', {\n  retrieveVectors: true,\n  hybrid: {\n    embedder: 'EMBEDDER_NAME'\n  }\n})"
          },
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').search('a futuristic movie', {\n  hybrid: {\n    embedder: 'EMBEDDER_NAME'\n  },\n  media: {\n    textAndPoster: {\n      text: 'a futuristic movie',\n      image: {\n        mime: 'image/jpeg',\n        data: 'base64EncodedImageData'\n      }\n    }\n  }\n})"
          },
          {
            "lang": "Java",
            "source": "client.getVersion();"
          },
          {
            "lang": "Java",
            "source": "client.index(\"jackets\").updateDistinctAttributeSettings(\"product_id\");"
          },
          {
            "lang": "Java",
            "source": "String[] attributes = {\"title\", \"overview\", \"genres\"}\nclient.index(\"movies\").updateSearchableAttributesSettings(attributes);"
          },
          {
            "lang": "Java",
            "source": "String[] attributes = {\"title\", \"overview\", \"genres\", \"release_date\"}\nclient.index(\"movies\").updateDisplayedAttributesSettings(attributes);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"Avengers\").filter(new String[] {\"release_date > \\\"795484800\\\"\"}).build();\nclient.index(\"movie_ratings\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"Batman\").filter(new String[] {\"release_date > 795484800 AND (director = \\\"Tim Burton\\\" OR director = \\\"Christopher Nolan\\\")\"}).build();\nclient.index(\"movie_ratings\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"Planet of the Apes\").filter(new String[] {\"release_date > 1577884550 AND (NOT director = \\\"Tim Burton\\\")\"}).build();\nclient.index(\"movie_ratings\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"thriller\").filter(new String[] {\"rating.users >= 90\"}).build();\nclient.index(\"movie_ratings\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").search(\"shifu\");"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"shifu\").offset(1).build();\nclient.index(\"movies\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"shifu\").limit(2).build();\nclient.index(\"movies\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"\").hitsPerPage(15).build();\nSearchResultPaginated searchResult = client.index(\"movies\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"\").page(15).build();\nSearchResultPaginated searchResult = client.index(\"movies\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"a\").attributesToRetrieve(new String[] {\"overview\", \"title\"}).build();\nclient.index(\"movies\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest =\n        SearchRequest.builder()\n                .q(\"shifu\")\n                .attributesToCrop(new String[] {\"overview\"})\n                .cropLength(5)\n                .build();\nclient.index(\"movies\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest =\n        SearchRequest.builder()\n                .q(\"shifu\")\n                .attributesToCrop(new String[] {\"overview\"})\n                .cropMarker(\"[]\")\n                .build();\nclient.index(\"movies\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest =\n  new SearchRequest(\"winter feast\").setAttributesToHighlight(new String[] {\"overview\"});\nclient.index(\"movies\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest =\n        SearchRequest.builder()\n                .q(\"winter feast\")\n                .attributesToHighlight(new String[] {\"overview\"})\n                .highlightPreTag(\"<span class=\\\"highlight\\\">\")\n                .highlightPostTag(\"</span>\")\n                .build();\nclient.index(\"movies\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"winter feast\").showMatchesPosition(true).build();\nSearchResultPaginated searchResult = client.index(\"movies\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "import com.meilisearch.sdk;\nimport org.json.JSONArray;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nPath fileName = Path.of(\"movies.json\");\nString moviesJson = Files.readString(fileName);\nClient client = new Client(new Config(\"http://localhost:7700\", \"masterKey\"));\nIndex index = client.index(\"movies\");\nindex.addDocuments(moviesJson);"
          },
          {
            "lang": "Java",
            "source": "// For Maven:\n// Add the following code to the `<dependencies>` section of your project:\n//\n// <dependency>\n//   <groupId>com.meilisearch.sdk</groupId>\n//   <artifactId>meilisearch-java</artifactId>\n//   <version>0.17.1</version>\n//   <type>pom</type>\n// </dependency>\n\n// For Gradle\n// Add the following line to the `dependencies` section of your `build.gradle`:\n//\n// implementation 'com.meilisearch.sdk:meilisearch-java:0.17.1'\n\n// In your .java file:\nimport com.meilisearch.sdk;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nPath fileName = Path.of(\"movies.json\");\nString moviesJson = Files.readString(fileName);\nClient client = new Client(new Config(\"http://localhost:7700\", \"aSampleMasterKey\"));\nIndex index = client.index(\"movies\");\nindex.addDocuments(moviesJson);"
          },
          {
            "lang": "Java",
            "source": "client.getTask(0);"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").search(\"botman\");"
          },
          {
            "lang": "Java",
            "source": "import com.meilisearch.sdk;\nimport org.json.JSONArray;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nPath fileName = Path.of(\"meteorites.json\");\nString meteoritesJson = Files.readString(fileName);\nClient client = new Client(new Config(\"http://localhost:7700\", \"masterKey\"));\n\nclient.index(\"meteorites\").addDocuments(meteoritesJson);"
          },
          {
            "lang": "Java",
            "source": "Settings settings = new Settings();\nsettings.setRankingRules(new String[]\n{\n  \"exactness\",\n  \"words\",\n  \"typo\",\n  \"proximity\",\n  \"attribute\",\n  \"sort\",\n  \"release_date:asc\",\n  \"rank:desc\"\n});\nclient.index(\"movies\").updateSettings(settings);"
          },
          {
            "lang": "Java",
            "source": "Settings settings = new Settings();\nsettings.setDisplayedAttributes(new String[]\n{\n      \"title\",\n      \"overview\",\n      \"poster\"\n});\nclient.index(\"movies\").updateSettings(settings);"
          },
          {
            "lang": "Java",
            "source": "Settings settings = new Settings();\nsettings.setSearchableAttributes(new String[]\n{\n  \"title\"\n});"
          },
          {
            "lang": "Java",
            "source": "Settings settings = new Settings();\nsettings.setStopWords(new String[]\n{\n  \"the\"\n});\nclient.index(\"movies\").updateSettings(settings);"
          },
          {
            "lang": "Java",
            "source": "Settings settings = new Settings();\nHashMap<String, String[]> synonyms = new HashMap<String, String[]>();\nsynonyms.put(\"winnie\", new String[] {\"piglet\"});\nsynonyms.put(\"piglet\", new String[] {\"winnie\"});\nsettings.setSynonyms(synonyms);\nclient.index(\"movies\").updateSettings(settings);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"\").filter(new String[] {\"mass < 200\"}).build();\nclient.index(\"meteorites\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"\").filter(new String[] {\"_geoRadius(46.9480, 7.4474, 210000)\"}).build();\nclient.index(\"meteorites\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"\").sort(new String[] {\"_geoPoint(48.8583701,2.2922926):asc\"}).build();\nclient.index(\"meteorites\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"\").filter(new String[] {\"mass < 200\"}).sort(new String[] {\"mass:asc\"}).build();\nclient.index(\"meteorites\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "Settings settings = new Settings();\nsettings.setFilterableAttributes(new String[] {\"mass\", \"_geo\"});\nsettings.setSortableAttributes(new String[] {\"mass\", \"_geo\"});\nclient.index(\"meteorites\").updateSettings(settings);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest =\n  SearchRequest.builder().q(\"thriller\").filterArray(new String[][] {\n    new String[] {\"genres = Horror\", \"genres = Mystery\"},\n    new String[] {\"director = \\\"Jordan Peele\\\"\"}}).build();\nclient.index(\"movies\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").search(\"\\\"african american\\\" horror\");"
          },
          {
            "lang": "Java",
            "source": "Client client = new Client(new Config(\"http://localhost:7700\", \"masterKey\"));\nclient.getKeys();"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").updateSortableAttributesSettings(new String[] {\"price\", \"author\"});"
          },
          {
            "lang": "Java",
            "source": "Settings settings = new Settings();\nsettings.setRankingRules(new String[]\n{\n  \"words\",\n  \"sort\",\n  \"typo\",\n  \"proximity\",\n  \"attribute\",\n  \"exactness\"\n});\nclient.index(\"books\").updateSettings(settings);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"science fiction\").sort(new String[] {\"rating.users:asc\"}).build();\nclient.index(\"books\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"science fiction\").sort(new String[] {\"price:asc\"}).build();\nclient.index(\"books\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"butler\").sort(new String[] {\"author:desc\"}).build();\nclient.index(\"books\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"science fiction\").sort(new String[] {\"price:asc\"}).build();\nclient.index(\"search_parameter_guide_sort_1\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "Settings settings = new Settings();\nsettings.setFilterableAttributes(new String[] {\"_geo\"});\nclient.index(\"restaurants\").updateSettings(settings);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"\").filter(new String[] {\"_geoRadius(45.472735, 9.184019, 2000)\"}).build();\nclient.index(\"restaurants\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"\").filter(new String[] {\"_geoRadius(45.472735, 9.184019, 2000) AND type = pizza\"}).build();\nclient.index(\"restaurants\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q()(\"\").filter(new String[] {\n    \"_geoBoundingBox([45.494181, 9.214024], [45.449484, 9.179175])\"\n  }).build();\nclient.index(\"restaurants\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "client.index(\"restaurants\").updateSortableAttributesSettings(new String[] {\"_geo\"});"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"\").sort(new String[] {\"_geoPoint(48.8561446,2.2978204):asc\"}).build();\nclient.index(\"restaurants\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q()(\"\").sort(new String[] {\n    \"_geoPoint(48.8561446,2.2978204):asc\",\n    \"rating:desc\",\n  }).build();\nclient.index(\"restaurants\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "Client client = new Client(new Config(\"http://localhost:7700\", \"apiKey\"));\nclient.index(\"patient_medical_records\").search();"
          },
          {
            "lang": "Java",
            "source": "Client client = new Client(new Config(\"http://localhost:7700\", \"masterKey\"));\nclient.updateKey(\"74c9c733-3368-4738-bbe5-1d18a5fecb37\", new KeyUpdate().setDescription(\"Default Search API Key\"));"
          },
          {
            "lang": "Java",
            "source": "Client client = new Client(new Config(\"http://localhost:7700\", \"masterKey\"));\n\nSimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\");\nDate dateParsed = format.parse(\"2023-01-01T00:00:00Z\");\n\nKey keyInfo = new Key();\n\nkeyInfo.setDescription(\"Search patient records key\");\nkeyInfo.setActions(new String[] {\"search\"});\nkeyInfo.setIndexes(new String[] {\"patient_medical_records\"});\nkeyInfo.setExpiresAt(dateParsed);\n\nclient.createKey(keyInfo);"
          },
          {
            "lang": "Java",
            "source": "Client client = new Client(new Config(\"http://localhost:7700\", \"masterKey\"));\nclient.getKeys();"
          },
          {
            "lang": "Java",
            "source": "Client client = new Client(new Config(\"http://localhost:7700\", \"masterKey\"));\nclient.deleteKey(\"c5cd97d-5a4b-4226-a868-2d0eb6d197ab\");"
          },
          {
            "lang": "Java",
            "source": "client.createIndex(\"books\", \"reference_number\");"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").addDocuments(\"[{\"\n  + \"\\\"reference_number\\\": 2879,\"\n  + \"\\\"title\\\": \\\"Diary of a Wimpy Kid\\\",\"\n  + \"\\\"author\\\": \\\"Jeff Kinney\\\",\"\n  + \"\\\"genres\\\": [\\\"comedy\\\", \\\"humor\\\"],\"\n  + \"\\\"price\\\": 5.00\"\n  + \"}]\"\n, \"reference_number\");"
          },
          {
            "lang": "Java",
            "source": "client.updateIndex(\"books\", \"title\");"
          },
          {
            "lang": "Java",
            "source": "TypoTolerance typoTolerance = new TypoTolerance();\ntypoTolerance.setEnabled(false);\nclient.index(\"movies\").updateTypoToleranceSettings(typoTolerance);"
          },
          {
            "lang": "Java",
            "source": "TypoTolerance typoTolerance = new TypoTolerance();\ntypoTolerance.setDisableOnAttributes(new String[] {\"title\"});\nclient.index(\"movies\").updateTypoToleranceSettings(typoTolerance);"
          },
          {
            "lang": "Java",
            "source": "TypoTolerance typoTolerance = new TypoTolerance();\ntypoTolerance.setDisableOnWords(new String[] {\"shrek\"});\nclient.index(\"movies\").updateTypoToleranceSettings(typoTolerance);"
          },
          {
            "lang": "Java",
            "source": "TypoTolerance typoTolerance = new TypoTolerance();\n  HashMap<String, Integer> minWordSizeTypos =\n        new HashMap<String, Integer>() {\n            {\n                put(\"oneTypo\", 4);\n                put(\"twoTypos\", 10);\n            }\n        };\ntypoTolerance.setMinWordSizeForTypos(minWordSizeTypos);\nclient.index(\"movies\").updateTypoToleranceSettings(typoTolerance);"
          },
          {
            "lang": "Java",
            "source": "TypoTolerance typoTolerance = new TypoTolerance();\ntypoTolerance.setDisableOnNumbers(true);\nclient.index(\"movies\").updateTypoToleranceSettings(typoTolerance);"
          },
          {
            "lang": "Java",
            "source": "HashMap<String, Integer> minWordSizeTypos =\nnew HashMap<String, Integer>() {\n  {\n    put(\"oneTypo\", 4);\n  }\n};\n\nTypoTolerance typoTolerance = new TypoTolerance();\ntypoTolerance.setMinWordSizeForTypos(minWordSizeTypos);\n\nclient.index(\"movies\").updateTypoToleranceSettings(typoTolerance);"
          },
          {
            "lang": "Java",
            "source": "HashMap<String, String[]> synonyms = new HashMap<String, String[]>();\nsynonyms.put(\"great\", new String[] {\"fantastic\"});\nsynonyms.put(\"fantastic\", new String[] {\"great\"});\n\nclient.index(\"movies\").updateSynonymsSettings(synonyms);"
          },
          {
            "lang": "Java",
            "source": "Faceting newFaceting = new Faceting();\nnewFaceting.setMaxValuesPerFacet(2);\nHashMap<String, FacetSortValue> facetSortValues = new HashMap<>();\nfacetSortValues.put(\"*\", FacetSortValue.COUNT);\nnewFaceting.setSortFacetValuesBy(facetSortValues);\nclient.index(\"movies\").updateFacetingSettings(newFaceting);"
          },
          {
            "lang": "Java",
            "source": "Pagination newPagination = new Pagination();\nnewPagination.setMaxTotalHits(500);\nclient.index(\"movies\").updatePaginationSettings(newPagination);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"big fat liar\").matchingStrategy(MatchingStrategy.LAST).build();\nclient.index(\"movies\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"big fat liar\").matchingStrategy(MatchingStrategy.ALL).build();\nclient.index(\"movies\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"white shirt\").matchingStrategy(MatchingStrategy.FREQUENCY).build();\nclient.index(\"movies\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "import com.meilisearch.sdk;\nimport org.json.JSONArray;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nPath fileName = Path.of(\"games.json\");\nString gamesJson = Files.readString(fileName);\nIndex index = client.index(\"games\");\nindex.addDocuments(gamesJson);"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").updateFilterableAttributesSettings(new String[] { \"release_timestamp\" });"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"\").filter(new String[] {\"release_timestamp >= 1514761200 AND release_timestamp < 1672527600\"}).build();\nclient.index(\"games\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "Settings settings = new Settings();\nsettings.setSortableAttributes(new String[] {\"release_timestamp\"});\nclient.index(\"games\").updateSettings(settings);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"\").sort(new String[] {\"release_timestamp:desc\"}).build();\nclient.index(\"games\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "TasksQuery query = new TasksQuery().setStatuses(new String[] {\"failed\", \"canceled\"});\nclient.getTasks(query);"
          },
          {
            "lang": "Java",
            "source": "TasksQuery query =\n        new TasksQuery()\n                .setStatuses(new String[] {\"processing\"})\n                .setTypes(new String[] {\"documentAdditionOrUpdate\", \"documentDeletion\"})\n                .setIndexUids(new String[] {\"movies\"});\n\nclient.getTasks(query);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"classic\").facets(new String[]\n{\n  \"genres\",\n  \"rating\",\n  \"language\"\n}).build();\nclient.index(\"books\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"Batman\").facets(new String[]\n{\n  \"genres\",\n  \"rating\"\n}).build();\nclient.index(\"movies\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").updateFilterableAttributesSettings(new String[]\n{\n  \"genres\",\n  \"director\"\n});"
          },
          {
            "lang": "Java",
            "source": "Faceting newFaceting = new Faceting();\nHashMap<String, FacetSortValue> facetSortValues = new HashMap<>();\nfacetSortValues.put(\"genres\", FacetSortValue.COUNT);\nnewFaceting.setSortFacetValuesBy(facetSortValues);\nclient.index(\"books\").updateFacetingSettings(newFaceting);"
          },
          {
            "lang": "Java",
            "source": "FacetSearchRequest fsr = FacetSearchRequest.builder().facetName(\"genres\").facetQuery(\"c\").build();\nclient.index(\"books\").facetSearch(fsr);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"dragon\").showRankingScore(true).build();\nclient.index(\"movies\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"dragon\").showRankingScoreDetails(true).build();\nclient.index(\"movies\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"adventure\").attributesToSearchOn(new String[] {\"overview\"});\nclient.index(\"movies\").searchRequest(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"QUERY TERMS\").distinct(\"ATTRIBUTE_A\").build();\nclient.index(\"INDEX_NAME\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "Settings settings = new Settings();\nsettings.setFilterableAttributes(new String[] {\"product_id\", \"SKU\", \"url\"});\nclient.index(\"products\").updateSettings(settings);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"white shirt\").distinct(\"sku\").build();\nclient.index(\"products\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"badman\").rankingScoreThreshold(0.2).build();\nclient.index(\"INDEX_NAME\").search(searchRequest);"
          },
          {
            "lang": "Java",
            "source": "SearchRequest searchRequest = SearchRequest.builder().q(\"QUERY TEXT IN JAPANESE\").locales(new String[]{\"jpn\"}).build();\nclient.index(\"INDEX_NAME\").search(searchRequest);"
          },
          {
            "lang": "PHP",
            "source": "$client->version();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('jackets')->updateDistinctAttribute('product_id');"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateSearchableAttributes([\n  'title',\n  'overview',\n  'genres'\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateDisplayedAttributes([\n  'title',\n  'overview',\n  'genres',\n  'release_date'\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movie_ratings')->search('Avengers', [\n  'filter' => 'release_date > 795484800'\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movie_ratings')->search('Batman', [\n  'filter' => 'release_date > 795484800 AND (director = \"Tim Burton\" OR director = \"Christopher Nolan\")'\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movie_ratings')->search('Planet of the Apes', [\n  'filter' => 'release_date > 1577884550 AND (NOT director = \"Tim Burton\")'\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movie_ratings')->search('thriller', [\n  'filter' => 'rating.users >= 90'\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->search('shifu');"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->search('shifu', ['offset' => 1]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->search('shifu', ['limit' => 2]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->search('', ['hitsPerPage' => 15]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->search('', ['page' => 2]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->search('shifu', [\n  'attributesToRetrieve' => ['overview', 'title']\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->search('shifu', [\n  'attributesToCrop' => ['overview'],\n  'cropLength' => 5\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->search('shifu', [\n  'attributesToCrop' => ['overview'],\n  'cropMarker' => '[]'\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->search('winter feast', [\n  'attributesToHighlight' => ['overview']\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->search('winter feast', [\n  'attributesToHighlight' => ['overview'],\n  'highlightPreTag' => '<span class=\"highlight\">',\n  'highlightPostTag' => '</span>'\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->search('winter feast', [\n  'attributesToHighlight' => ['overview'],\n  'showMatchesPosition' => true\n]);"
          },
          {
            "lang": "PHP",
            "source": "$moviesJson = file_get_contents('movies.json');\n$movies = json_decode($moviesJson);\n\n$client->index('movies')->addDocuments($movies);"
          },
          {
            "lang": "PHP",
            "source": "/**\n * Using `meilisearch-php` with the Guzzle HTTP client, in the command line:\n *   composer require meilisearch/meilisearch-php \\\n *     guzzlehttp/guzzle \\\n *     http-interop/http-factory-guzzle:^1.0\n */\n\n/**\n * In your PHP file:\n */\n<?php\n\nrequire_once __DIR__ . '/vendor/autoload.php';\n\nuse Meilisearch\\Client;\n\n$client = new Client('http://localhost:7700', 'aSampleMasterKey');\n\n$movies_json = file_get_contents('movies.json');\n$movies = json_decode($movies_json);\n\n$client->index('movies')->addDocuments($movies);"
          },
          {
            "lang": "PHP",
            "source": "$client->getTask(0);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->search('botman');"
          },
          {
            "lang": "PHP",
            "source": "$client = new Client('http://localhost:7700');\n\n$meteorites_json = file_get_contents('meteorites.json');\n$meteorites = json_decode($meteorites_json);\n\n$client->index('meteorites')->addDocuments($meteorites);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateRankingRules([\n  'exactness',\n  'words',\n  'typo',\n  'proximity',\n  'attribute',\n  'sort',\n  'release_date:asc',\n  'rank:desc'\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateDisplayedAttributes([\n  'title',\n  'overview',\n  'poster'\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateSearchableAttributes(['title']);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateStopWords(['the']);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateSynonyms([\n  'winnie' => ['piglet'],\n  'piglet' => ['winnie']\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('meteorites')->search('', [\n  'filter' => 'mass < 200'\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('meteorites')->search('', [\n  'filter' => '_geoRadius(46.9480, 7.4474, 210000)'\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('meteorites')->search('', [\n  'sort' => ['_geoPoint(48.8583701,2.2922926):asc']\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('meteorites')->search('', [\n  'filter' => 'mass < 200',\n  'sort' => ['mass:asc']\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('meteorites')->updateSettings([\n  'filterableAttributes' => [\n    'mass',\n    '_geo'\n  ],\n  'sortableAttributes' => [\n    'mass',\n    '_geo'\n  ]\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->search('thriller', [\n  'filter' => [['genres = Horror', 'genres = Mystery'], 'director = \"Jordan Peele\"']\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->search('\"african american\" horror');"
          },
          {
            "lang": "PHP",
            "source": "$client = new Client('http://localhost:7700', 'masterKey');\n$client->getKeys();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->updateSortableAttributes([\n  'author',\n  'price'\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->updateRankingRules([\n  'words',\n  'sort',\n  'typo',\n  'proximity',\n  'attribute',\n  'exactness'\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->search('science fiction', ['sort' => ['rating.users:asc']]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->search('science fiction', ['sort' => ['price:asc']]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->search('butler', ['sort' => ['author:desc']]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->search('science fiction', ['sort' => ['price:asc']]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('restaurants')->updateFilterableAttributes([\n  '_geo'\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('restaurants')->search('', [\n  'filter' => '_geoRadius(45.472735, 9.184019, 2000)'\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('restaurants')->search('', [\n  'filter' => '_geoRadius(45.472735, 9.184019, 2000) AND type = pizza'\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('restaurants')->search('', [\n  'filter' => '_geoBoundingBox([45.494181, 9.214024], [45.449484, 9.179175])'\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('restaurants')->updateSortableAttributes([\n  '_geo'\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('restaurants')->search('', [\n  'sort' => ['_geoPoint(48.8561446,2.2978204):asc']\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('restaurants')->search('', [\n  'sort' => ['_geoPoint(48.8561446,2.2978204):asc', 'rating:desc']\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client = new Client('http://localhost:7700', 'masterKey');\n$client->index('patient_medical_records')->search();"
          },
          {
            "lang": "PHP",
            "source": "$client = new Client('http://localhost:7700', 'masterKey');\n$client->updateKey('74c9c733-3368-4738-bbe5-1d18a5fecb37',\n  ['description' => 'Default Search API Key']\n);"
          },
          {
            "lang": "PHP",
            "source": "$client = new Client('http://localhost:7700', 'masterKey');\n$client->createKey([\n  'description' => 'Search patient records key',\n  'actions' => ['search'],\n  'indexes' => ['patient_medical_records'],\n  'expiresAt' => '2023-01-01T00:00:00Z',\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client = new Client('http://localhost:7700', 'masterKey');\n$client->getKeys();"
          },
          {
            "lang": "PHP",
            "source": "$client = new Client('http://localhost:7700', 'masterKey');\n$client->deleteKey('ac5cd97d-5a4b-4226-a868-2d0eb6d197ab');"
          },
          {
            "lang": "PHP",
            "source": "$client->createIndex('books', ['primaryKey' => 'reference_number']);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->addDocuments([\n  [\n    'reference_number' => 287947,\n    'title' => 'Diary of a Wimpy Kid',\n    'author' => 'Jeff Kinney',\n    'genres' => ['comedy', 'humor'],\n    'price' => 5.00\n  ]\n], 'reference_number');"
          },
          {
            "lang": "PHP",
            "source": "$client->updateIndex('books', ['primaryKey' => 'title']);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateTypoTolerance([\n  'enabled' => false\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateTypoTolerance([\n  'disableOnAttributes' => ['title']\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateTypoTolerance([\n  'disableOnWords' => ['shrek']\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateTypoTolerance([\n  'minWordSizeForTypos' => [\n    'oneTypo' => 4,\n    'twoTypos' => 10\n  ]\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateTypoTolerance([\n  'disableOnNumbers' => true\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->updateTypoTolerance([\n  'minWordSizeForTypos' => [\n    'oneTypo' => 4\n  ]\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateSynonyms([\n  'great' => ['fantastic'],\n  'fantastic' => ['great'],\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')\n  ->updateFaceting([\n    'maxValuesPerFacet' => 2,\n    'sortFacetValuesBy' => ['*' => 'count']\n  ]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updatePagination(['maxTotalHits' => 500]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->search('big fat liar', ['matchingStrategy' => 'last']);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->search('big fat liar', ['matchingStrategy' => 'all']);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->search('white shirt', ['matchingStrategy' => 'frequency']);"
          },
          {
            "lang": "PHP",
            "source": "$gamesJson = file_get_contents('games.json');\n$games = json_decode($gamesJson);\n\n$client->index('games')->addDocuments($games);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('games')->updateFilterableAttributes(['release_timestamp']);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('games')->search('', [\n  'filter' => ['release_timestamp >= 1514761200 AND release_timestamp < 1672527600']\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('games')->updateSortableAttributes(['release_timestamp']);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('games')->search('', ['sort' => ['release_timestamp:desc']]);"
          },
          {
            "lang": "PHP",
            "source": "$client->getTasks((new TasksQuery())->setStatuses(['failed', 'canceled']));"
          },
          {
            "lang": "PHP",
            "source": "$client->getTasks(\n  (new TasksQuery())\n    ->setStatuses(['processing'])\n    ->setUids(['movies'])\n    ->setTypes(['documentAdditionOrUpdate', 'documentDeletion'])\n);"
          },
          {
            "lang": "PHP",
            "source": "$client->multiSearch([\n    (new SearchQuery())\n      ->setIndexUid('movies'))\n      ->setQuery('batman'),\n    (new SearchQuery())\n      ->setIndexUid('comics')\n      ->setQuery('batman'),\n  ],\n  (new MultiSearchFederation())\n);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movie_ratings')->updateFilterableAttributes(['genres', 'rating', 'language']);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->search('classic', [\n  'facets' => ['genres', 'rating', 'language']\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movie_ratings')->search('Batman', [\n  'facets' => ['genres', 'rating']\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateFilterableAttributes(['director', 'genres']);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->updateFaceting(['sortFacetValuesBy' => ['genres' => 'count']]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->facetSearch(\n  (new FacetSearchQuery())\n      ->setFacetQuery('c')\n      ->setFacetName('genres')\n);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->search('dragon', [\n  'showRankingScore' => true\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->search('dragon', [\n  'showRankingScoreDetails' => true\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->search('adventure', [\n  'attributesToSearchOn' => ['overview']\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->search('-escape');"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->search('-\"escape\"');"
          },
          {
            "lang": "PHP",
            "source": "$client->index('INDEX_NAME')->search('QUERY TERMS', [\n  'distinct' => 'ATTRIBUTE_A'\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('products')->updateFilterableAttributes(['product_id', 'sku', 'url']);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('products')->search('white shirt', [\n  'distinct' => 'sku'\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('INDEX_NAME')->search('badman', [\n  'rankingScoreThreshold' => 0.2\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('INDEX_NAME')->search('QUERY TEXT IN JAPANESE', [\n  'locales' => ['jpn']\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('INDEX_NAME')->search('kitchen utensils', [\n  'hybrid' => [\n    'semanticRatio' => 0.9,\n    'embedder' => 'EMBEDDER_NAME'\n  ]\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('INDEX_NAME')->search('kitchen utensils', [\n  'retrieveVectors' => true,\n  'hybrid' => [\n    'embedder': 'EMBEDDER_NAME'\n  ]\n]);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('INDEX_NAME')->search('a futuristic movie', [\n  'hybrid' => [\n    'embedder' => 'EMBEDDER_NAME'\n  ],\n  'media' => [\n    'textAndPoster' => [\n      'text' => 'a futuristic movie',\n      'image' => [\n        'mime' => 'image/jpeg',\n        'data' => 'base64EncodedImageData'\n      ]\n    ]\n  ]\n]);"
          },
          {
            "lang": "Python",
            "source": "client.get_version()"
          },
          {
            "lang": "Python",
            "source": "client.index('jackets').update_distinct_attribute('product_id')"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_searchable_attributes([\n    'title',\n    'overview',\n    'genres'\n])"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_displayed_attributes([\n    'title',\n    'overview',\n    'genres',\n    'release_date'\n])"
          },
          {
            "lang": "Python",
            "source": "client.index('movie_ratings').search('Avengers', {\n  'filter': 'release_date > 795484800'\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('movie_ratings').search('Batman', {\n  'filter': 'release_date > 795484800 AND (director = \"Tim Burton\" OR director = \"Christopher Nolan\")'\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('movie_ratings').search('Planet of the Apes', {\n  'filter': 'release_date > 1577884550 AND (NOT director = \"Tim Burton\"))'\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('movie_ratings').search('thriller', {\n  'filter': 'rating.users >= 90'\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').search('shifu')"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').search('shifu', {\n  'offset': 1\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').search('shifu', {\n  'limit': 2\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').search('', {'hitsPerPage': 15})"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').search('', {'page': 2})"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').search('shifu', {\n  'attributesToRetrieve': ['overview', 'title']\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').search('shifu', {\n  'attributesToCrop': ['overview'],\n  'cropLength': 5\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').search('shifu', {\n  'attributesToCrop': ['overview'],\n  'cropMarker': '[]'\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').search('winter feast', {\n  'attributesToHighlight': ['overview']\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').search('winter feast', {\n  'attributesToHighlight': ['overview'],\n  'highlightPreTag': '<span class=\"highlight\">',\n  'highlightPostTag': '</span>'\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').search('winter feast', {\n  'showMatchesPosition': True\n})"
          },
          {
            "lang": "Python",
            "source": "import json\n\njson_file = open('movies.json', encoding='utf-8')\nmovies = json.load(json_file)\nclient.index('movies').add_documents(movies)"
          },
          {
            "lang": "Python",
            "source": "# In the command line:\n# pip3 install meilisearch\n\n# In your .py file:\nimport meilisearch\nimport json\n\nclient = meilisearch.Client('http://localhost:7700', 'aSampleMasterKey')\n\njson_file = open('movies.json', encoding='utf-8')\nmovies = json.load(json_file)\nclient.index('movies').add_documents(movies)"
          },
          {
            "lang": "Python",
            "source": "client.get_task(0)"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').search('botman')"
          },
          {
            "lang": "Python",
            "source": "import json\n\njson_file = open('meteorites.json', encoding='utf-8')\nmeteorites = json.load(json_file)\nclient.index('meteorites').add_documents(meteorites)"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_ranking_rules([\n    'exactness',\n    'words',\n    'typo',\n    'proximity',\n    'attribute',\n    'sort',\n    'release_date:asc',\n    'rank:desc'\n])"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_displayed_attributes([\n    'title',\n    'overview',\n    'poster'\n])"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_searchable_attributes([\n    'title'\n])"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_stop_words(['the'])"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_synonyms({\n  'winnie': ['piglet'],\n  'piglet': ['winnie']\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('meteorites').search('', {\n  'filter': 'mass < 200'\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('meteorites').search('', {\n  'filter': '_geoRadius(46.9480, 7.4474, 210000)'\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('meteorites').search('', {\n  'sort': ['_geoPoint(48.8583701,2.2922926):asc']\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('meteorites').search('', {\n  'filter': 'mass < 200',\n  'sort': ['mass:asc']\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('meteorites').update_settings({\n  'filterableAttributes': [\n      'mass',\n      '_geo'\n  ],\n  'sortableAttributes': [\n      'mass',\n      '_geo'\n  ]\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').search('thriller', {\n  'filter': [['genres = Horror', 'genres = Mystery'], 'director = \"Jordan Peele\"']\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').search('\"african american\" horror')"
          },
          {
            "lang": "Python",
            "source": "client = Client('http://localhost:7700', 'masterKey')\nclient.get_keys()"
          },
          {
            "lang": "Python",
            "source": "client.index('books').update_sortable_attributes([\n  'author',\n  'price'\n])"
          },
          {
            "lang": "Python",
            "source": "client.index('books').update_ranking_rules([\n    'words',\n    'sort',\n    'typo',\n    'proximity',\n    'attribute',\n    'exactness'\n])"
          },
          {
            "lang": "Python",
            "source": "client.index('books').search('science fiction', {\n  'sort': ['rating.users:asc']\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('books').search('science fiction', {\n  'sort': ['price:asc']\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('books').search('butler', {\n  'sort': ['author:desc']\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('books').search('science fiction', {\n  'sort': ['price:asc']\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('restaurants').update_filterable_attributes([\n  '_geo'\n])"
          },
          {
            "lang": "Python",
            "source": "client.index('restaurants').search('', {\n  'filter': '_geoRadius(45.472735, 9.184019, 2000)'\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('restaurants').search('', {\n  'filter': '_geoRadius(45.472735, 9.184019, 2000) AND type = pizza'\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('restaurants').search('Batman', {\n  'filter': '_geoBoundingBox([45.494181, 9.214024], [45.449484, 9.179175])'\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('restaurants').update_sortable_attributes([\n  '_geo'\n])"
          },
          {
            "lang": "Python",
            "source": "client.index('restaurants').search('', {\n  'sort': ['_geoPoint(48.8561446,2.2978204):asc']\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('restaurants').search('', {\n  'sort': ['_geoPoint(48.8561446,2.2978204):asc', 'rating:desc']\n})"
          },
          {
            "lang": "Python",
            "source": "client = Client('http://localhost:7700', 'apiKey')\nclient.index('patient_medical_records').search()"
          },
          {
            "lang": "Python",
            "source": "client = Client('http://localhost:7700', 'masterKey')\nclient.update_key(key_or_uid='74c9c733-3368-4738-bbe5-1d18a5fecb37', options={\n  'description': 'Default Search API Key'\n})"
          },
          {
            "lang": "Python",
            "source": "client = Client('http://localhost:7700', 'masterKey')\n  client.create_key(options={\n  'description': 'Search patient records key',\n  'actions': ['search'],\n  'indexes': ['patient_medical_records'],\n  'expiresAt': '2023-01-01T00:00:00Z'\n})"
          },
          {
            "lang": "Python",
            "source": "client = Client('http://localhost:7700', 'masterKey')\nclient.get_keys()"
          },
          {
            "lang": "Python",
            "source": "client = Client('http://localhost:7700', 'masterKey')\nclient.delete_key('ac5cd97d-5a4b-4226-a868-2d0eb6d197ab')"
          },
          {
            "lang": "Python",
            "source": "client.create_index('books', {'primaryKey': 'reference_number'})"
          },
          {
            "lang": "Python",
            "source": "client.index('books').add_documents([{\n  'reference_number': 287947,\n  'title': 'Diary of a Wimpy Kid',\n  'author': 'Jeff Kinney',\n  'genres': ['comedy', 'humor'],\n  'price': 5.00\n}], 'reference_number')"
          },
          {
            "lang": "Python",
            "source": "client.index('books').update(primary_key='title')"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_typo_tolerance({\n  'enabled': False\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_typo_tolerance({\n  'disableOnAttributes': ['title']\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_typo_tolerance({\n  'disableOnWords': ['shrek']\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_typo_tolerance({\n  'minWordSizeForTypos': {\n    'oneTypo': 4,\n    'twoTypos': 10\n  }\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_typo_tolerance({\n  'disableOnNumbers': True\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_typo_tolerance({\n  'minWordSizeForTypos': {\n    'oneTypo': 4\n  }\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_synonyms({\n  'great': ['fantastic'],\n  'fantastic': ['great']\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_faceting_settings({\n  'maxValuesPerFacet': 2,\n  'sortFacetValuesBy': {\n    '*': 'count'\n  }\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_pagination_settings({'maxTotalHits': 500})"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').search('big fat liar', {\n  'matchingStrategy': 'last'\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').search('big fat liar', {\n  'matchingStrategy': 'all'\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').search('big fat liar', {\n  'matchingStrategy': 'frequency'\n})"
          },
          {
            "lang": "Python",
            "source": "import json\n\njson_file = open('./games.json', encoding='utf-8')\ngames = json.load(json_file)\nclient.index('games').add_documents(games)"
          },
          {
            "lang": "Python",
            "source": "client.index('games').update_filterable_attributes(['release_timestamp'])"
          },
          {
            "lang": "Python",
            "source": "client.index('games').search('', {\n  'filter': 'release_timestamp >= 1514761200 AND release_timestamp < 1672527600'\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('games').update_sortable_attributes(['release_timestamp'])"
          },
          {
            "lang": "Python",
            "source": "client.index('games').search('', {\n  'sort': ['release_timestamp:desc']\n})"
          },
          {
            "lang": "Python",
            "source": "client.get_tasks({'statuses': ['failed', 'canceled']})"
          },
          {
            "lang": "Python",
            "source": "client.get_tasks(\n  {\n      'indexUids': 'movies',\n      'types': ['documentAdditionOrUpdate', 'documentDeletion'],\n      'statuses': ['processing'],\n  }\n)"
          },
          {
            "lang": "Python",
            "source": "client.multi_search(\n  [{\"indexUid\": \"movies\", \"q\": \"batman\"}, {\"indexUid\": \"comics\", \"q\": \"batman\"}],\n  {}\n)"
          },
          {
            "lang": "Python",
            "source": "client.index('movie_ratings').update_filterable_attributes([\n  'genres',\n  'director',\n  'language'\n])"
          },
          {
            "lang": "Python",
            "source": "client.index('books').search('classic', {\n  'facets': ['genres', 'rating', 'language']\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('movie_ratings').search('Batman', {\n  'facets': ['genres', 'rating']\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_filterable_attributes([\n    'director',\n    'genres',\n])"
          },
          {
            "lang": "Python",
            "source": "client.index('books').update_faceting_settings({ 'sortFacetValuesBy': { 'genres': 'count' } })"
          },
          {
            "lang": "Python",
            "source": "client.index('books').facet_search('genres', 'c')"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').search('dragon', {\n  'showRankingScore': True\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').search('dragon', {\n  'showRankingScoreDetails': True\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').search('adventure', {\n  'attributesToSearchOn': ['overview']\n})"
          },
          {
            "lang": "Python",
            "source": "client.index('INDEX_NAME').search('QUERY_TERMS', { distinct: 'ATTRIBUTE_A' })"
          },
          {
            "lang": "Python",
            "source": "client.index('products').update_filterable_attributes(['product_id', 'sku', 'url'])"
          },
          {
            "lang": "Python",
            "source": "client.index('products').search('white shirt', { distinct: 'sku' })"
          },
          {
            "lang": "Python",
            "source": "client.index('INDEX_NAME').search('badman', { 'rankingScoreThreshold': 0.2 })"
          },
          {
            "lang": "Python",
            "source": "client.index('INDEX_NAME').search('', { 'locales': ['jpn'] })"
          },
          {
            "lang": "Ruby",
            "source": "client.version"
          },
          {
            "lang": "Ruby",
            "source": "client.index('jackets').update_distinct_attribute('product_id')"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_searchable_attributes([\n  'title',\n  'overview',\n  'genres'\n])"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_settings({\n  displayed_attributes: [\n    'title',\n    'overview',\n    'genres',\n    'release_date'\n  ]\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movie_ratings').search('Avengers', { filter: 'release_date > 795484800' })"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movie_ratings').search('Batman', {\n  filter: 'release_date > 795484800 AND (director = \"Tim Burton\" OR director = \"Christopher Nolan\")'\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movie_ratings').search('Planet of the Apes', {\n  filter: \"release_date > 1577884550 AND (NOT director = \\\"Tim Burton\\\")\"\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies_ratings').search('thriller', {\n  filter: 'rating.users >= 90'\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').search('shifu')"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').search('shifu', {\n  offset: 1\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').search('shifu', {\n  limit: 2\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').search('', hits_per_page: 15)"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').search('', page: 2)"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').search('shifu', {\n  attributes_to_retrieve: ['overview', 'title']\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').search('shifu', {\n  attributes_to_crop: ['overview'],\n  crop_length: 5\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').search('shifu', {\n  attributes_to_crop: ['overview'],\n  crop_marker: '[]'\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').search('winter feast', {\n  attributes_to_highlight: ['overview']\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').search('winter feast', {\n  attributes_to_highlight: ['overview'],\n  highlight_pre_tag: '<span class=\"highlight\">',\n  highlight_post_tag: '</span>'\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').search('winter feast', {\n  show_matches_position: true\n})"
          },
          {
            "lang": "Ruby",
            "source": "require 'json'\n\nmovies_json = File.read('movies.json')\nmovies = JSON.parse(movies_json)\nclient.index('movies').add_documents(movies)"
          },
          {
            "lang": "Ruby",
            "source": "# In the command line:\n# bundle add meilisearch\n\n# In your .rb file:\nrequire 'json'\nrequire 'meilisearch'\n\nclient = MeiliSearch::Client.new('http://localhost:7700', 'aSampleMasterKey')\n\nmovies_json = File.read('movies.json')\nmovies = JSON.parse(movies_json)\n\nclient.index('movies').add_documents(movies)"
          },
          {
            "lang": "Ruby",
            "source": "client.task(0)"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').search('botman')"
          },
          {
            "lang": "Ruby",
            "source": "file = File.read('meteorites.json')\njson = JSON.parse(file)\n\nclient.index('meteorites').add_documents(json)"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_ranking_rules([\n  'exactness',\n  'words',\n  'typo',\n  'proximity',\n  'attribute',\n  'sort',\n  'release_date:asc',\n  'rank:desc'\n])"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_displayed_attributes([\n  'title',\n  'overview',\n  'poster'\n])"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_searchable_attributes([\n  'title'\n])"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_stop_words(['the'])"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_synonyms({\n  winnie: ['piglet'],\n  piglet: ['winnie']\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('meteorites').search('', { filter: 'mass < 200' })"
          },
          {
            "lang": "Ruby",
            "source": "client.index('meteorites').search('', { filter: '_geoRadius(46.9480, 7.4474, 210000)' })"
          },
          {
            "lang": "Ruby",
            "source": "client.index('meteorites').search('', { sort: ['_geoPoint(48.8583701, 2.2922926):asc'] })"
          },
          {
            "lang": "Ruby",
            "source": "client.index('meteorites').search('', {\n  sort: ['mass:asc'],\n  filter: 'mass < 200'\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('meteorites').update_settings({\n  filterable_attributes: ['mass', '_geo'],\n  sortable_attributes: ['mass', '_geo']\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').search('thriller', {\n  filter: [['genres = Horror', 'genres = Mystery'], 'director = \"Jordan Peele\"']\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').search('\"african american\" horror')"
          },
          {
            "lang": "Ruby",
            "source": "client = MeiliSearch::Client.new('http://localhost:7700', 'masterKey')\nclient.keys"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').update_sortable_attributes(['author', 'price'])"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').update_ranking_rules([\n  'words',\n  'sort',\n  'typo',\n  'proximity',\n  'attribute',\n  'exactness'\n])"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').search('science fiction', { sort: ['rating.users:asc'] })"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').search('science fiction', { sort: ['price:asc'] })"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').search('butler', { sort: ['author:desc'] })"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').search('science fiction', { sort: ['price:asc'] })"
          },
          {
            "lang": "Ruby",
            "source": "client.index('restaurants').update_filterable_attributes(['_geo'])"
          },
          {
            "lang": "Ruby",
            "source": "client.index('restaurants').search('', { filter: '_geoRadius(45.472735, 9.184019, 2000)' })"
          },
          {
            "lang": "Ruby",
            "source": "client.index('restaurants').search('', { filter: '_geoRadius(45.472735, 9.184019, 2000) AND type = pizza' })"
          },
          {
            "lang": "Ruby",
            "source": "client.index('restaurants').search('', { filter: ['_geoBoundingBox([45.494181, 9.214024], [45.449484, 9.179175])'] })"
          },
          {
            "lang": "Ruby",
            "source": "client.index('restaurants').update_sortable_attributes(['_geo'])"
          },
          {
            "lang": "Ruby",
            "source": "client.index('restaurants').search('', { sort: ['_geoPoint(48.8561446, 2.2978204):asc'] })"
          },
          {
            "lang": "Ruby",
            "source": "client.index('restaurants').search('', { sort: ['_geoPoint(48.8561446, 2.2978204):asc', 'rating:desc'] })"
          },
          {
            "lang": "Ruby",
            "source": "client = MeiliSearch::Client.new('http://localhost:7700', 'apiKey')\nclient.index('patient_medical_records').search"
          },
          {
            "lang": "Ruby",
            "source": "client = MeiliSearch::Client.new('http://localhost:7700', 'masterKey')\nclient.update_key('74c9c733-3368-4738-bbe5-1d18a5fecb37', description: 'Default Search API Key')"
          },
          {
            "lang": "Ruby",
            "source": "client = MeiliSearch::Client.new('http://localhost:7700', 'masterKey')\nclient.create_key(\n  description: 'Search patient records key',\n  actions: ['search'],\n  indexes: ['patient_medical_records'],\n  expires_at: '2023-01-01T00:00:00Z'\n)"
          },
          {
            "lang": "Ruby",
            "source": "client = MeiliSearch::Client.new('http://localhost:7700', 'masterKey')\nclient.keys"
          },
          {
            "lang": "Ruby",
            "source": "client = MeiliSearch::Client.new('http://localhost:7700', 'masterKey')\nclient.delete_key('ac5cd97d-5a4b-4226-a868-2d0eb6d197ab')"
          },
          {
            "lang": "Ruby",
            "source": "client.create_index('books', primary_key: 'reference_number')"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').add_documents([\n  {\n    reference_number: 287947,\n    title: 'Diary of a Wimpy Kid',\n    author: 'Jeff Kinney',\n    genres: ['comedy', 'humor'],\n    price: 5.00\n  }\n], 'reference_number')"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').update(primary_key: 'title')"
          },
          {
            "lang": "Ruby",
            "source": "index('books').update_typo_tolerance({ enabled: false })"
          },
          {
            "lang": "Ruby",
            "source": "index('books').update_typo_tolerance({ disable_on_attributes: ['title'] })"
          },
          {
            "lang": "Ruby",
            "source": "index('books').update_typo_tolerance({ disable_on_words: ['shrek'] })"
          },
          {
            "lang": "Ruby",
            "source": "index('books').update_typo_tolerance({\n  min_word_size_for_typos: {\n    one_typo: 4,\n    two_typos: 10\n  }\n})"
          },
          {
            "lang": "Ruby",
            "source": "index('books').update_typo_tolerance({ disable_on_numbers: true })"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_typo_tolerance({ min_word_size_for_typos: { one_typo: 4 } })"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_synonyms({\n  great: ['fantastic'],\n  fantastic: ['great']\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_faceting({\n  max_values_per_facet: 2,\n  sort_facet_values_by: {\n    genres: 'count'\n  }\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_pagination(max_total_hits: 500)"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').search('big fat liar', {\n  matching_strategy: 'last'\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').search('big fat liar', {\n  matching_strategy: 'all'\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').search('white shirt', {\n  matching_strategy: 'frequency'\n})"
          },
          {
            "lang": "Ruby",
            "source": "require 'json'\n\ngames = JSON.parse(File.read('games.json'))\nclient.index('games').add_documents(games)"
          },
          {
            "lang": "Ruby",
            "source": "client.index('games').update_filterable_attributes(['release_timestamp'])"
          },
          {
            "lang": "Ruby",
            "source": "client.index('games').search('', {\n  filter: 'release_timestamp >= 1514761200 AND release_timestamp < 1672527600'\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('games').update_sortable_attributes(['release_timestamp'])"
          },
          {
            "lang": "Ruby",
            "source": "client.index('games').search('', sort: ['release_timestamp:desc'])"
          },
          {
            "lang": "Ruby",
            "source": "client.get_tasks(statuses: ['failed', 'canceled'])"
          },
          {
            "lang": "Ruby",
            "source": "client.get_tasks(index_uids: ['movies'], types: ['documentAdditionOrUpdate', 'documentDeletion'], statuses: ['processing'])"
          },
          {
            "lang": "Ruby",
            "source": "client.multi_search(\n  queries: [{ index_uid: 'movies', q: 'batman' }, { index_uid: 'comics', q: 'batman' }],\n  federation: {}\n)"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movie_ratings').update_filterable_attributes(['genres', 'rating', 'language'])"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').search('classic', {\n  facets: ['genres', 'rating', 'language']\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movie_ratings').search('Batman', {\n  facets: ['genres', 'rating']\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_filterable_attributes([\n  'director',\n  'genres'\n])"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').update_faceting(\n  sort_facet_values_by: {\n    genres: 'count'\n  }\n)"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').facet_search('genres', 'c')"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').search('dragon', {\n  show_ranking_score: true\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').search('dragon', {\n  show_ranking_score_details: true\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').search('adventure', {\n  attributes_to_search_on: ['overview']\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_NAME').search('QUERY TERMS', {\n  distinct: 'ATTRIBUTE_A'\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('products').update_filterable_attributes([\n  'product_id',\n  'sku',\n  'url'\n])"
          },
          {
            "lang": "Ruby",
            "source": "client.index('products').search('white shirt', {\n  distinct: 'sku'\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_NAME').search('badman', {\n  rankingScoreThreshold: 0.2\n})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_NAME').search('', { locales: ['jpn'] })"
          },
          {
            "lang": "Rust",
            "source": "let version: Version = client\n  .get_version()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"jackets\")\n  .set_distinct_attribute(\"product_id\")\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let searchable_attributes = [\n  \"title\",\n  \"overview\",\n  \"genres\"\n];\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_searchable_attributes(&searchable_attributes)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let displayed_attributes = [\n  \"title\",\n  \"overview\",\n  \"genres\",\n  \"release_date\"\n];\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_displayed_attributes(&displayed_attributes)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Movie> = client\n  .index(\"movie_ratings\")\n  .search()\n  .with_query(\"Avengers\")\n  .with_filter(\"release_date > 795484800\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Movie> = client\n  .index(\"movie_ratings\")\n  .search()\n  .with_query(\"Batman\")\n  .with_filter(r#\"release_date > 795484800 AND (director = \"Tim Burton\" OR director = \"Christopher Nolan\")\"#)\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Movie> = client\n  .index(\"movie_ratings\")\n  .search()\n  .with_query(\"Planet of the Apes\")\n  .with_filter(r#\"release_date > 1577884550 AND (NOT director = \"Tim Burton\")\"#)\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<MovieRatings> = client\n  .index(\"movie_rating\")\n  .search()\n  .with_query(\"thriller\")\n  .with_filter(\"rating.users >= 90\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Movie> = client\n  .index(\"movies\")\n  .search()\n  .with_query(\"shifu\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Movie> = client\n  .index(\"movies\")\n  .search()\n  .with_query(\"shifu\")\n  .with_offset(1)\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Movie> = client\n  .index(\"movies\")\n  .search()\n  .with_query(\"shifu\")\n  .with_limit(2)\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "client.index(\"movies\").search().with_hits_per_page(15).execute().await?;"
          },
          {
            "lang": "Rust",
            "source": "client.index(\"movies\").search().with_page(2).execute().await?;"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Movie> = client\n  .index(\"movies\")\n  .search()\n  .with_query(\"shifu\")\n  .with_attributes_to_retrieve(Selectors::Some(&[\"overview\", \"title\"]))\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Movie> = client\n  .index(\"movies\")\n  .search()\n  .with_query(\"shifu\")\n  .with_attributes_to_crop(Selectors::Some(&[(\"overview\", None)]))\n  .with_crop_length(5)\n  .execute()\n  .await\n  .unwrap();\n\n// Get the formatted results\nlet formatted_results: Vec<&Movie> = results\n  .hits\n  .iter()\n  .map(|r| r.formatted_result.as_ref().unwrap())\n  .collect();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Movie> = client\n  .index(\"movies\")\n  .search()\n  .with_query(\"shifu\")\n  .with_attributes_to_crop(Selectors::Some(&[(\"overview\", None)]))\n  .with_crop_marker(\"[]\")\n  .execute()\n  .await\n  .unwrap();\n\n// Get the formatted results\nlet formatted_results: Vec<&Movie> = results\n  .hits\n  .iter()\n  .map(|r| r.formatted_result.as_ref().unwrap())\n  .collect();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Movie> = client\n  .index(\"movies\")\n  .search()\n  .with_query(\"winter feast\")\n  .with_attributes_to_highlight(Selectors::Some(&[\"overview\"]))\n  .execute()\n  .await\n  .unwrap();\n\n// Get the formatted results\nlet formatted_results: Vec<&Movie> = results\n  .hits\n  .iter()\n  .map(|r| r.formatted_result.as_ref().unwrap())\n  .collect();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Movie> = client\n  .index(\"movies\")\n  .search()\n  .with_query(\"winter feast\")\n  .with_attributes_to_highlight(Selectors::Some(&[\"overview\"]))\n  .with_highlight_pre_tag(\"<span class=\\\"highlight\\\">\")\n  .with_highlight_post_tag(\"</span>\")\n  .execute()\n  .await\n  .unwrap();\n\n// Get the formatted results\nlet formatted_results: Vec<&Movie> = results\n  .hits\n  .iter()\n  .map(|r| r.formatted_result.as_ref().unwrap())\n  .collect();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Movie> = client\n  .index(\"movies\")\n  .search()\n  .with_query(\"winter feast\")\n  .with_show_matches_position(true)\n  .execute()\n  .await\n  .unwrap();\n\n// Get the matches info\nlet matches_position: Vec<&HashMap<String, Vec<MatchRange>>> = results\n  .hits\n  .iter()\n  .map(|r| r.matches_position.as_ref().unwrap())\n  .collect();"
          },
          {
            "lang": "Rust",
            "source": "use meilisearch_sdk::{\n  indexes::*,\n  client::*,\n  search::*,\n  settings::*\n};\nuse serde::{Serialize, Deserialize};\nuse std::{io::prelude::*, fs::File};\nuse futures::executor::block_on;\n\nfn main() { block_on(async move {\n  let client = Client::new(\"http://localhost:7700\", Some(\"masterKey\"));\n\n  // reading and parsing the file\n  let mut file = File::open(\"movies.json\")\n    .unwrap();\n  let mut content = String::new();\n  file\n    .read_to_string(&mut content)\n    .unwrap();\n  let movies_docs: Vec<Movie> = serde_json::from_str(&content)\n    .unwrap();\n\n  // adding documents\n  client\n    .index(\"movies\")\n    .add_documents(&movies_docs, None)\n    .await\n    .unwrap();\n})}"
          },
          {
            "lang": "Rust",
            "source": "// In your .toml file:\n  [dependencies]\n  meilisearch-sdk = \"0.31.0\"\n  # futures: because we want to block on futures\n  futures = \"0.3\"\n  # serde: required if you are going to use documents\n  serde = { version=\"1.0\",   features = [\"derive\"] }\n  # serde_json: required in some parts of this guide\n  serde_json = \"1.0\"\n```\n\n// In your .rs file:\n// Documents in the Rust library are strongly typed\n#[derive(Serialize, Deserialize)]\nstruct Movie {\n  id: i64,\n  title: String,\n  poster: String,\n  overview: String,\n  release_date: i64,\n  genres: Vec<String>\n}\n\n// You will often need this `Movie` struct in other parts of this documentation. (you will have to change it a bit sometimes)\n// You can also use schemaless values, by putting a `serde_json::Value` inside your own struct like this:\n#[derive(Serialize, Deserialize)]\nstruct Movie {\n  id: i64,\n  #[serde(flatten)]\n  value: serde_json::Value,\n}\n\n// Then, add documents into the index:\nuse meilisearch_sdk::{\n  indexes::*,\n  client::*,\n  search::*,\n  settings::*\n};\nuse serde::{Serialize, Deserialize};\nuse std::{io::prelude::*, fs::File};\nuse futures::executor::block_on;\n\nfn main() { block_on(async move {\n  let client = Client::new(\"http://localhost:7700\", Some(\"aSampleMasterKey\"));\n\n  // Reading and parsing the file\n  let mut file = File::open(\"movies.json\")\n    .unwrap();\n  let mut content = String::new();\n  file\n    .read_to_string(&mut content)\n    .unwrap();\n  let movies_docs: Vec<Movie> = serde_json::from_str(&content)\n    .unwrap();\n\n  // Adding documents\n  client\n    .index(\"movies\")\n    .add_documents(&movies_docs, None)\n    .await\n    .unwrap();\n})}"
          },
          {
            "lang": "Rust",
            "source": "client\n  .get_task(0)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "// You can build a `SearchQuery` and execute it later:\nlet query: SearchQuery = SearchQuery::new(&movies)\n  .with_query(\"botman\")\n  .build();\n\nlet results: SearchResults<Movie> = client\n  .index(\"movies\")\n  .execute_query(&query)\n  .await\n  .unwrap();\n\n// You can build a `SearchQuery` and execute it directly:\nlet results: SearchResults<Movie> = SearchQuery::new(&movies)\n  .with_query(\"botman\")\n  .execute()\n  .await\n  .unwrap();\n\n// You can search in an index directly:\nlet results: SearchResults<Movie> = client\n  .index(\"movies\")\n  .search()\n  .with_query(\"botman\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "use serde::{Serialize, Deserialize};\nuse std::fs::File;\n\n#[derive(Serialize, Deserialize)]\nstruct Geo {\n  lat: f64,\n  lon: f64\n}\n\nstruct Meteorite {\n  name: String,\n  id: String,\n  nametype: String,\n  recclass: String,\n  mass: i64,\n  fall: String,\n  _geo: Geo\n}\n\nlet mut file = File::open(\"meteorites.json\")?;\nlet meteorites: Vec<Meteorite> = serde_json::from_reader(file)?;\n\nclient\n  .index(\"meteorites\")\n  .add_documents(&meteorites, None)\n  .await?;"
          },
          {
            "lang": "Rust",
            "source": "let ranking_rules = [\n  \"exactness\",\n  \"words\",\n  \"typo\",\n  \"proximity\",\n  \"attribute\",\n  \"sort\",\n  \"release_date:asc\",\n  \"rank:desc\"\n];\n\nclient\n  .index(\"movies\")\n  .set_ranking_rules(&ranking_rules)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let displayed_attributes = [\n  \"title\",\n  \"overview\",\n  \"poster\",\n];\n\nclient\n  .index(\"movies\")\n  .set_displayed_attributes(&displayed_attributes)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let searchable_attributes = [\n  \"title\"\n];\n\nclient\n  .index(\"movies\")\n  .set_searchable_attributes(&searchable_attributes)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let stop_words = [\"the\"];\nclient\n  .index(\"movies\")\n  .set_stop_words(&stop_words)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let mut synonyms = std::collections::HashMap::new();\nsynonyms.insert(String::from(\"winnie\"), vec![String::from(\"piglet\")]);\nsynonyms.insert(String::from(\"piglet\"), vec![String::from(\"winnie\")]);\n\nclient\n  .index(\"movies\")\n  .set_synonyms(&synonyms)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Meteorite> = client\n  .index(\"meteorites\")\n  .search()\n  .with_filter(\"mass < 200\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Meteorite> = client\n  .index(\"meteorites\")\n  .search()\n  .with_filter(\"_geoRadius(46.9480, 7.4474, 210000)\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Meteorite> = client\n  .index(\"meteorites\")\n  .search()\n  .with_sort(&[\"_geoPoint(48.8583701, 2.2922926):asc\"])\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Meteorite> = client\n  .index(\"meteorites\")\n  .search()\n  .with_filter(\"mass < 200\")\n  .with_sort(&[\"mass:asc\"])\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let settings = Settings::new()\n  .with_filterable_attributes([\n    \"mass\",\n    \"_geo\"\n  ])\n  .with_sortable_attributes([\n    \"mass\",\n    \"_geo\"\n  ])\nlet task: TaskInfo = client\n  .index(\"meteorites\")\n  .set_settings(&settings)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Movie> = client\n  .index(\"movies\")\n  .search()\n  .with_query(\"thriller\")\n  .with_filter(\"(genres = Horror AND genres = Mystery) OR director = \\\"Jordan Peele\\\"\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Movie> = client\n  .index(\"movies\")\n  .search()\n  .with_query(\"\\\"african american\\\" horror\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let sortable_attributes = [\n  \"author\",\n  \"price\"\n];\n\nlet task: TaskInfo = client\n  .index(\"books\")\n  .set_sortable_attributes(&sortable_attributes)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let ranking_rules = [\n  \"words\",\n  \"sort\",\n  \"typo\",\n  \"proximity\",\n  \"attribute\",\n  \"exactness\"\n];\n\nlet task: TaskInfo = client\n  .index(\"books\")\n  .set_ranking_rules(&ranking_rules)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Books> = client\n  .index(\"books\")\n  .search()\n  .with_query(\"science fiction\")\n  .with_sort(&[\"rating.users:asc\"])\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Books> = client\n  .index(\"books\")\n  .search()\n  .with_query(\"science fiction\")\n  .with_sort(&[\"price:asc\"])\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Books> = client\n  .index(\"books\")\n  .search()\n  .with_query(\"butler\")\n  .with_sort(&[\"author:desc\"])\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Books> = client\n  .index(\"books\")\n  .search()\n  .with_query(\"science fiction\")\n  .with_sort(&[\"price:asc\"])\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"restaurants\")\n  .set_filterable_attributes(&[\"_geo\"])\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Restaurant> = client\n  .index(\"restaurants\")\n  .search()\n  .with_filter(\"_geoRadius(45.472735, 9.184019, 2000)\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Restaurant> = client\n  .index(\"restaurants\")\n  .search()\n  .with_filter(\"_geoRadius(45.472735, 9.184019, 2000) AND type = pizza\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Restaurant> = client\n  .index(\"restaurants\")\n  .search()\n  .with_filter(\"_geoBoundingBox([45.494181, 9.214024], [45.449484, 9.179175])\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"restaurants\")\n  .set_sortable_attributes(&[\"_geo\"])\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Restaurant> = client\n  .index(\"restaurants\")\n  .search()\n  .with_sort(&[\"_geoPoint(48.8561446, 2.2978204):asc\"])\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Restaurant> = client\n  .index(\"restaurants\")\n  .search()\n  .with_sort(&[\"_geoPoint(48.8561446, 2.2978204):asc\", \"rating:desc\"])\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let client = Client::new(\"http://localhost:7700\", Some(\"MASTER_KEY\"));\nclient\n  .get_keys()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let client = Client::new(\"http://localhost:7700\", Some(\"DEFAULT_ADMIN_API_KEY\"));\nlet task = client\n  .create_index(\"medical_records\", Some(\"id\"))\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let client = Client::new(\"http://localhost:7700\", Some(\"DEFAULT_SEARCH_API_KEY\"));\nlet index = client.index(\"medical_records\");\nindex\n  .search()\n  .with_query(\"appointments\")\n  .execute::<MedicalRecord>()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let client = Client::new(\"http://localhost:7700\", Some(\"apiKey\"));\nlet result = client.index(\"patient_medical_records\")\n  .search()\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let client = Client::new(\"http://localhost:7700\", Some(\"masterKey\"));\nlet mut key = client\n  .get_key(\"74c9c733-3368-4738-bbe5-1d18a5fecb37\")\n  .await\n  .unwrap();\nkey\n  .with_description(\"Default Search API key\".to_string())\n  .update(&client);"
          },
          {
            "lang": "Rust",
            "source": "let client = Client::new(\"http://localhost:7700\", Some(\"masterKey\"));\nlet mut key_options = KeyBuilder::new();\nkey_options\n  .with_name(\"Search patient records key\")\n  .with_action(Action::Search)\n  .with_expires_at(time::macros::datetime!(2023 - 01 - 01 00:00:00 UTC))\n  .with_index(\"patient_medical_records\");\nlet new_key = client\n  .create_key(key_options)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let client = Client::new(\"http://localhost:7700\", Some(\"masterKey\"));\nlet keys = client\n  .get_keys()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let client = Client::new(\"http://localhost:7700\", Some(\"masterKey\"));\nlet key = client\n  .get_key(\"ac5cd97d-5a4b-4226-a868-2d0eb6d197ab\")\n  .await\n  .unwrap();\nclient\n  .delete_key(&key)\n  .await?;"
          },
          {
            "lang": "Rust",
            "source": "client\n  .create_index(\"books\", Some(\"reference_number\"))\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "#[derive(Serialize, Deserialize)]\nstruct Book {\n  reference_number: String,\n  title: String,\n  author: String,\n  genres: Vec<String>,\n  price: f64\n}\n\nlet task: TaskInfo = client\n  .index(\"books\")\n  .add_documents(&[\n    Book {\n      reference_number: \"287947\".to_string(),\n      title: \"Diary of a Wimpy Kid\".to_string(),\n      author: \"Jeff Kinney\".to_string(),\n      genres: vec![\"comedy\".to_string(),\"humor\".to_string()],\n      price: 5.00\n    }\n  ], Some(\"reference_number\"))\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let task = IndexUpdater::new(\"books\", &client)\n  .with_primary_key(\"title\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let typo_tolerance = TypoToleranceSettings {\n  enabled: Some(false),\n  disable_on_attributes: None,\n  disable_on_words: None,\n  min_word_size_for_typos: None,\n};\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_typo_tolerance(&typo_tolerance)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let min_word_size_for_typos = MinWordSizeForTypos {\n  one_typo: Some(5),\n  two_typos: Some(12)\n}\nlet typo_tolerance = TypoToleranceSettings {\n  enabled: Some(true),\n  disable_on_attributes: Some(vec![\"title\".to_string()]),\n  disable_on_words: None,\n  min_word_size_for_typos: None,\n};\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_typo_tolerance(&typo_tolerance)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let min_word_size_for_typos = MinWordSizeForTypos {\n  one_typo: Some(5),\n  two_typos: Some(12)\n}\nlet typo_tolerance = TypoToleranceSettings {\n  enabled: Some(true),\n  disable_on_attributes: None,\n  disable_on_words: Some(vec![\"shrek\".to_string()]),\n  min_word_size_for_typos: Some(min_word_size_for_typos),\n};\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_typo_tolerance(&typo_tolerance)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let min_word_size_for_typos = MinWordSizeForTypos {\n  one_typo: Some(4),\n  two_typos: Some(12)\n};\nlet typo_tolerance = TypoToleranceSettings {\n  enabled: Some(true),\n  disable_on_attributes: Some(vec![]),\n  disable_on_words: Some(vec![\"title\".to_string()]),\n  min_word_size_for_typos: Some(min_word_size_for_typos),\n};\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_typo_tolerance(&typo_tolerance)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "// Deactivate typo tolerance on numbers and other high entropy words\nlet typo_tolerance = TypoToleranceSettings {\n  disable_on_numbers: Some(true),\n  ..Default::default()\n};\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_typo_tolerance(&typo_tolerance)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let min_word_size_for_typos = MinWordSizeForTypos {\n  one_typo: Some(5),\n  two_typos: Some(4)\n}\nlet typo_tolerance = TypoToleranceSettings {\n  enabled: Some(true),\n  disable_on_attributes: Some(vec![]),\n  disable_on_words: Some(vec![\"title\".to_string()]),\n  min_word_size_for_typos: Some(min_word_size_for_typos),\n};\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_typo_tolerance(&typo_tolerance)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let mut synonyms = std::collections::HashMap::new();\nsynonyms.insert(String::from(\"great\"), vec![String::from(\"fantastic\")]);\nsynonyms.insert(String::from(\"fantastic\"), vec![String::from(\"great\")]);\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_synonyms(&synonyms)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let mut facet_sort_setting = BTreeMap::new();\nfacet_sort_setting.insert(\"*\".to_string(), FacetSortValue::Count);\nlet mut faceting = FacetingSettings {\n  max_values_per_facet: 2,\n  sort_facet_values_by: Some(facet_sort_setting),\n};\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_faceting(&faceting)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let pagination = PaginationSetting {max_total_hits:500};\n\nlet task: TaskInfo = client\n  .index(\"books\")\n  .set_pagination(pagination)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Movie> = client\n.index(\"movies\")\n.search()\n.with_query(\"big fat liar\")\n.with_matching_strategy(MatchingStrategies::LAST)\n.execute()\n.await\n.unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Movie> = client\n.index(\"movies\")\n.search()\n.with_query(\"big fat liar\")\n.with_matching_strategy(MatchingStrategies::ALL)\n.execute()\n.await\n.unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Movie> = client\n.index(\"movies\")\n.search()\n.with_query(\"white shirt\")\n.with_matching_strategy(MatchingStrategies::FREQUENCY)\n.execute()\n.await\n.unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let mut file = File::open(\"games.json\")\n  .unwrap();\nlet mut content = String::new();\nfile\n  .read_to_string(&mut content)\n  .unwrap();\nlet docs: Vec<Game> = serde_json::from_str(&content)\n  .unwrap();\n\nclient\n  .index(\"games\")\n  .add_documents(&docs, None)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let settings = Settings::new()\n  .with_filterable_attributes([\"release_timestamp\"]);\n\nlet task: TaskInfo = client\n  .index(\"games\")\n  .set_settings(&settings)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Game> = client\n  .index(\"games\")\n  .search()\n  .with_filter(\"release_timestamp >= 1514761200 AND release_timestamp < 1672527600\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let settings = Settings::new()\n  .with_sortable_attributes([\"release_timestamp\"]);\n\nlet task: TaskInfo = client\n  .index(\"games\")\n  .set_settings(&settings)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Game> = client\n  .index(\"games\")\n  .search()\n  .with_sort([\"release_timestamp:desc\"])\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let mut query = TasksQuery::new(&client);\nlet tasks = query\n  .with_statuses([\"failed\"])\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let mut query = TasksQuery::new(&client);\nlet tasks = query\n  .with_statuses([\"failed\", \"canceled\"])\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let mut query = TasksQuery::new(&client);\nlet tasks = query\n  .with_index_uids([\"movies\"])\n  .with_types([\"documentAdditionOrUpdate\",\"documentDeletion\"])\n  .with_statuses([\"processing\"])\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movie_ratings\")\n  .set_filterable_attributes(&[\"genres\", \"rating\", \"language\"])\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let books = client.index(\"books\");\n\nlet results: SearchResults<Book> = SearchQuery::new(&books)\n  .with_query(\"classic\")\n  .with_facets(Selectors::Some(&[\"genres\", \"rating\", \"language\"]))\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let books = client.index(\"movie_ratings\");\nlet results: SearchResults<Book> = SearchQuery::new(&books)\n  .with_query(\"Batman\")\n  .with_facets(Selectors::Some(&[\"genres\", \"rating\"))\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .set_filterable_attributes([\"director\", \"genres\"])\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let mut facet_sort_setting = BTreeMap::new();\nfacet_sort_setting.insert(\"genres\".to_string(), FacetSortValue::Count);\nlet faceting = FacetingSettings {\n  max_values_per_facet: 100,\n  sort_facet_values_by: Some(facet_sort_setting),\n};\n\nlet res = client.index(\"books\")\n  .set_faceting(&faceting)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let res = client.index(\"books\")\n  .facet_search(\"genres\")\n  .with_facet_query(\"c\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Movie> = client\n  .index(\"movies\")\n  .search()\n  .with_query(\"dragon\")\n  .with_show_ranking_score(true)\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Movie> = client\n  .index(\"movies\")\n  .search()\n  .with_query(\"dragon\")\n  .with_show_ranking_score_details(true)\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Movie> = client\n  .index(\"movies\")\n  .search()\n  .with_query(\"adventure\")\n  .with_attributes_to_search_on(&[\"overview\"])\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let searchable_attributes: Vec<String> = index\n  .get_searchable_attributes()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let task = index\n  .set_searchable_attributes([\"title\", \"overview\"])\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let task_status = index.get_task(&task).await.unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results = index.search()\n  .with_query(\"-escape\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results = index.search()\n  .with_query(\"-\\\"escape room\\\"\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let res = client\n  .index(\"INDEX_NAME\")\n  .search()\n  .with_query(\"QUERY TERMS\")\n  .with_distinct(\"ATTRIBUTE_A\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"products\")\n  .settings()\n  .set_filterable_attributes([\"product_id\", \"sku\", \"url\"])\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let res = client\n  .index(\"products\")\n  .search()\n  .with_query(\"white shirt\")\n  .with_distinct(\"sku\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let res = client\n  .index(\"INDEX_NAME\")\n  .search()\n  .with_query(\"badman\")\n  .with_ranking_score_threshold(0.2)\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let res = client\n  .index(\"books\")\n  .search()\n  .with_query(\"\")\n  .with_locales(&[\"jpn\"])\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results = index\n  .search()\n  .with_query(\"kitchen utensils\")\n  .with_hybrid(\"EMBEDDER_NAME\", 0.9)\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results = index\n  .search()\n  .with_vector(&[0.0, 1.0, 2.0])\n  .with_hybrid(\"EMBEDDER_NAME\", 1.0)\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results = index\n  .search()\n  .with_query(\"kitchen utensils\")\n  .with_retrieve_vectors(true)\n  .with_hybrid(\"EMBEDDER_NAME\", 0.5)\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let embedders = HashMap::from([(\n  String::from(\"movies-text\"),\n  Embedder {\n    source: EmbedderSource::OpenAi,\n    api_key: Some(String::from(\"OPENAI_API_KEY\")),\n    model: Some(String::from(\"text-embedding-3-small\")),\n    document_template: Some(String::from(\"A movie titled '{{doc.title}}' released in {{ doc.release_date }}. The movie genres are: {{doc.genres}}. The story is about: {{doc.overview|truncatewords: 20}}\")),\n    ..Embedder::default()\n  }\n)]);\nmovies.set_embedders(&embedders)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results = movies.search()\n  .with_query(\"batman\")\n  .with_hybrid(\"EMBEDDER_NAME\", 0.5)\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "let results = movies.similar_search(\"192\", \"EMBEDDER_NAME\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Rust",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/INDEX_A' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{ \"uid\": \"INDEX_B\" }'"
          },
          {
            "lang": "Rust",
            "source": "let results = index\n  .search()\n  .with_hybrid(\"EMBEDDER_NAME\", 0.5)\n  .with_media(json!({\n    \"FIELD_A\": \"VALUE_A\",\n    \"FIELD_B\": {\n      \"FIELD_C\": \"VALUE_B\",\n      \"FIELD_D\": \"VALUE_C\"\n    }\n  }))\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.version { (result) in\n    switch result {\n    case .success(let version):\n        print(version)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"jackets\").updateDistinctAttribute(\"product_id\") { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchableAttributes: [String] = [\n    \"title\",\n    \"overview\",\n    \"genres\"\n]\nclient.index(\"movies\").updateSearchableAttributes(searchableAttributes) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let displayedAttributes: [String] = [\n    \"title\",\n    \"overview\",\n    \"genres\",\n    \"release_date\"\n]\nclient.index(\"movies\").updateDisplayedAttributes(displayedAttributes) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n    query: \"Avengers\",\n    filter: \"release_date > 795484800\"\n)\nclient.index(\"movie_ratings\").search(searchParameters) { (result: Result<Searchable<Movie>, Swift.Error>) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n    query: \"Batman\",\n    filter: \"release_date > 795484800 AND (director = \\\"Tim Burton\\\" OR director = \\\"Christopher Nolan\\\"\")\nclient.index(\"movie_ratings\").search(searchParameters) { (result: Result<Searchable<Movie>, Swift.Error>) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n    query: \"Planet of the Apes\",\n    filter: \"release_date > 1577884550 AND (NOT director = \\\"Tim Burton\\\"))\nclient.index(\"movie_ratings\").search(searchParameters) { (result: Result<Searchable<Movie>, Swift.Error>) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n    query: \"thriller\",\n    filter: \"rating.users >= 90\"\n)\nclient.index(\"movie_ratings\").search(searchParameters) { (result: Result<Searchable<Meteorite>, Swift.Error>) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").search(SearchParameters(query: \"shifu\")) { (result: Result<Searchable<Movie>, Swift.Error>) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n    query: \"shifu\",\n    offset: 1)\nclient.index(\"movies\").search(searchParameters) { (result: Result<Searchable<Movie>, Swift.Error>) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n    query: \"shifu\",\n    limit: 2)\nclient.index(\"movies\").search(searchParameters) { (result: Result<Searchable<Movie>, Swift.Error>) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(query: \"\", hitsPerPage: 15)\nclient.index(\"movies\").search(searchParameters) { (result: Result<Searchable<Movie>, Swift.Error>) in\n  switch result {\n  case .success(let searchResult):\n      print(searchResult)\n  case .failure(let error):\n      print(error)\n  }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(query: \"\", page: 15)\nclient.index(\"movies\").search(searchParameters) { (result: Result<Searchable<Movie>, Swift.Error>) in\n  switch result {\n  case .success(let searchResult):\n      print(searchResult)\n  case .failure(let error):\n      print(error)\n  }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n    query: \"shifu\",\n    attributesToRetrieve: [\"overview\", \"title\"])\nclient.index(\"movies\").search(searchParameters) { (result: Result<Searchable<Movie>, Swift.Error>) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n    query: \"shifu\",\n    attributesToCrop: [\"overview\"],\n    cropLength: 5)\nclient.index(\"movies\").search(searchParameters) { (result: Result<Searchable<Movie>, Swift.Error>) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n    query: \"shifu\",\n    attributesToCrop: [\"overview\"],\n    cropMarker: \"[]\")\nclient.index(\"movies\").search(searchParameters) { (result: Result<Searchable<Movie>, Swift.Error>) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n    query: \"winter feast\",\n    attributesToHighlight: [\"overview\"])\nclient.index(\"movies\").search(searchParameters) { (result: Result<Searchable<Movie>, Swift.Error>) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n    query: \"winter feast\",\n    attributesToHighlight: [\"overview\"],\n    highlightPreTag: \"<span class=\\\"highlight\\\">\",\n    highlightPostTag: \"</span>\")\nclient.index(\"movies\").search(searchParameters) { (result: Result<Searchable<Movie>, Swift.Error>) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n    query: \"winter feast\",\n    showMatchesPosition: true)\nclient.index(\"movies\").search(searchParameters) { (result: Result<Searchable<Movie>, Swift.Error>) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let path = Bundle.main.url(forResource: \"movies\", withExtension: \"json\")!\nlet documents: Data = try Data(contentsOf: path)\n\nclient.index(\"movies\").addDocuments(documents: documents) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "// Add this to your `Package.swift`\ndependencies: [\n  .package(url: \"https://github.com/meilisearch/meilisearch-swift.git\", from: \"0.17.0\")\n]\n\n// In your .swift file:\nlet path = Bundle.main.url(forResource: \"movies\", withExtension: \"json\")!\nlet documents: Data = try Data(contentsOf: path)\nlet client = try MeiliSearch(host: \"http://localhost:7700\", apiKey: \"aSampleMasterKey\")\n\nclient.index(\"movies\").addDocuments(documents: documents) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "client.getTask(taskUid: 0) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").search(SearchParameters(query: \"botman\")) { (result) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let file = \"meteorites.json\"\nlet path = URL(fileURLWithPath: file)\nlet documents: Data = try Data(contentsOf: path)\n\nclient.index(\"meteorites\").addDocuments(documents: documents) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let rankingRules: [String] = [\n  \"exactness\",\n  \"words\",\n  \"typo\",\n  \"proximity\",\n  \"attribute\",\n  \"sort\",\n  \"release_date:asc\",\n  \"rank:desc\"\n]\nclient.index(\"movies\").updateRankingRules(rankingRules) { (result) in\n  switch result {\n  case .success(let task):\n    print(task)\n  case .failure(let error):\n    print(error)\n  }\n}"
          },
          {
            "lang": "Swift",
            "source": "let displayedAttributes: [String] = [\"title\", \"overview\", \"poster\"]\nclient.index(\"movies\").updateDisplayedAttributes(displayedAttributes) { (result) in\n     switch result {\n     case .success(let task):\n         print(task)\n     case .failure(let error):\n         print(error)\n     }\n }"
          },
          {
            "lang": "Swift",
            "source": "let searchableAttributes: [String] = [\"title\"]\nclient.index(\"movies\").updateSearchableAttributes(searchableAttributes) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let stopWords: [String] = [\"the\"]\nclient.index(\"movies\").updateStopWords(stopWords) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let synonyms: [String: [String]] = [\n   \"winnie\": [\"piglet\"],\n   \"piglet\": [\"winnie\"]\n]\n client.index(\"movies\").updateSynonyms(synonyms) { (result) in\n     switch result {\n     case .success(let task):\n         print(task)\n     case .failure(let error):\n         print(error)\n     }\n }"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n   query: \"\",\n   filter: \"mass < 200\"\n )\n client.index(\"meteorites\").search(searchParameters) { (result: Result<Searchable<Meteorite>, Swift.Error>) in\n     switch result {\n     case .success(let searchResult):\n         print(searchResult)\n     case .failure(let error):\n         print(error)\n     }\n }"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n    query: \"\",\n    filter: \"_geoRadius(46.9480, 7.4474, 210000)\"\n)\nclient.index(\"meteorites\").search(searchParameters) { (result: Result<Searchable<Meteorite>, Swift.Error>) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n    query: \"\",\n    sort: [\"_geoPoint(48.8583701, 2.2922926):asc\"]\n)\nclient.index(\"meteorites\").search(searchParameters) { (result: Result<Searchable<Meteorite>, Swift.Error>) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n  query: \"\",\n  filter: \"mass < 200\",\n  sort: [\"mass:asc\"]\n)\nclient.index(\"meteorites\").search(searchParameters) { (result: Result<Searchable<Meteorite>, Swift.Error>) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let settings = Setting(\n  filterableAttributes: [\"mass\", \"_geo\"],\n  sortableAttributes: [\"mass\", \"_geo\"]\n)\nclient.index(\"meteorites\").updateSettings(settings) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n    query: \"thriller\",\n    filter: [\n      [\n        \"genres = Horror\",\n        \"genres = Mystery\"\n      ],\n      \"director = \\\"Jordan Peele\\\"\"\n    ])\nclient.index(\"movies\").search(searchParameters) { (result: Result<Searchable<Movie>, Swift.Error>) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n    query: \"\\\"african american\\\" horror\")\nclient.index(\"movies\").search(searchParameters) { (result: Result<Searchable<Movie>, Swift.Error>) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "client = try MeiliSearch(host: \"http://localhost:7700\", apiKey: \"masterKey\")\nclient.getKeys { result in\n    switch result {\n    case .success(let keys):\n        print(keys)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"books\").updateSortableAttributes([\"price\", \"author\"]) { (result: Result<TaskInfo, Swift.Error>) in\n  switch result {\n  case .success(let task):\n    print(task)\n  case .failure(let error):\n    print(error)\n  }\n}"
          },
          {
            "lang": "Swift",
            "source": "let rankingRules: [String] = [\n  \"words\",\n  \"sort\",\n  \"typo\",\n  \"proximity\",\n  \"attribute\",\n  \"exactness\"\n]\nclient.index(\"books\").updateRankingRules(rankingRules) { (result) in\n  switch result {\n  case .success(let task):\n    print(task)\n  case .failure(let error):\n    print(error)\n  }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n    query: \"science fiction\",\n    sort: [\"rating.users:asc\"]\n)\nclient.index(\"books\").search(searchParameters) { (result: Result<Searchable<Meteorite>, Swift.Error>) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n  query: \"science fiction\",\n  sort: [\"price:asc\"]\n)\nclient.index(\"books\").search(searchParameters) { (result: Result<Searchable<Book>, Swift.Error>) in\n  switch result {\n  case .success(let searchResult):\n    print(searchResult)\n  case .failure(let error):\n    print(error)\n  }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n  query: \"butler\",\n  sort: [\"author:desc\"]\n)\nclient.index(\"books\").search(searchParameters) { (result: Result<Searchable<Book>, Swift.Error>) in\n  switch result {\n  case .success(let searchResult):\n    print(searchResult)\n  case .failure(let error):\n    print(error)\n  }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n  query: \"science fiction\",\n  sort: [\"price:asc\"]\n)\nclient.index(\"books\").search(searchParameters) { (result: Result<Searchable<Book>, Swift.Error>) in\n  switch result {\n  case .success(let searchResult):\n    print(searchResult)\n  case .failure(let error):\n    print(error)\n  }\n}"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"restaurants\").updateFilterableAttributes([\"_geo\"]) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n    filter: \"_geoRadius(45.472735, 9.184019, 2000)\"\n)\nclient.index(\"restaurants\").search(searchParameters) { (result: Result<Searchable<Restaurant>, Swift.Error>) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n    filter: \"_geoRadius(45.472735, 9.184019, 2000) AND type = pizza\"\n)\nclient.index(\"restaurants\").search(searchParameters) { (result: Result<Searchable<Restaurant>, Swift.Error>) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n    filter: \"_geoBoundingBox([45.494181, 9.214024], [45.449484, 9.179175])\"\n)\nclient.index(\"restaurants\").search(searchParameters) { (result: Result<Searchable<Restaurant>, Swift.Error>) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"restaurants\").updateSortableAttributes([\"_geo\"]) { (result) in\n  switch result {\n  case .success(let task):\n    print(task)\n  case .failure(let error):\n    print(error)\n  }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n    query: \"\",\n    sort: [\"_geoPoint(48.8561446, 2.2978204):asc\"]\n)\nclient.index(\"restaurants\").search(searchParameters) { (result: Result<Searchable<Restaurant>, Swift.Error>) in\n    switch result {\n    case .success(let task):\n      print(task)\n    case .failure(let error):\n      print(error)\n    }\n  }"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n    query: \"\",\n    sort: [\"_geoPoint(48.8561446, 2.2978204):asc\", \"rating:desc\"]\n)\nclient.index(\"restaurants\").search(searchParameters) { (result: Result<Searchable<Restaurant>, Swift.Error>) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "client = try MeiliSearch(host: \"http://localhost:7700\", apiKey: \"apiKey\")\nclient.index(\"patient_medical_records\")\n  .search(SearchParameters(query: \"\")) { (result: Result<Searchable<Patient>, Swift.Error>) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let client = try MeiliSearch(host: \"http://localhost:7700\", apiKey: \"masterKey\")\nlet keyParams = KeyUpdateParams(description: \"Default Search API Key\")\n\nclient.updateKey(key: \"74c9c733-3368-4738-bbe5-1d18a5fecb37\", keyParams: keyParams) { result in\n  switch result {\n  case .success(let key):\n    print(key)\n  case .failure(let error):\n    print(error)\n  }\n}"
          },
          {
            "lang": "Swift",
            "source": "let client = try MeiliSearch(host: \"http://localhost:7700\", apiKey: \"masterKey\")\n\nlet keyParams = KeyParams(\n  description: \"Search patient records key\",\n  actions: [\"search\"],\n  indexes: [\"patient_medical_records\"],\n  expiresAt: \"2023-01-01T00:00:00Z\"\n)\nclient.createKey(keyParams) { result in\n  switch result {\n  case .success(let key):\n    print(key)\n  case .failure(let error):\n    print(error)\n  }\n}"
          },
          {
            "lang": "Swift",
            "source": "let client = try MeiliSearch(host: \"http://localhost:7700\", apiKey: \"masterKey\")\n\nclient.getKeys() { result in\n    switch result {\n    case .success(let keys):\n        print(keys)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let client = try MeiliSearch(host: \"http://localhost:7700\", apiKey: \"masterKey\")\n\nclient.deleteKey(keyOrUid: \"ac5cd97d-5a4b-4226-a868-2d0eb6d197ab\") { result in\n    switch result {\n    case .success:\n        print(\"success\")\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "client.createIndex(uid: \"books\", primaryKey: \"reference_number\") { (result) in\n  switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let documents: Data = \"\"\"\n[\n  {\n    \"reference_number\": 287947,\n    \"title\": \"Diary of a Wimpy Kid\",\n    \"author\": \"Jeff Kinney\",\n    \"genres\": [\"comedy\", \"humor\"],\n    \"price\": 5\n  }\n]\n\"\"\".data(using: .utf8)!\n\nclient.index(\"books\").addDocuments(documents: documents, primaryKey: \"reference_number\") { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "client.updateIndex(uid: \"movies\", primaryKey: \"title\") { (result) in\n  switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let synonyms: [String: [String]] = [\n  \"great\": [\"fantastic\"],\n  \"fantastic\": [\"great\"]\n]\n\nclient.index(\"movies\").updateSynonyms(synonyms) { (result) in\n  switch result {\n  case .success(let task):\n      print(task)\n  case .failure(let error):\n      print(error)\n  }\n}"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").updateFaceting({ maxValuesPerFacet: 2 })"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").updatePagination({ maxTotalHits: 500 })"
          },
          {
            "lang": "Swift",
            "source": "let path = Bundle.main.url(forResource: \"games\", withExtension: \"json\")!\nlet documents: Data = try Data(contentsOf: path)\n\nclient.index(\"games\").addDocuments(documents: documents) { (result) in\n  switch result {\n  case .success(let task):\n      print(task)\n  case .failure(let error):\n      print(error)\n  }\n}"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"games\").updateFilterableAttributes([\"release_timestamp\"]) { (result) in\n  switch result {\n  case .success(let task):\n      print(task)\n  case .failure(let error):\n      print(error)\n  }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n  query: \"\",\n  filter: \"release_timestamp >= 1514761200 AND release_timestamp < 1672527600\"\n)\nclient.index(\"games\").search(searchParameters) { (result: Result<Searchable<Game>, Swift.Error>) in\n  switch result {\n  case .success(let searchResult):\n      print(searchResult)\n  case .failure(let error):\n      print(error)\n  }\n}"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"games\").updateSortableAttributes([\"release_timestamp\"]) { (result) in\n  switch result {\n  case .success(let task):\n    print(task)\n  case .failure(let error):\n    print(error)\n  }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(\n  query: \"\",\n  sort: [\"release_timestamp:desc\"],\n)\n\nclient.index(\"games\").search(searchParameters) { (result: Result<Searchable<Game>, Swift.Error>) in\n  switch result {\n  case .success(let searchResult):\n      print(searchResult)\n  case .failure(let error):\n      print(error)\n  }\n}"
          },
          {
            "lang": "Swift",
            "source": "client.getTasks(params: TasksQuery(statuses: [.failed, .canceled])) { result in\n  switch result {\n  case .success(let taskResult):\n    print(taskResult)\n  case .failure(let error):\n    print(error)\n  }\n}"
          },
          {
            "lang": "Swift",
            "source": "client.getTasks(params: TasksQuery(indexUids: \"movies\", types: [\"documentAdditionOrUpdate\", \"documentDeletion\"], statuses: [\"processing\"])) { result in\n  switch result {\n  case .success(let taskResult):\n    print(taskResult)\n  case .failure(let error):\n    print(error)\n  }\n}"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").updateFilterableAttributes([\"genre\", \"director\"]) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(query: \"dragon\", showRankingScore: true)\nclient.index(\"movies\").search(searchParameters) { (result: Result<Searchable<Movie>, Swift.Error>) in\n  switch result {\n  case .success(let searchResult):\n      print(searchResult.rankingScore)\n  case .failure(let error):\n      print(error)\n  }\n}"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(query: \"dragon\", showRankingScoreDetails: true)\nlet movies: Searchable<Movie> = try await client.index(\"movies\").search(searchParameters)"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(query: \"adventure\", attributesToSearchOn: [\"overview\"])\nclient.index(\"movies\").search(searchParameters) { (result: Result<Searchable<Movie>, Swift.Error>) in\n  switch result {\n  case .success(let searchResult):\n      print(searchResult)\n  case .failure(let error):\n      print(error)\n  }\n}"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/version'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/jackets/settings/distinct-attribute' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '\"product_id\"'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/searchable-attributes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n      \"title\",\n      \"overview\",\n      \"genres\"\n    ]'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/displayed-attributes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n      \"title\",\n      \"overview\",\n      \"genres\",\n      \"release_date\"\n    ]'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movie_ratings/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"Avengers\",\n    \"filter\": \"release_date > 795484800\"\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movie_ratings/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"Batman\",\n    \"filter\": \"release_date > 795484800 AND (director = \\\"Tim Burton\\\" OR director = \\\"Christopher Nolan\\\")\"\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movie_ratings/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"Planet of the Apes\",\n    \"filter\": \"release_date > 1577884550 AND (NOT director = \\\"Tim Burton\\\")\"\n  }' \\"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movie_ratings/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"thriller\",\n    \"filter\": \"rating.users >= 90\"\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{ \"q\": \"shifu\" }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"shifu\",\n    \"offset\": 1\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"shifu\",\n    \"limit\": 2\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"\",\n    \"hitsPerPage\": 15\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"\",\n    \"page\": 2\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"shifu\",\n    \"attributesToRetrieve\": [\n      \"overview\",\n      \"title\"\n    ]\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"shifu\",\n    \"attributesToCrop\": [\"overview\"],\n    \"cropLength\": 5\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"shifu\",\n    \"cropMarker\": \"[]\",\n    \"attributesToCrop\": [\"overview\"]\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"winter feast\",\n    \"attributesToHighlight\": [\"overview\"]\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"winter feast\",\n    \"attributesToHighlight\": [\"overview\"],\n    \"highlightPreTag\": \"<span class=\\\"highlight\\\">\",\n    \"highlightPostTag\": \"</span>\"\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"winter feast\",\n    \"showMatchesPosition\": true\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/documents'\\\n  -H 'Content-Type: application/json' \\\n  --data-binary @movies.json"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/documents?primaryKey=id' \\\n  -H 'Content-Type: application/json' \\\n  -H 'Authorization: Bearer aSampleMasterKey' \\\n  --data-binary @movies.json"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/tasks/0' \\\n  -H 'Authorization: Bearer aSampleMasterKey'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/search' \\\n  -H 'Content-Type: application/json' \\\n  -H 'Authorization: Bearer aSampleMasterKey' \\\n  --data-binary '{ \"q\": \"botman\" }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/meteorites/documents' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary @meteorites.json"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/ranking-rules' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"exactness\",\n    \"words\",\n    \"typo\",\n    \"proximity\",\n    \"attribute\",\n    \"sort\",\n    \"release_date:asc\",\n    \"rank:desc\"\n  ]'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/displayed-attributes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"title\",\n    \"overview\",\n    \"poster\"\n  ]'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/searchable-attributes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\"title\"]'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/stop-words' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\"the\"]'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/synonyms' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"winnie\": [\"piglet\"],\n    \"piglet\": [\"winnie\"]\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/meteorites/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{ \"filter\": \"mass < 200\" }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/meteorites/search' \\\n  -H 'Content-type:application/json' \\\n  --data-binary '{ \"filter\": \"_geoRadius(46.9480, 7.4474, 210000)\" }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/meteorites/search' \\\n  -H 'Content-type:application/json' \\\n  --data-binary '{ \"sort\": [\"_geoPoint(48.8583701,2.2922926):asc\"] }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/meteorites/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"filter\": \"mass < 200\",\n    \"sort\": [\"mass:asc\"]\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/meteorites/settings' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"filterableAttributes\": [\n      \"mass\",\n      \"_geo\"\n    ],\n    \"sortableAttributes\": [\n      \"mass\",\n      \"_geo\"\n    ]\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"thriller\",\n    \"filter\": [\n      [\n        \"genres = Horror\",\n        \"genres = Mystery\"\n      ],\n      \"director = \\\"Jordan Peele\\\"\"\n    ]\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/search' \\\n  -H 'Content-Type: application/json' \\\n--data-binary '{ \"q\": \"\\\"african american\\\" horror\" }'"
          },
          {
            "lang": "cURL",
            "source": "# replace the MASTER_KEY placeholder with your master key\ncurl \\\n  -X GET 'MEILISEARCH_URL/keys' \\\n  -H 'Authorization: Bearer MASTER_KEY'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/books/settings/sortable-attributes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"author\",\n    \"price\"\n  ]'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/books/settings/ranking-rules' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"words\",\n    \"sort\",\n    \"typo\",\n    \"proximity\",\n    \"attribute\",\n    \"exactness\"\n  ]'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/books/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"science fiction\",\n    \"sort\": [\"rating.users:asc\"]\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/books/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"science fiction\",\n    \"sort\": [\"price:asc\"]\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/books/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"butler\",\n    \"sort\": [\"author:desc\"]\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/books/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"science fiction\",\n    \"sort\": [\"price:asc\"]\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/restaurants/settings/filterable-attributes' \\\n  -H 'Content-type:application/json' \\\n  --data-binary '[\"_geo\"]'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/restaurants/search' \\\n  -H 'Content-type:application/json' \\\n  --data-binary '{ \"filter\": \"_geoRadius(45.472735, 9.184019, 2000)\" }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/restaurants/search' \\\n  -H 'Content-type:application/json' \\\n  --data-binary '{ \"filter\": \"_geoRadius(45.472735, 9.184019, 2000) AND type = pizza\" }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/restaurants/search' \\\n  -H 'Content-type:application/json' \\\n  --data-binary '{ \"filter\": \"_geoBoundingBox([45.494181, 9.214024], [45.449484, 9.179175])\" }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/restaurants/search' \\\n  -H 'Content-type:application/json' \\\n  --data-binary '{ \"filter\": \"_geoPolygon([45.494181, 9.214024], [45.449484, 9.179175], [45.449486, 9.179177])\" }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/restaurants/settings/sortable-attributes' \\\n  -H 'Content-type:application/json' \\\n  --data-binary '[\"_geo\"]'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/restaurants/search' \\\n  -H 'Content-type:application/json' \\\n  --data-binary '{ \"sort\": [\"_geoPoint(48.8561446,2.2978204):asc\"] }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/restaurants/search' \\\n  -H 'Content-type:application/json' \\\n  --data-binary '{\n    \"sort\": [\n      \"_geoPoint(48.8561446,2.2978204):asc\",\n      \"rating:desc\"\n    ]\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl -X GET 'MEILISEARCH_URL/keys' \\\n-H 'Authorization: Bearer MASTER_KEY'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes' \\\n  -H 'Content-Type: application/json' \\\n  -H 'Authorization: Bearer DEFAULT_ADMIN_API_KEY' \\\n  --data-binary '{\n    \"uid\": \"medical_records\",\n    \"primaryKey\": \"id\"\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/medical_records/search' \\\n  -H 'Content-Type: application/json' \\\n  -H 'Authorization: Bearer DEFAULT_SEARCH_API_KEY' \\\n  --data-binary '{ \"q\": \"appointments\" }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/patient_medical_records/search' \\\n  -H 'Authorization: Bearer API_KEY'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/keys/74c9c733-3368-4738-bbe5-1d18a5fecb37' \\\n  -H 'Authorization: Bearer MASTER_KEY' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{ \"description\": \"Default Search API Key\" }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/keys' \\\n  -H 'Content-Type: application/json' \\\n  -H 'Authorization: Bearer MASTER_KEY' \\\n  --data-binary '{\n    \"description\": \"Search patient records key\",\n    \"actions\": [\"search\"],\n    \"indexes\": [\"patient_medical_records\"],\n    \"expiresAt\": \"2023-01-01T00:00:00Z\"\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/keys' \\\n  -H 'Authorization: Bearer MASTER_KEY'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/keys/ac5cd97d-5a4b-4226-a868-2d0eb6d197ab' \\\n  -H 'Authorization: Bearer MASTER_KEY'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"uid\": \"books\",\n    \"primaryKey\": \"reference_number\"\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/books/documents?primaryKey=reference_number' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    {\n      \"reference_number\": 287947,\n      \"title\": \"Diary of a Wimpy Kid\",\n      \"author\": \"Jeff Kinney\",\n      \"genres\": [\n        \"comedy\",\n        \"humor\"\n      ],\n      \"price\": 5.00\n    }\n  ]'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/books' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{ \"primaryKey\": \"title\" }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/patient_medical_records/search' \\\n  -H 'Authorization: Bearer TENANT_TOKEN'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/movies/settings/typo-tolerance' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{ \"enabled\": false }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/movies/settings/typo-tolerance' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{ \"disableOnAttributes\": [\"title\"] }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/movies/settings/typo-tolerance' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"disableOnWords\": [\n      \"shrek\"\n    ]\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/movies/settings/typo-tolerance' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"minWordSizeForTypos\": {\n      \"oneTypo\": 4,\n      \"twoTypos\": 10\n    }\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/movies/settings/typo-tolerance' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"disableOnNumbers\": true\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'http://<your-domain-name>/version' \\\n  -H 'Authorization: Bearer API_KEY'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'http://<your-domain-name>/version' \\\n  -H 'X-Meili-API-Key: API_KEY'"
          },
          {
            "lang": "cURL",
            "source": "# whenever you see {index_uid}, replace it with your index's unique id\ncurl \\\n  -X GET 'http://<your-domain-name>/indexes/{index_uid}/settings/displayed-attributes' \\\n  -H 'X-Meili-API-Key: API_KEY'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'http://<your-domain-name>/indexes/{index_uid}/settings/displayed-attributes' \\\n  -H 'X-Meili-API-Key: API_KEY'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'http://<your-domain-name>/dumps' \\\n  -H 'Authorization: Bearer API_KEY'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/movies/settings/typo-tolerance' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"minWordSizeForTypos\": { \"oneTypo\": 4 }\n}'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/synonyms' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"great\": [\"fantastic\"], \"fantastic\": [\"great\"]\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/movies/settings/faceting' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"maxValuesPerFacet\": 2,\n     \"sortFacetValuesBy\": {\n       \"*\": \"count\"\n     }\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/movies/settings/pagination' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"maxTotalHits\": 500\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"big fat liar\",\n    \"matchingStrategy\": \"last\"\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"big fat liar\",\n    \"matchingStrategy\": \"all\"\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"white shirt\",\n    \"matchingStrategy\": \"frequency\"\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -x POST 'MEILISEARCH_URL/indexes/games/documents' \\\n  -h 'content-type: application/json' \\\n  --data-binary @games.json"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/games/settings/filterable-attributes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"release_timestamp\"\n  ]'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/games/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"\",\n    \"filter\": \"release_timestamp >= 1514761200 AND release_timestamp < 1672527600\"\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/games/settings/sortable-attributes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"release_timestamp\"\n  ]'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/games/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"\",\n    \"sort\": [\"release_timestamp:desc\"]\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/tasks?statuses=failed'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/tasks?statuses=failed,canceled'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/tasks?indexUids=movies&types=documentAdditionOrUpdate,documentDeletion&statuses=processing'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/multi-search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"federation\": {},\n    \"queries\": [\n      {\n        \"indexUid\": \"movies\",\n        \"q\": \"batman\"\n      },\n      {\n        \"indexUid\": \"comics\",\n        \"q\": \"batman\"\n      }\n    ]\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/books/settings/filterable-attributes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"genres\", \"rating\", \"language\"\n  ]'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/books/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"classic\",\n    \"facets\": [\n    \"genres\", \"rating\", \"language\"\n  ]\n}'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movie_ratings/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"Batman\",\n    \"facets\": [\"genres\", \"rating\"]\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movie_ratings/settings/filterable-attributes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"genres\",\n    \"director\",\n    \"release_date\",\n    \"ratings\"\n  ]'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/books/settings/faceting' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"sortFacetValuesBy\": {\n      \"genres\": \"count\"\n  }\n}'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/books/facet-search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"facetQuery\": \"c\",\n    \"facetName\": \"genres\"\n}'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"dragon\",\n    \"showRankingScore\": true\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"dragon\",\n    \"showRankingScoreDetails\": true\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"adventure\",\n    \"attributesToSearchOn\": [\"overview\"]\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/INDEX_NAME/settings/searchable-attributes'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/INDEX_NAME/settings/searchable-attributes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"title\",\n    \"overview\"\n  ]'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/tasks/TASK_UID'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{ \"q\": \"-escape\" }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{ \"q\": \"-\\\"escape room\\\"\" }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'https://PROJECT_URL/events' \\\n  -H 'Content-Type: application/json' \\\n  -H 'Authorization: Bearer DEFAULT_SEARCH_API_KEY' \\\n  --data-binary '{\n    \"eventType\": \"click\",\n    \"eventName\": \"Search Result Clicked\",\n    \"indexUid\": \"products\",\n    \"userId\": \"SEARCH_USER_ID\",\n    \"queryUid\": \"019a01b7-a1c2-7782-a410-bb1274c81393\",\n    \"objectId\": \"0\",\n    \"objectName\": \"DOCUMENT_DESCRIPTION\",\n    \"position\": 0\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'https://PROJECT_URL/events' \\\n  -H 'Content-Type: application/json' \\\n  -H 'Authorization: Bearer DEFAULT_SEARCH_API_KEY' \\\n  --data-binary '{\n    \"eventType\": \"conversion\",\n    \"eventName\": \"Product Added To Cart\",\n    \"indexUid\": \"products\",\n    \"userId\": \"SEARCH_USER_ID\",\n    \"objectId\": \"0\",\n    \"objectName\": \"DOCUMENT_DESCRIPTION\",\n    \"position\": 0\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/INDEX_NAME/search' \\\n  -H 'Content-Type: application/json' \\\n  -H 'Authorization: Bearer DEFAULT_SEARCH_API_KEY' \\\n  -H 'X-MS-USER-ID: MEILISEARCH_USER_ID' \\\n  --data-binary '{}'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'https://PROJECT_URL/events' \\\n  -H 'Content-Type: application/json' \\\n  -H 'Authorization: Bearer DEFAULT_SEARCH_API_KEY' \\\n  -H 'X-MS-USER-ID: SEARCH_USER_ID' \\\n  --data-binary '{\n    \"eventType\": \"click\",\n    \"eventName\": \"Search Result Clicked\",\n    \"indexUid\": \"products\",\n    \"objectId\": \"0\",\n    \"position\": 0\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'https://PROJECT_URL/events' \\\n  -H 'Content-Type: application/json' \\\n  -H 'Authorization: Bearer DEFAULT_SEARCH_API_KEY' \\\n  --data-binary '{\n    \"eventType\": \"click\",\n    \"userId\": \"SEARCH_USER_ID\",\n    \"eventName\": \"Search Result Clicked\",\n    \"indexUid\": \"products\",\n    \"objectId\": \"0\",\n    \"position\": 0\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/INDEX_NAME/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"QUERY TERMS\",\n    \"distinct\": \"ATTRIBUTE_A\"\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/products/settings/filterable-attributes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"product_id\",\n    \"sku\",\n    \"url\"\n  ]'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/products/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"q\": \"white shirt\",\n    \"distinct\": \"sku\"\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n-X POST 'MEILISEARCH_URL/indexes/INDEX_NAME/search' \\\n-H 'Content-Type: application/json' \\\n--data-binary '{\n    \"q\": \"badman\",\n    \"rankingScoreThreshold\": 0.2\n}'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n-X POST 'MEILISEARCH_URL/indexes/INDEX_NAME/search' \\\n-H 'Content-Type: application/json' \\\n--data-binary '{\n  \"q\": \"QUERY TEXT IN JAPANESE\",\n  \"locales\": [\"jpn\"]\n}'"
          },
          {
            "lang": "cURL",
            "source": "curl -X POST 'MEILISEARCH_URL/indexes/INDEX_NAME/search' \\\n  -H 'content-type: application/json' \\\n  --data-binary '{\n    \"q\": \"kitchen utensils\",\n    \"hybrid\": {\n      \"semanticRatio\": 0.9,\n      \"embedder\": \"EMBEDDER_NAME\"\n    }\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl -X POST 'MEILISEARCH_URL/indexes/INDEX_NAME/search' \\\n  -H 'content-type: application/json' \\\n  --data-binary '{\n    \"vector\": [0, 1, 2],\n    \"hybrid\": {\n      \"embedder\": \"EMBEDDER_NAME\"\n    }\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl -X POST 'MEILISEARCH_URL/indexes/INDEX_NAME/search' \\\n  -H 'content-type: application/json' \\\n  --data-binary '{\n    \"q\": \"kitchen utensils\",\n    \"retrieveVectors\": true,\n    \"hybrid\": {\n      \"embedder\": \"EMBEDDER_NAME\"\n    }\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl -X PATCH 'MEILISEARCH_URL/indexes/movies/settings'\n  -H 'Content-Type: application/json'\n  -H 'Authorization: Bearer MEILISEARCH_API_KEY'\n  --data-binary '{\n    \"embedders\": {\n      \"movies-text\": {\n        \"source\": \"openAi\",\n        \"apiKey\": \"OPENAI_API_KEY\",\n        \"model\": \"text-embedding-3-small\",\n        \"documentTemplate\": \"A movie titled '{{doc.title}}' released in {{ doc.release_date }}. The movie genres are: {{doc.genres}}. The story is about: {{doc.overview|truncatewords: 20}}\"\n      }\n    }\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl -X POST 'MEILISEARCH_URL/indexes/INDEX_NAME/search' \\\n  -H 'content-type: application/json' \\\n  -H 'Authorization: Bearer DEFAULT_SEARCH_API_KEY' \\\n  --data-binary '{\n    \"q\": \"batman\",\n    \"hybrid\": {\n      \"embedder\": \"EMBEDDER_NAME\"\n    }\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/similar' \\\n  -H 'Content-Type: application/json' \\\n  -H 'Authorization: Bearer DEFAULT_SEARCH_API_KEY' \\\n  --data-binary '{\n    \"id\": 192,\n    \"embedder\": \"EMBEDDER_NAME\"\n  }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/INDEX_A' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{ \"uid\": \"INDEX_B\" }'"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/multi-search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"federation\": {},\n    \"queries\": [\n      {\n        \"indexUid\": \"movies\",\n        \"q\": \"batman\",\n        \"federationOptions\": {\n          \"remote\": \"ms-00\"\n        }\n      },\n      {\n        \"indexUid\": \"movies\",\n        \"q\": \"batman\",\n        \"federationOptions\": {\n          \"remote\": \"ms-01\"\n        }\n      }\n    ]"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n-X POST 'MEILISEARCH_URL/indexes/INDEX_NAME/search' \\\n-H 'Content-Type: application/json' \\\n--data-binary '{\n  \"hybrid\": {\n    \"embedder\": \"EMBEDDER_NAME\"\n  },\n  \"media\": {\n    \"FIELD_A\": \"VALUE_A\",\n    \"FIELD_B\" : {\n      \"FIELD_C\": \"VALUE_B\"\n      \"FIELD_D\": \"VALUE_C\"\n    }\n  }\n}'"
          }
        ]
      }
    },
    "/webhooks": {
      "get": {
        "tags": [
          "Webhooks"
        ],
        "operationId": "get_webhooks",
        "responses": {
          "200": {
            "description": "Webhooks are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookResults"
                },
                "example": {
                  "results": [
                    {
                      "uuid": "550e8400-e29b-41d4-a716-446655440000",
                      "url": "https://your.site/on-tasks-completed",
                      "headers": {
                        "Authorization": "Bearer a-secret-token"
                      },
                      "isEditable": true
                    },
                    {
                      "uuid": "550e8400-e29b-41d4-a716-446655440001",
                      "url": "https://another.site/on-tasks-completed",
                      "isEditable": true
                    }
                  ]
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "webhooks.get",
              "webhooks.*",
              "*.get",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "Go",
            "source": "client.ListWebhooks();"
          },
          {
            "lang": "JS",
            "source": "client.getWebhooks()"
          },
          {
            "lang": "Python",
            "source": "client.get_webhooks()"
          },
          {
            "lang": "Rust",
            "source": "let webhooks = client.get_webhooks().await.unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/webhooks'"
          }
        ]
      },
      "post": {
        "tags": [
          "Webhooks"
        ],
        "operationId": "post_webhook",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WebhookSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Webhook created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookWithMetadataRedactedAuthorization"
                },
                "example": {
                  "uuid": "550e8400-e29b-41d4-a716-446655440000",
                  "url": "https://your.site/on-tasks-completed",
                  "headers": {
                    "Authorization": "Bearer a-secret-token"
                  },
                  "isEditable": true
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "webhooks.create",
              "webhooks.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "Go",
            "source": "client.AddWebhook(&meilisearch.AddWebhookRequest{\n  URL: \"WEBHOOK_TARGET_URL\",\n  Headers: map[string]string{\n    \"authorization\": \"SECURITY_KEY\",\n    \"referer\": \"https://example.com\"\n  },\n});"
          },
          {
            "lang": "JS",
            "source": "client.createWebhook({\n  url: 'WEBHOOK_TARGET_URL',\n  headers: {\n    authorization: 'SECURITY_KEY',\n    referer: 'https://example.com'\n  }\n})"
          },
          {
            "lang": "Python",
            "source": "client.create_webhook({\n  'url': 'https://example.com/webhook',\n  'headers': {\"Authorization\":\"\", \"X-Custom-Header\":\"test\"},\n})"
          },
          {
            "lang": "Rust",
            "source": "let mut payload = meilisearch_sdk::webhooks::WebhookCreate::new(\"WEBHOOK_TARGET_URL\");\npayload\n  .insert_header(\"authorization\", \"SECURITY_KEY\")\n  .insert_header(\"referer\", \"https://example.com\");\nlet webhook = client.create_webhook(&payload).await.unwrap();"
          },
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/webhooks' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"url\": \"WEBHOOK_TARGET_URL\",\n    \"headers\": {\n      \"authorization\": \"SECURITY_KEY\",\n      \"referer\": \"https://example.com\"\n    }\n  }'"
          }
        ]
      }
    },
    "/webhooks/{uuid}": {
      "get": {
        "tags": [
          "Webhooks"
        ],
        "operationId": "get_webhook",
        "parameters": [
          {
            "name": "uuid",
            "in": "path",
            "description": "The universally unique identifier of the webhook",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Webhook found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookWithMetadataRedactedAuthorization"
                },
                "example": {
                  "uuid": "550e8400-e29b-41d4-a716-446655440000",
                  "url": "https://your.site/on-tasks-completed",
                  "headers": {
                    "Authorization": "Bearer a-secret"
                  },
                  "isEditable": true
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                }
              }
            }
          },
          "404": {
            "description": "Webhook not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "webhooks.get",
              "webhooks.*",
              "*.get",
              "*"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Webhooks"
        ],
        "operationId": "delete_webhook",
        "parameters": [
          {
            "name": "uuid",
            "in": "path",
            "description": "The universally unique identifier of the webhook",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Webhook deleted successfully"
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                }
              }
            }
          },
          "404": {
            "description": "Webhook not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "webhooks.delete",
              "webhooks.*",
              "*"
            ]
          }
        ]
      },
      "patch": {
        "tags": [
          "Webhooks"
        ],
        "operationId": "patch_webhook",
        "parameters": [
          {
            "name": "uuid",
            "in": "path",
            "description": "The universally unique identifier of the webhook",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WebhookSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Webhook updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookWithMetadataRedactedAuthorization"
                },
                "example": {
                  "uuid": "550e8400-e29b-41d4-a716-446655440000",
                  "url": "https://your.site/on-tasks-completed",
                  "headers": {
                    "Authorization": "Bearer a-secret-token"
                  },
                  "isEditable": true
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "webhooks.update",
              "webhooks.*",
              "*"
            ]
          }
        ]
      }
    }
  },
  "components": {
    "schemas": {
      "Action": {
        "type": "string",
        "enum": [
          "*",
          "search",
          "documents.*",
          "documents.add",
          "documents.get",
          "documents.delete",
          "indexes.*",
          "indexes.create",
          "indexes.get",
          "indexes.update",
          "indexes.delete",
          "indexes.swap",
          "tasks.*",
          "tasks.cancel",
          "tasks.delete",
          "tasks.get",
          "settings.*",
          "settings.get",
          "settings.update",
          "stats.*",
          "stats.get",
          "metrics.*",
          "metrics.get",
          "dumps.*",
          "dumps.create",
          "snapshots.*",
          "snapshots.create",
          "version",
          "keys.create",
          "keys.get",
          "keys.update",
          "keys.delete",
          "experimental.get",
          "experimental.update",
          "export",
          "network.get",
          "network.update",
          "chatCompletions",
          "chats.*",
          "chats.get",
          "chats.delete",
          "chatsSettings.*",
          "chatsSettings.get",
          "chatsSettings.update",
          "*.get",
          "webhooks.get",
          "webhooks.update",
          "webhooks.delete",
          "webhooks.create",
          "webhooks.*",
          "indexes.compact"
        ]
      },
      "AllBatches": {
        "type": "object",
        "required": [
          "results",
          "total",
          "limit"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BatchView"
            }
          },
          "total": {
            "type": "integer",
            "format": "u-int64",
            "minimum": 0
          },
          "limit": {
            "type": "integer",
            "format": "u-int32",
            "minimum": 0
          },
          "from": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int32",
            "minimum": 0
          },
          "next": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int32",
            "minimum": 0
          }
        }
      },
      "AllTasks": {
        "type": "object",
        "required": [
          "results",
          "total",
          "limit"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TaskView"
            },
            "description": "The list of tasks that matched the filter."
          },
          "total": {
            "type": "integer",
            "format": "u-int64",
            "description": "Total number of browsable results using offset/limit parameters for the given resource.",
            "minimum": 0
          },
          "limit": {
            "type": "integer",
            "format": "u-int32",
            "description": "Limit given for the query. If limit is not provided as a query parameter, this parameter displays the default limit value.",
            "minimum": 0
          },
          "from": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int32",
            "description": "The first task uid returned.",
            "minimum": 0
          },
          "next": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int32",
            "description": "Represents the value to send in from to fetch the next slice of the results. The first item for the next slice starts at this exact number. When the returned value is null, it means that all the data have been browsed in the given order.",
            "minimum": 0
          }
        }
      },
      "AttributePatterns": {
        "type": "object",
        "required": [
          "patterns"
        ],
        "properties": {
          "patterns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "example": [
              "title",
              "overview_*",
              "release_date"
            ]
          }
        }
      },
      "BTreeMap": {
        "type": "object",
        "additionalProperties": {
          "type": "array",
          "items": {
            "type": "object",
            "required": [
              "start",
              "length"
            ],
            "properties": {
              "start": {
                "type": "integer",
                "minimum": 0
              },
              "length": {
                "type": "integer",
                "minimum": 0
              },
              "indices": {
                "type": [
                  "array",
                  "null"
                ],
                "items": {
                  "type": "integer",
                  "minimum": 0
                }
              }
            }
          }
        },
        "propertyNames": {
          "type": "string"
        }
      },
      "BatchStats": {
        "type": "object",
        "required": [
          "totalNbTasks",
          "status",
          "types",
          "indexUids"
        ],
        "properties": {
          "totalNbTasks": {
            "$ref": "#/components/schemas/u32"
          },
          "status": {
            "type": "object",
            "additionalProperties": {
              "type": "integer",
              "format": "u-int32",
              "minimum": 0
            },
            "propertyNames": {
              "type": "string",
              "description": "The status of a task.",
              "enum": [
                "enqueued",
                "processing",
                "succeeded",
                "failed",
                "canceled"
              ],
              "example": "processing"
            }
          },
          "types": {
            "type": "object",
            "additionalProperties": {
              "type": "integer",
              "format": "u-int32",
              "minimum": 0
            },
            "propertyNames": {
              "type": "string",
              "description": "The type of the task.",
              "enum": [
                "documentAdditionOrUpdate",
                "documentEdition",
                "documentDeletion",
                "settingsUpdate",
                "indexCreation",
                "indexDeletion",
                "indexUpdate",
                "indexSwap",
                "taskCancelation",
                "taskDeletion",
                "dumpCreation",
                "snapshotCreation",
                "export",
                "upgradeDatabase",
                "indexCompaction"
              ],
              "example": [
                "documentAdditionOrUpdate",
                "documentEdition",
                "documentDeletion",
                "settingsUpdate",
                "indexCreation",
                "indexDeletion",
                "indexUpdate",
                "indexSwap",
                "taskCancelation",
                "taskDeletion",
                "dumpCreation",
                "snapshotCreation",
                "export",
                "upgradeDatabase",
                "indexCompaction"
              ]
            }
          },
          "indexUids": {
            "type": "object",
            "additionalProperties": {
              "type": "integer",
              "format": "u-int32",
              "minimum": 0
            },
            "propertyNames": {
              "type": "string"
            }
          },
          "progressTrace": {
            "type": "object",
            "additionalProperties": {},
            "propertyNames": {
              "type": "string"
            }
          },
          "writeChannelCongestion": {
            "type": [
              "object",
              "null"
            ],
            "additionalProperties": {},
            "propertyNames": {
              "type": "string"
            }
          },
          "internalDatabaseSizes": {
            "type": "object",
            "additionalProperties": {},
            "propertyNames": {
              "type": "string"
            }
          }
        }
      },
      "BatchStatsView": {
        "allOf": [
          {
            "$ref": "#/components/schemas/BatchStats"
          },
          {
            "type": "object",
            "properties": {
              "embedderRequests": {
                "$ref": "#/components/schemas/EmbedderStatsView"
              }
            }
          }
        ]
      },
      "BatchView": {
        "type": "object",
        "required": [
          "uid",
          "details",
          "stats"
        ],
        "properties": {
          "uid": {
            "$ref": "#/components/schemas/u32"
          },
          "progress": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/ProgressView"
              }
            ]
          },
          "details": {
            "$ref": "#/components/schemas/DetailsView"
          },
          "stats": {
            "$ref": "#/components/schemas/BatchStatsView"
          },
          "duration": {
            "type": [
              "string",
              "null"
            ]
          },
          "startedAt": {
            "type": "string",
            "format": "date-time"
          },
          "finishedAt": {
            "type": [
              "string",
              "null"
            ],
            "format": "date-time"
          },
          "batchStrategy": {
            "type": "string"
          }
        }
      },
      "BrowseQuery": {
        "type": "object",
        "required": [
          "offset",
          "limit",
          "retrieveVectors"
        ],
        "properties": {
          "offset": {
            "type": "integer",
            "example": 150,
            "minimum": 0
          },
          "limit": {
            "type": "integer",
            "default": 20,
            "example": 1,
            "minimum": 0
          },
          "fields": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "example": [
              "title, description"
            ]
          },
          "retrieveVectors": {
            "type": "boolean",
            "example": true
          },
          "ids": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "example": [
              "cody",
              "finn",
              "brandy",
              "gambit"
            ]
          },
          "filter": {},
          "sort": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "example": [
              "title:asc",
              "rating:desc"
            ]
          }
        }
      },
      "ChatSearchParams": {
        "type": "object",
        "properties": {
          "hybrid": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/HybridQuery"
              }
            ]
          },
          "limit": {
            "type": [
              "integer",
              "null"
            ],
            "minimum": 0
          },
          "sort": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            }
          },
          "distinct": {
            "type": [
              "string",
              "null"
            ]
          },
          "matchingStrategy": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/MatchingStrategy"
              }
            ]
          },
          "attributesToSearchOn": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            }
          },
          "rankingScoreThreshold": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/RankingScoreThreshold"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "ChatSettings": {
        "type": "object",
        "properties": {
          "description": {
            "type": [
              "string",
              "null"
            ]
          },
          "documentTemplate": {
            "type": [
              "string",
              "null"
            ],
            "description": "A liquid template used to render documents to a text that can be embedded.\n\nMeillisearch interpolates the template for each document and sends the resulting text to the embedder.\nThe embedder then generates document vectors based on this text."
          },
          "documentTemplateMaxBytes": {
            "type": [
              "integer",
              "null"
            ],
            "description": "Rendered texts are truncated to this size. Defaults to 400.",
            "minimum": 0
          },
          "searchParameters": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/ChatSearchParams",
                "description": "The search parameters to use for the LLM."
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Code": {
        "type": "string",
        "enum": [
          "api_key_already_exists",
          "api_key_not_found",
          "bad_parameter",
          "bad_request",
          "database_size_limit_reached",
          "document_not_found",
          "dump_already_processing",
          "dump_not_found",
          "dump_process_failed",
          "duplicate_index_found",
          "immutable_api_key_actions",
          "immutable_api_key_created_at",
          "immutable_api_key_expires_at",
          "immutable_api_key_indexes",
          "immutable_api_key_key",
          "immutable_api_key_uid",
          "immutable_api_key_updated_at",
          "immutable_index_created_at",
          "immutable_index_updated_at",
          "index_already_exists",
          "index_creation_failed",
          "index_not_found",
          "index_primary_key_already_exists",
          "index_primary_key_multiple_candidates_found",
          "index_primary_key_no_candidate_found",
          "internal",
          "invalid_api_key",
          "invalid_api_key_actions",
          "invalid_api_key_description",
          "invalid_api_key_expires_at",
          "invalid_api_key_indexes",
          "invalid_api_key_limit",
          "invalid_api_key_name",
          "invalid_api_key_offset",
          "invalid_api_key_uid",
          "invalid_content_type",
          "invalid_document_csv_delimiter",
          "invalid_document_fields",
          "invalid_document_retrieve_vectors",
          "missing_document_filter",
          "missing_document_edition_function",
          "inconsistent_document_change_headers",
          "invalid_document_filter",
          "invalid_document_sort",
          "invalid_document_geo_field",
          "invalid_document_geojson_field",
          "invalid_header_value",
          "invalid_vector_dimensions",
          "invalid_vectors_type",
          "invalid_document_id",
          "invalid_document_ids",
          "invalid_document_limit",
          "invalid_document_offset",
          "invalid_search_embedder",
          "invalid_similar_embedder",
          "invalid_search_hybrid_query",
          "invalid_index_limit",
          "invalid_index_offset",
          "invalid_index_primary_key",
          "invalid_index_custom_metadata",
          "invalid_index_uid",
          "invalid_multi_search_facets",
          "invalid_multi_search_facets_by_index",
          "invalid_multi_search_facet_order",
          "invalid_multi_search_query_personalization",
          "invalid_multi_search_federated",
          "invalid_multi_search_federation_options",
          "invalid_multi_search_max_values_per_facet",
          "invalid_multi_search_merge_facets",
          "invalid_multi_search_query_facets",
          "invalid_multi_search_query_pagination",
          "invalid_multi_search_query_ranking_rules",
          "invalid_multi_search_query_position",
          "invalid_multi_search_remote",
          "invalid_multi_search_weight",
          "invalid_network_remotes",
          "invalid_network_self",
          "invalid_network_sharding",
          "invalid_network_search_api_key",
          "invalid_network_write_api_key",
          "invalid_network_url",
          "invalid_search_attributes_to_search_on",
          "invalid_search_attributes_to_crop",
          "invalid_search_attributes_to_highlight",
          "invalid_similar_attributes_to_retrieve",
          "invalid_similar_retrieve_vectors",
          "invalid_search_attributes_to_retrieve",
          "invalid_search_ranking_score_threshold",
          "invalid_similar_ranking_score_threshold",
          "invalid_search_retrieve_vectors",
          "invalid_search_crop_length",
          "invalid_search_crop_marker",
          "invalid_search_facets",
          "invalid_search_semantic_ratio",
          "invalid_search_locales",
          "invalid_facet_search_exhaustive_facet_count",
          "invalid_facet_search_facet_name",
          "invalid_similar_id",
          "invalid_search_filter",
          "invalid_similar_filter",
          "invalid_search_highlight_post_tag",
          "invalid_search_highlight_pre_tag",
          "invalid_search_hits_per_page",
          "invalid_similar_limit",
          "invalid_search_limit",
          "invalid_search_matching_strategy",
          "invalid_similar_offset",
          "invalid_search_offset",
          "invalid_search_page",
          "invalid_search_q",
          "invalid_facet_search_query",
          "invalid_facet_search_name",
          "facet_search_disabled",
          "invalid_search_vector",
          "invalid_search_media",
          "invalid_search_show_matches_position",
          "invalid_search_show_ranking_score",
          "invalid_similar_show_ranking_score",
          "invalid_search_show_ranking_score_details",
          "invalid_similar_show_ranking_score_details",
          "invalid_search_sort",
          "invalid_search_distinct",
          "invalid_search_personalize",
          "invalid_search_personalize_user_context",
          "invalid_search_media_and_vector",
          "invalid_settings_displayed_attributes",
          "invalid_settings_distinct_attribute",
          "invalid_settings_proximity_precision",
          "invalid_settings_facet_search",
          "invalid_settings_prefix_search",
          "invalid_settings_faceting",
          "invalid_settings_filterable_attributes",
          "invalid_settings_pagination",
          "invalid_settings_search_cutoff_ms",
          "invalid_settings_embedders",
          "invalid_settings_ranking_rules",
          "invalid_settings_searchable_attributes",
          "invalid_settings_sortable_attributes",
          "invalid_settings_stop_words",
          "invalid_settings_non_separator_tokens",
          "invalid_settings_separator_tokens",
          "invalid_settings_dictionary",
          "invalid_settings_synonyms",
          "invalid_settings_typo_tolerance",
          "invalid_settings_localized_attributes",
          "invalid_state",
          "invalid_store_file",
          "invalid_swap_duplicate_index_found",
          "invalid_swap_indexes",
          "invalid_swap_rename",
          "invalid_task_after_enqueued_at",
          "invalid_task_after_finished_at",
          "invalid_task_after_started_at",
          "invalid_task_before_enqueued_at",
          "invalid_task_before_finished_at",
          "invalid_task_before_started_at",
          "invalid_task_canceled_by",
          "invalid_task_from",
          "invalid_task_limit",
          "invalid_task_reverse",
          "invalid_task_statuses",
          "invalid_task_types",
          "invalid_task_uids",
          "invalid_batch_uids",
          "io_error",
          "feature_not_enabled",
          "malformed_payload",
          "max_fields_limit_exceeded",
          "missing_api_key_actions",
          "missing_api_key_expires_at",
          "missing_api_key_indexes",
          "missing_authorization_header",
          "missing_content_type",
          "missing_document_id",
          "missing_facet_search_facet_name",
          "missing_index_uid",
          "missing_master_key",
          "missing_network_url",
          "missing_payload",
          "missing_search_hybrid",
          "missing_swap_indexes",
          "missing_task_filters",
          "no_space_left_on_device",
          "payload_too_large",
          "remote_bad_response",
          "remote_bad_request",
          "remote_could_not_send_request",
          "remote_invalid_api_key",
          "remote_remote_error",
          "remote_timeout",
          "too_many_search_requests",
          "task_not_found",
          "task_file_not_found",
          "batch_not_found",
          "too_many_open_files",
          "too_many_vectors",
          "unretrievable_document",
          "unretrievable_error_code",
          "unsupported_media_type",
          "invalid_s3_snapshot_request",
          "invalid_s3_snapshot_parameters",
          "s3_snapshot_server_error",
          "vector_embedding_error",
          "not_found_similar_id",
          "invalid_document_edition_context",
          "invalid_document_edition_function_filter",
          "edit_documents_by_function_error",
          "invalid_settings_index_chat",
          "invalid_settings_vector_store",
          "invalid_export_url",
          "invalid_export_api_key",
          "invalid_export_payload_size",
          "invalid_export_indexes_patterns",
          "invalid_export_index_filter",
          "invalid_export_index_override_settings",
          "unimplemented_external_function_calling",
          "unimplemented_non_streaming_chat_completions",
          "unimplemented_multi_choice_chat_completions",
          "chat_not_found",
          "invalid_chat_setting_document_template",
          "invalid_chat_completion_org_id",
          "invalid_chat_completion_project_id",
          "invalid_chat_completion_api_version",
          "invalid_chat_completion_deployment_id",
          "invalid_chat_completion_source",
          "invalid_chat_completion_base_api",
          "invalid_chat_completion_api_key",
          "invalid_chat_completion_prompts",
          "invalid_chat_completion_system_prompt",
          "invalid_chat_completion_search_description_prompt",
          "invalid_chat_completion_search_query_param_prompt",
          "invalid_chat_completion_search_filter_param_prompt",
          "invalid_chat_completion_search_index_uid_param_prompt",
          "invalid_chat_completion_pre_query_prompt",
          "requires_enterprise_edition",
          "invalid_webhooks",
          "invalid_webhook_url",
          "invalid_webhook_headers",
          "immutable_webhook",
          "invalid_webhook_uuid",
          "webhook_not_found",
          "immutable_webhook_uuid",
          "immutable_webhook_is_editable"
        ]
      },
      "ComputedFacets": {
        "type": "object",
        "required": [
          "distribution",
          "stats"
        ],
        "properties": {
          "distribution": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "additionalProperties": {
                "type": "integer",
                "format": "u-int64",
                "minimum": 0
              },
              "propertyNames": {
                "type": "string"
              }
            },
            "propertyNames": {
              "type": "string"
            }
          },
          "stats": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/FacetStats"
            },
            "propertyNames": {
              "type": "string"
            }
          }
        }
      },
      "CreateApiKey": {
        "type": "object",
        "required": [
          "uid",
          "actions",
          "indexes"
        ],
        "properties": {
          "description": {
            "type": [
              "string",
              "null"
            ],
            "description": "A description for the key. `null` if empty.",
            "example": null
          },
          "name": {
            "type": [
              "string",
              "null"
            ],
            "description": "A human-readable name for the key. `null` if empty.",
            "example": "Indexing Products API key"
          },
          "uid": {
            "type": "string",
            "format": "uuid",
            "description": "A uuid v4 to identify the API Key. If not specified, it's generated by Meilisearch.",
            "example": null
          },
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Action"
            },
            "description": "A list of actions permitted for the key. `[\"*\"]` for all actions. The `*` character can be used as a wildcard when located at the last position. e.g. `documents.*` to authorize access on all documents endpoints.",
            "example": [
              "documents.add"
            ]
          },
          "indexes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of accessible indexes permitted for the key. `[\"*\"]` for all indexes. The `*` character can be used as a wildcard when located at the last position. e.g. `products_*` to allow access to all indexes whose names start with `products_`.",
            "example": [
              "products"
            ]
          },
          "expiresAt": {
            "type": [
              "string",
              "null"
            ],
            "format": "date-time",
            "description": "Represent the expiration date and time as RFC 3339 format. `null` equals to no expiration time."
          }
        }
      },
      "DetailsExportIndexSettings": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ExportIndexSettings"
          },
          {
            "type": "object",
            "properties": {
              "matchedDocuments": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int64",
                "minimum": 0
              }
            }
          }
        ]
      },
      "DetailsView": {
        "allOf": [
          {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/Settings_Unchecked",
                "description": "[Learn more about the settings in this guide](https://www.meilisearch.com/docs/reference/api/settings)."
              }
            ]
          },
          {
            "type": "object",
            "properties": {
              "receivedDocuments": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int64",
                "description": "Number of documents received for documentAdditionOrUpdate task.",
                "minimum": 0
              },
              "indexedDocuments": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int64",
                "description": "Number of documents finally indexed for documentAdditionOrUpdate task or a documentAdditionOrUpdate batch of tasks.",
                "minimum": 0
              },
              "editedDocuments": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int64",
                "description": "Number of documents edited for editDocumentByFunction task.",
                "minimum": 0
              },
              "primaryKey": {
                "type": [
                  "string",
                  "null"
                ],
                "description": "Value for the primaryKey field encountered if any for indexCreation or indexUpdate task."
              },
              "providedIds": {
                "type": [
                  "integer",
                  "null"
                ],
                "description": "Number of provided document ids for the documentDeletion task.",
                "minimum": 0
              },
              "deletedDocuments": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int64",
                "description": "Number of documents finally deleted for documentDeletion and indexDeletion tasks.",
                "minimum": 0
              },
              "matchedTasks": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int64",
                "description": "Number of tasks that match the request for taskCancelation or taskDeletion tasks.",
                "minimum": 0
              },
              "canceledTasks": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int64",
                "description": "Number of tasks canceled for taskCancelation.",
                "minimum": 0
              },
              "deletedTasks": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int64",
                "description": "Number of tasks deleted for taskDeletion.",
                "minimum": 0
              },
              "originalFilter": {
                "type": [
                  "string",
                  "null"
                ],
                "description": "Original filter query for taskCancelation or taskDeletion tasks."
              },
              "dumpUid": {
                "type": [
                  "string",
                  "null"
                ],
                "description": "Identifier generated for the dump for dumpCreation task."
              },
              "context": {
                "type": [
                  "object",
                  "null"
                ]
              },
              "function": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "swaps": {
                "type": [
                  "array",
                  "null"
                ],
                "items": {
                  "$ref": "#/components/schemas/IndexSwap"
                }
              },
              "upgradeFrom": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "upgradeTo": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "url": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "apiKey": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "payloadSize": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "indexes": {
                "type": [
                  "object",
                  "null"
                ],
                "additionalProperties": {
                  "$ref": "#/components/schemas/DetailsExportIndexSettings"
                },
                "propertyNames": {
                  "type": "string"
                }
              },
              "oldIndexUid": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "newIndexUid": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "preCompactionSize": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "postCompactionSize": {
                "type": [
                  "string",
                  "null"
                ]
              }
            }
          }
        ]
      },
      "DistributionShift": {
        "type": "object",
        "description": "Describes the mean and sigma of distribution of embedding similarity in the embedding space.\n\nThe intended use is to make the similarity score more comparable to the regular ranking score.\nThis allows to correct effects where results are too \"packed\" around a certain value.",
        "required": [
          "current_mean",
          "current_sigma"
        ],
        "properties": {
          "current_mean": {
            "type": "number",
            "format": "float",
            "description": "Value where the results are \"packed\".\n\nSimilarity scores are translated so that they are packed around 0.5 instead"
          },
          "current_sigma": {
            "type": "number",
            "format": "float",
            "description": "standard deviation of a similarity score.\n\nSet below 0.4 to make the results less packed around the mean, and above 0.4 to make them more packed."
          }
        }
      },
      "DocumentDeletionByFilter": {
        "type": "object",
        "required": [
          "filter"
        ],
        "properties": {
          "filter": {}
        }
      },
      "DocumentEditionByFunction": {
        "type": "object",
        "required": [
          "function"
        ],
        "properties": {
          "filter": {
            "description": "A string containing a RHAI function."
          },
          "context": {
            "description": "A string containing a filter expression."
          },
          "function": {
            "type": "string",
            "description": "An object with data Meilisearch should make available for the editing function."
          }
        }
      },
      "EmbedderSource": {
        "type": "string",
        "enum": [
          "openAi",
          "huggingFace",
          "ollama",
          "userProvided",
          "rest",
          "composite"
        ]
      },
      "EmbedderStatsView": {
        "type": "object",
        "required": [
          "total",
          "failed"
        ],
        "properties": {
          "total": {
            "type": "integer",
            "minimum": 0
          },
          "failed": {
            "type": "integer",
            "minimum": 0
          },
          "lastError": {
            "type": [
              "string",
              "null"
            ]
          }
        }
      },
      "ErrorType": {
        "type": "string",
        "enum": [
          "internal",
          "invalid_request",
          "auth",
          "system"
        ]
      },
      "Export": {
        "type": "object",
        "properties": {
          "url": {
            "type": [
              "string",
              "null"
            ],
            "example": "https://ms-1234.heaven.meilisearch.com"
          },
          "apiKey": {
            "type": [
              "string",
              "null"
            ],
            "example": "1234abcd"
          },
          "payloadSize": {
            "type": [
              "string",
              "null"
            ],
            "example": "24MiB"
          },
          "indexes": {
            "type": [
              "object",
              "null"
            ],
            "additionalProperties": {
              "$ref": "#/components/schemas/ExportIndexSettings"
            },
            "propertyNames": {
              "type": "string"
            },
            "example": {
              "*": {
                "filter": null
              }
            }
          }
        }
      },
      "ExportIndexSettings": {
        "type": "object",
        "properties": {
          "filter": {
            "type": [
              "string",
              "null"
            ],
            "example": "genres = action"
          },
          "overrideSettings": {
            "type": [
              "boolean",
              "null"
            ],
            "example": true
          }
        }
      },
      "FacetSearchQuery": {
        "type": "object",
        "required": [
          "facet_name",
          "matching_strategy"
        ],
        "properties": {
          "facet_query": {
            "type": [
              "string",
              "null"
            ]
          },
          "facet_name": {
            "type": "string"
          },
          "q": {
            "type": [
              "string",
              "null"
            ]
          },
          "vector": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "number",
              "format": "float"
            }
          },
          "media": {},
          "hybrid": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/HybridQuery"
              }
            ]
          },
          "filter": {},
          "matching_strategy": {
            "$ref": "#/components/schemas/MatchingStrategy"
          },
          "attributes_to_search_on": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            }
          },
          "ranking_score_threshold": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/RankingScoreThreshold"
              }
            ]
          },
          "locales": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "$ref": "#/components/schemas/Locale"
            }
          },
          "exhaustive_facet_count": {
            "type": [
              "boolean",
              "null"
            ]
          }
        }
      },
      "FacetStats": {
        "type": "object",
        "required": [
          "min",
          "max"
        ],
        "properties": {
          "min": {
            "type": "number",
            "format": "double"
          },
          "max": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "FacetValuesSort": {
        "type": "string",
        "enum": [
          "alpha",
          "count"
        ]
      },
      "FacetingSettings": {
        "type": "object",
        "properties": {
          "maxValuesPerFacet": {
            "type": [
              "integer",
              "null"
            ],
            "example": 10,
            "minimum": 0
          },
          "sortFacetValuesBy": {
            "type": [
              "object",
              "null"
            ],
            "additionalProperties": {
              "$ref": "#/components/schemas/FacetValuesSort"
            },
            "propertyNames": {
              "type": "string"
            },
            "example": {
              "genre": "count"
            }
          }
        },
        "additionalProperties": false
      },
      "FederatedFacets": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/components/schemas/ComputedFacets"
        },
        "propertyNames": {
          "type": "string"
        }
      },
      "FederatedSearch": {
        "type": "object",
        "required": [
          "queries"
        ],
        "properties": {
          "queries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchQueryWithIndex"
            }
          },
          "federation": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/Federation"
              }
            ]
          }
        }
      },
      "FederatedSearchResult": {
        "allOf": [
          {
            "$ref": "#/components/schemas/HitsInfo"
          },
          {
            "type": "object",
            "required": [
              "hits",
              "processingTimeMs"
            ],
            "properties": {
              "hits": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/SearchHit"
                }
              },
              "processingTimeMs": {
                "type": "integer",
                "minimum": 0
              },
              "queryVectors": {
                "type": [
                  "object",
                  "null"
                ],
                "additionalProperties": {
                  "$ref": "#/components/schemas/Vec"
                },
                "propertyNames": {
                  "type": "integer",
                  "minimum": 0
                }
              },
              "semanticHitCount": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int32",
                "minimum": 0
              },
              "facetDistribution": {
                "type": [
                  "object",
                  "null"
                ],
                "additionalProperties": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "integer",
                    "format": "u-int64",
                    "minimum": 0
                  },
                  "propertyNames": {
                    "type": "string"
                  }
                },
                "propertyNames": {
                  "type": "string"
                }
              },
              "facetStats": {
                "type": [
                  "object",
                  "null"
                ],
                "additionalProperties": {
                  "$ref": "#/components/schemas/FacetStats"
                },
                "propertyNames": {
                  "type": "string"
                }
              },
              "facetsByIndex": {
                "$ref": "#/components/schemas/FederatedFacets"
              },
              "requestUid": {
                "type": [
                  "string",
                  "null"
                ],
                "format": "uuid"
              },
              "metadata": {
                "type": [
                  "array",
                  "null"
                ],
                "items": {
                  "$ref": "#/components/schemas/SearchMetadata"
                }
              },
              "remoteErrors": {
                "type": [
                  "object",
                  "null"
                ],
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "propertyNames": {
                  "type": "string"
                }
              }
            }
          }
        ]
      },
      "Federation": {
        "type": "object",
        "required": [
          "limit",
          "offset",
          "facetsByIndex"
        ],
        "properties": {
          "limit": {
            "type": "integer",
            "minimum": 0
          },
          "offset": {
            "type": "integer",
            "minimum": 0
          },
          "facetsByIndex": {
            "type": "object",
            "additionalProperties": {
              "type": [
                "array",
                "null"
              ],
              "items": {
                "type": "string"
              }
            },
            "propertyNames": {
              "type": "string",
              "description": "An index uid is composed of only ascii alphanumeric characters, - and _, between 1 and 400\nbytes long",
              "example": "movies"
            }
          },
          "mergeFacets": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/MergeFacets"
              }
            ]
          }
        }
      },
      "FederationOptions": {
        "type": "object",
        "required": [
          "weight"
        ],
        "properties": {
          "weight": {
            "type": "number",
            "format": "double"
          },
          "remote": {
            "type": [
              "string",
              "null"
            ]
          },
          "queryPosition": {
            "type": [
              "integer",
              "null"
            ],
            "minimum": 0
          }
        }
      },
      "FilterFeatures": {
        "type": "object",
        "properties": {
          "equality": {
            "type": "boolean"
          },
          "comparison": {
            "type": "boolean"
          }
        },
        "additionalProperties": false
      },
      "FilterableAttributesFeatures": {
        "type": "object",
        "properties": {
          "facetSearch": {
            "type": "boolean"
          },
          "filter": {
            "$ref": "#/components/schemas/FilterFeatures"
          }
        },
        "additionalProperties": false
      },
      "FilterableAttributesPatterns": {
        "type": "object",
        "required": [
          "attributePatterns"
        ],
        "properties": {
          "attributePatterns": {
            "$ref": "#/components/schemas/AttributePatterns"
          },
          "features": {
            "$ref": "#/components/schemas/FilterableAttributesFeatures"
          }
        },
        "additionalProperties": false
      },
      "FilterableAttributesRule": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/FilterableAttributesPatterns"
          }
        ]
      },
      "GetLogs": {
        "type": "object",
        "required": [
          "target",
          "mode",
          "profileMemory"
        ],
        "properties": {
          "target": {
            "type": "string",
            "description": "Lets you specify which parts of the code you want to inspect and is formatted like that: code_part=log_level,code_part=log_level\n- If the `code_part` is missing, then the `log_level` will be applied to everything.\n- If the `log_level` is missing, then the `code_part` will be selected in `info` log level.",
            "default": "info",
            "example": "milli=trace,index_scheduler,actix_web=off"
          },
          "mode": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/LogMode",
                "description": "Lets you customize the format of the logs."
              }
            ],
            "default": "Human"
          },
          "profileMemory": {
            "type": "boolean",
            "description": "A boolean to indicate if you want to profile the memory as well. This is only useful while using the `profile` mode.\nBe cautious, though; it slows down the engine a lot.",
            "default": false
          }
        }
      },
      "HealthResponse": {
        "type": "object",
        "required": [
          "status"
        ],
        "properties": {
          "status": {
            "$ref": "#/components/schemas/HealthStatus",
            "description": "The status of the instance."
          }
        }
      },
      "HealthStatus": {
        "type": "string",
        "enum": [
          "available"
        ]
      },
      "HitsInfo": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "hitsPerPage",
              "page",
              "totalPages",
              "totalHits"
            ],
            "properties": {
              "hitsPerPage": {
                "type": "integer",
                "minimum": 0
              },
              "page": {
                "type": "integer",
                "minimum": 0
              },
              "totalPages": {
                "type": "integer",
                "minimum": 0
              },
              "totalHits": {
                "type": "integer",
                "minimum": 0
              }
            }
          },
          {
            "type": "object",
            "required": [
              "limit",
              "offset",
              "estimatedTotalHits"
            ],
            "properties": {
              "limit": {
                "type": "integer",
                "minimum": 0
              },
              "offset": {
                "type": "integer",
                "minimum": 0
              },
              "estimatedTotalHits": {
                "type": "integer",
                "minimum": 0
              }
            }
          }
        ]
      },
      "HybridQuery": {
        "type": "object",
        "required": [
          "embedder"
        ],
        "properties": {
          "semanticRatio": {
            "type": "number",
            "format": "float"
          },
          "embedder": {
            "type": "string"
          }
        }
      },
      "IndexCreateRequest": {
        "type": "object",
        "required": [
          "uid"
        ],
        "properties": {
          "uid": {
            "$ref": "#/components/schemas/IndexUid",
            "description": "The name of the index"
          },
          "primaryKey": {
            "type": [
              "string",
              "null"
            ],
            "description": "The primary key of the index",
            "example": "id"
          }
        }
      },
      "IndexStats": {
        "type": "object",
        "description": "Stats of an `Index`, as known to the `stats` route.",
        "required": [
          "numberOfDocuments",
          "rawDocumentDbSize",
          "avgDocumentSize",
          "isIndexing",
          "fieldDistribution"
        ],
        "properties": {
          "numberOfDocuments": {
            "type": "integer",
            "format": "u-int64",
            "description": "Number of documents in the index",
            "minimum": 0
          },
          "rawDocumentDbSize": {
            "type": "integer",
            "format": "u-int64",
            "description": "Size of the documents database, in bytes.",
            "minimum": 0
          },
          "avgDocumentSize": {
            "type": "integer",
            "format": "u-int64",
            "description": "Average size of a document in the documents database.",
            "minimum": 0
          },
          "isIndexing": {
            "type": "boolean",
            "description": "Whether or not the index is currently ingesting document"
          },
          "numberOfEmbeddings": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int64",
            "description": "Number of embeddings in the index",
            "minimum": 0
          },
          "numberOfEmbeddedDocuments": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int64",
            "description": "Number of embedded documents in the index",
            "minimum": 0
          },
          "fieldDistribution": {
            "type": "object",
            "description": "Association of every field name with the number of times it occurs in the documents.",
            "additionalProperties": {
              "type": "integer",
              "format": "u-int64",
              "minimum": 0
            },
            "propertyNames": {
              "type": "string"
            }
          }
        }
      },
      "IndexSwap": {
        "type": "object",
        "required": [
          "indexes"
        ],
        "properties": {
          "indexes": {
            "type": "array",
            "items": false,
            "prefixItems": [
              {
                "type": "string"
              },
              {
                "type": "string"
              }
            ]
          },
          "rename": {
            "type": "boolean"
          }
        }
      },
      "IndexUid": {
        "type": "string",
        "description": "An index uid is composed of only ascii alphanumeric characters, - and _, between 1 and 400\nbytes long",
        "example": "movies"
      },
      "IndexView": {
        "type": "object",
        "required": [
          "uid",
          "createdAt",
          "updatedAt"
        ],
        "properties": {
          "uid": {
            "type": "string",
            "description": "Unique identifier for the index"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "An `RFC 3339` format for date/time/duration."
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "An `RFC 3339` format for date/time/duration."
          },
          "primaryKey": {
            "type": [
              "string",
              "null"
            ],
            "description": "Custom primaryKey for documents"
          }
        }
      },
      "KeyView": {
        "type": "object",
        "required": [
          "key",
          "uid",
          "actions",
          "indexes",
          "createdAt",
          "updatedAt"
        ],
        "properties": {
          "name": {
            "type": [
              "string",
              "null"
            ],
            "description": "The name of the API Key if any"
          },
          "description": {
            "type": [
              "string",
              "null"
            ],
            "description": "The description of the API Key if any"
          },
          "key": {
            "type": "string",
            "description": "The actual API Key you can send to Meilisearch"
          },
          "uid": {
            "type": "string",
            "format": "uuid",
            "description": "The `Uuid` specified while creating the key or autogenerated by Meilisearch."
          },
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Action"
            },
            "description": "The actions accessible with this key."
          },
          "indexes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The indexes accessible with this key."
          },
          "expiresAt": {
            "type": [
              "string",
              "null"
            ],
            "format": "date-time",
            "description": "The expiration date of the key. Once this timestamp is exceeded the key is not deleted but cannot be used anymore."
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "The date of creation of this API Key.",
            "readOnly": true
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "The date of the last update made on this key.",
            "readOnly": true
          }
        }
      },
      "Kind": {
        "type": "string",
        "description": "The type of the task.",
        "enum": [
          "documentAdditionOrUpdate",
          "documentEdition",
          "documentDeletion",
          "settingsUpdate",
          "indexCreation",
          "indexDeletion",
          "indexUpdate",
          "indexSwap",
          "taskCancelation",
          "taskDeletion",
          "dumpCreation",
          "snapshotCreation",
          "export",
          "upgradeDatabase",
          "indexCompaction"
        ],
        "example": [
          "documentAdditionOrUpdate",
          "documentEdition",
          "documentDeletion",
          "settingsUpdate",
          "indexCreation",
          "indexDeletion",
          "indexUpdate",
          "indexSwap",
          "taskCancelation",
          "taskDeletion",
          "dumpCreation",
          "snapshotCreation",
          "export",
          "upgradeDatabase",
          "indexCompaction"
        ]
      },
      "Locale": {
        "type": "string",
        "enum": [
          "af",
          "ak",
          "am",
          "ar",
          "az",
          "be",
          "bn",
          "bg",
          "ca",
          "cs",
          "da",
          "de",
          "el",
          "en",
          "eo",
          "et",
          "fi",
          "fr",
          "gu",
          "he",
          "hi",
          "hr",
          "hu",
          "hy",
          "id",
          "it",
          "jv",
          "ja",
          "kn",
          "ka",
          "km",
          "ko",
          "la",
          "lv",
          "lt",
          "ml",
          "mr",
          "mk",
          "my",
          "ne",
          "nl",
          "nb",
          "or",
          "pa",
          "fa",
          "pl",
          "pt",
          "ro",
          "ru",
          "si",
          "sk",
          "sl",
          "sn",
          "es",
          "sr",
          "sv",
          "ta",
          "te",
          "tl",
          "th",
          "tk",
          "tr",
          "uk",
          "ur",
          "uz",
          "vi",
          "yi",
          "zh",
          "zu",
          "afr",
          "aka",
          "amh",
          "ara",
          "aze",
          "bel",
          "ben",
          "bul",
          "cat",
          "ces",
          "dan",
          "deu",
          "ell",
          "eng",
          "epo",
          "est",
          "fin",
          "fra",
          "guj",
          "heb",
          "hin",
          "hrv",
          "hun",
          "hye",
          "ind",
          "ita",
          "jav",
          "jpn",
          "kan",
          "kat",
          "khm",
          "kor",
          "lat",
          "lav",
          "lit",
          "mal",
          "mar",
          "mkd",
          "mya",
          "nep",
          "nld",
          "nob",
          "ori",
          "pan",
          "pes",
          "pol",
          "por",
          "ron",
          "rus",
          "sin",
          "slk",
          "slv",
          "sna",
          "spa",
          "srp",
          "swe",
          "tam",
          "tel",
          "tgl",
          "tha",
          "tuk",
          "tur",
          "ukr",
          "urd",
          "uzb",
          "vie",
          "yid",
          "zho",
          "zul",
          "cmn"
        ]
      },
      "LocalizedAttributesRuleView": {
        "type": "object",
        "required": [
          "attributePatterns",
          "locales"
        ],
        "properties": {
          "attributePatterns": {
            "$ref": "#/components/schemas/AttributePatterns"
          },
          "locales": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Locale"
            }
          }
        }
      },
      "LogMode": {
        "type": "string",
        "enum": [
          "human",
          "json",
          "profile"
        ]
      },
      "MatchingStrategy": {
        "type": "string",
        "description": "This is unfortunately a duplication of the struct in <meilisearch/src/search/mod.rs>.\nThe reason why it is duplicated is because milli cannot depend on meilisearch. It would be cyclic imports.",
        "enum": [
          "last",
          "all",
          "frequency"
        ]
      },
      "MergeFacets": {
        "type": "object",
        "properties": {
          "maxValuesPerFacet": {
            "type": [
              "integer",
              "null"
            ],
            "minimum": 0
          }
        }
      },
      "MinWordSizeTyposSetting": {
        "type": "object",
        "properties": {
          "oneTypo": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int8",
            "example": 5,
            "minimum": 0
          },
          "twoTypos": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int8",
            "example": 9,
            "minimum": 0
          }
        },
        "additionalProperties": false
      },
      "Network": {
        "type": "object",
        "properties": {
          "remotes": {
            "type": [
              "object",
              "null"
            ],
            "additionalProperties": {
              "$ref": "#/components/schemas/Remote"
            },
            "propertyNames": {
              "type": "string"
            },
            "example": "http://localhost:7700"
          },
          "self": {
            "type": [
              "string",
              "null"
            ],
            "example": "ms-00"
          },
          "sharding": {
            "type": [
              "boolean",
              "null"
            ],
            "example": true
          }
        }
      },
      "Origin": {
        "type": "object",
        "required": [
          "remoteName",
          "taskUid"
        ],
        "properties": {
          "remoteName": {
            "type": "string"
          },
          "taskUid": {
            "type": "integer",
            "minimum": 0
          }
        }
      },
      "OverridePooling": {
        "type": "string",
        "enum": [
          "useModel",
          "forceCls",
          "forceMean"
        ]
      },
      "PaginationSettings": {
        "type": "object",
        "properties": {
          "maxTotalHits": {
            "type": [
              "integer",
              "null"
            ],
            "example": 250,
            "minimum": 0
          }
        },
        "additionalProperties": false
      },
      "PaginationView_IndexView": {
        "type": "object",
        "required": [
          "results",
          "offset",
          "limit",
          "total"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "uid",
                "createdAt",
                "updatedAt"
              ],
              "properties": {
                "uid": {
                  "type": "string",
                  "description": "Unique identifier for the index"
                },
                "createdAt": {
                  "type": "string",
                  "format": "date-time",
                  "description": "An `RFC 3339` format for date/time/duration."
                },
                "updatedAt": {
                  "type": "string",
                  "format": "date-time",
                  "description": "An `RFC 3339` format for date/time/duration."
                },
                "primaryKey": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "description": "Custom primaryKey for documents"
                }
              }
            }
          },
          "offset": {
            "type": "integer",
            "minimum": 0
          },
          "limit": {
            "type": "integer",
            "minimum": 0
          },
          "total": {
            "type": "integer",
            "minimum": 0
          }
        }
      },
      "PaginationView_KeyView": {
        "type": "object",
        "required": [
          "results",
          "offset",
          "limit",
          "total"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "key",
                "uid",
                "actions",
                "indexes",
                "createdAt",
                "updatedAt"
              ],
              "properties": {
                "name": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "description": "The name of the API Key if any"
                },
                "description": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "description": "The description of the API Key if any"
                },
                "key": {
                  "type": "string",
                  "description": "The actual API Key you can send to Meilisearch"
                },
                "uid": {
                  "type": "string",
                  "format": "uuid",
                  "description": "The `Uuid` specified while creating the key or autogenerated by Meilisearch."
                },
                "actions": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Action"
                  },
                  "description": "The actions accessible with this key."
                },
                "indexes": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "The indexes accessible with this key."
                },
                "expiresAt": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "format": "date-time",
                  "description": "The expiration date of the key. Once this timestamp is exceeded the key is not deleted but cannot be used anymore."
                },
                "createdAt": {
                  "type": "string",
                  "format": "date-time",
                  "description": "The date of creation of this API Key.",
                  "readOnly": true
                },
                "updatedAt": {
                  "type": "string",
                  "format": "date-time",
                  "description": "The date of the last update made on this key.",
                  "readOnly": true
                }
              }
            }
          },
          "offset": {
            "type": "integer",
            "minimum": 0
          },
          "limit": {
            "type": "integer",
            "minimum": 0
          },
          "total": {
            "type": "integer",
            "minimum": 0
          }
        }
      },
      "PaginationView_Value": {
        "type": "object",
        "required": [
          "results",
          "offset",
          "limit",
          "total"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {}
          },
          "offset": {
            "type": "integer",
            "minimum": 0
          },
          "limit": {
            "type": "integer",
            "minimum": 0
          },
          "total": {
            "type": "integer",
            "minimum": 0
          }
        }
      },
      "PatchApiKey": {
        "type": "object",
        "properties": {
          "description": {
            "type": [
              "string",
              "null"
            ],
            "example": "This key is used to update documents in the products index"
          },
          "name": {
            "type": [
              "string",
              "null"
            ],
            "example": "Indexing Products API key"
          }
        }
      },
      "Personalize": {
        "type": "object",
        "required": [
          "user_context"
        ],
        "properties": {
          "user_context": {
            "type": "string"
          }
        }
      },
      "PrefixSearchSettings": {
        "type": "string",
        "enum": [
          "indexingTime",
          "disabled"
        ]
      },
      "ProgressStepView": {
        "type": "object",
        "required": [
          "currentStep",
          "finished",
          "total"
        ],
        "properties": {
          "currentStep": {
            "type": "string"
          },
          "finished": {
            "type": "integer",
            "format": "u-int32",
            "minimum": 0
          },
          "total": {
            "type": "integer",
            "format": "u-int32",
            "minimum": 0
          }
        }
      },
      "ProgressView": {
        "type": "object",
        "required": [
          "steps",
          "percentage"
        ],
        "properties": {
          "steps": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ProgressStepView"
            }
          },
          "percentage": {
            "type": "number",
            "format": "float"
          }
        }
      },
      "ProximityPrecisionView": {
        "type": "string",
        "enum": [
          "byWord",
          "byAttribute"
        ]
      },
      "RankingRuleView": {
        "oneOf": [
          {
            "type": "string",
            "description": "Sorted by decreasing number of matched query terms.\nQuery words at the front of an attribute is considered better than if it was at the back.",
            "enum": [
              "Words"
            ]
          },
          {
            "type": "string",
            "description": "Sorted by increasing number of typos.",
            "enum": [
              "Typo"
            ]
          },
          {
            "type": "string",
            "description": "Sorted by increasing distance between matched query terms.",
            "enum": [
              "Proximity"
            ]
          },
          {
            "type": "string",
            "description": "Documents with quey words contained in more important\nattributes are considered better.",
            "enum": [
              "Attribute"
            ]
          },
          {
            "type": "string",
            "description": "Dynamically sort at query time the documents. None, one or multiple Asc/Desc sortable\nattributes can be used in place of this criterion at query time.",
            "enum": [
              "Sort"
            ]
          },
          {
            "type": "string",
            "description": "Sorted by the similarity of the matched words with the query words.",
            "enum": [
              "Exactness"
            ]
          },
          {
            "type": "object",
            "description": "Sorted by the increasing value of the field specified.",
            "required": [
              "Asc"
            ],
            "properties": {
              "Asc": {
                "type": "string",
                "description": "Sorted by the increasing value of the field specified."
              }
            }
          },
          {
            "type": "object",
            "description": "Sorted by the decreasing value of the field specified.",
            "required": [
              "Desc"
            ],
            "properties": {
              "Desc": {
                "type": "string",
                "description": "Sorted by the decreasing value of the field specified."
              }
            }
          }
        ]
      },
      "RankingScoreThreshold": {
        "type": "number",
        "format": "double"
      },
      "Remote": {
        "type": "object",
        "properties": {
          "url": {
            "type": [
              "string",
              "null"
            ],
            "example": {
              "ms-0": {
                "url": "http://localhost:7700",
                "searchApiKey": null,
                "writeApiKey": null
              },
              "ms-1": {
                "url": "http://localhost:7701",
                "searchApiKey": "foo",
                "writeApiKey": "bar"
              },
              "ms-2": {
                "url": "http://localhost:7702",
                "searchApiKey": "bar",
                "writeApiKey": "foo"
              }
            }
          },
          "searchApiKey": {
            "type": [
              "string",
              "null"
            ],
            "example": "XWnBI8QHUc-4IlqbKPLUDuhftNq19mQtjc6JvmivzJU"
          },
          "writeApiKey": {
            "type": [
              "string",
              "null"
            ],
            "example": "XWnBI8QHUc-4IlqbKPLUDuhftNq19mQtjc6JvmivzJU"
          }
        }
      },
      "RemoteTask": {
        "type": "object",
        "properties": {
          "taskUid": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/u32"
              }
            ]
          },
          "error": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/ResponseError"
              }
            ]
          }
        }
      },
      "ResponseError": {
        "type": "object",
        "required": [
          "message",
          "code",
          "type",
          "link"
        ],
        "properties": {
          "message": {
            "type": "string",
            "description": "The error message."
          },
          "code": {
            "$ref": "#/components/schemas/Code",
            "description": "The error code."
          },
          "type": {
            "$ref": "#/components/schemas/ErrorType",
            "description": "The error type."
          },
          "link": {
            "type": "string",
            "description": "A link to the documentation about this specific error."
          }
        }
      },
      "RuntimeTogglableFeatures": {
        "type": "object",
        "properties": {
          "metrics": {
            "type": [
              "boolean",
              "null"
            ]
          },
          "logsRoute": {
            "type": [
              "boolean",
              "null"
            ]
          },
          "editDocumentsByFunction": {
            "type": [
              "boolean",
              "null"
            ]
          },
          "containsFilter": {
            "type": [
              "boolean",
              "null"
            ]
          },
          "network": {
            "type": [
              "boolean",
              "null"
            ]
          },
          "getTaskDocumentsRoute": {
            "type": [
              "boolean",
              "null"
            ]
          },
          "compositeEmbedders": {
            "type": [
              "boolean",
              "null"
            ]
          },
          "chatCompletions": {
            "type": [
              "boolean",
              "null"
            ]
          },
          "multimodal": {
            "type": [
              "boolean",
              "null"
            ]
          },
          "vectorStoreSetting": {
            "type": [
              "boolean",
              "null"
            ]
          }
        }
      },
      "SearchHit": {
        "type": "object",
        "properties": {
          "_formatted": {
            "type": "object",
            "additionalProperties": true
          },
          "_matchesPosition": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/BTreeMap"
              }
            ]
          },
          "_rankingScore": {
            "type": [
              "number",
              "null"
            ],
            "format": "double"
          },
          "_rankingScoreDetails": {
            "type": [
              "object",
              "null"
            ],
            "additionalProperties": {},
            "propertyNames": {
              "type": "string"
            }
          }
        },
        "additionalProperties": {}
      },
      "SearchMetadata": {
        "type": "object",
        "required": [
          "queryUid",
          "indexUid"
        ],
        "properties": {
          "queryUid": {
            "type": "string",
            "format": "uuid"
          },
          "indexUid": {
            "type": "string"
          },
          "primaryKey": {
            "type": [
              "string",
              "null"
            ]
          },
          "remote": {
            "type": [
              "string",
              "null"
            ]
          }
        }
      },
      "SearchQuery": {
        "type": "object",
        "required": [
          "offset",
          "limit",
          "retrieve_vectors",
          "crop_length",
          "show_matches_position",
          "show_ranking_score",
          "show_ranking_score_details",
          "highlight_pre_tag",
          "highlight_post_tag",
          "crop_marker",
          "matching_strategy"
        ],
        "properties": {
          "q": {
            "type": [
              "string",
              "null"
            ]
          },
          "vector": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "number",
              "format": "float"
            }
          },
          "media": {},
          "hybrid": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/HybridQuery"
              }
            ]
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "minimum": 0
          },
          "limit": {
            "type": "integer",
            "default": 20,
            "minimum": 0
          },
          "page": {
            "type": [
              "integer",
              "null"
            ],
            "minimum": 0
          },
          "hits_per_page": {
            "type": [
              "integer",
              "null"
            ],
            "minimum": 0
          },
          "attributes_to_retrieve": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "uniqueItems": true
          },
          "retrieve_vectors": {
            "type": "boolean"
          },
          "attributes_to_crop": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            }
          },
          "crop_length": {
            "type": "integer",
            "default": 10,
            "minimum": 0
          },
          "attributes_to_highlight": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "uniqueItems": true
          },
          "show_matches_position": {
            "type": "boolean"
          },
          "show_ranking_score": {
            "type": "boolean"
          },
          "show_ranking_score_details": {
            "type": "boolean"
          },
          "filter": {},
          "sort": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            }
          },
          "distinct": {
            "type": [
              "string",
              "null"
            ]
          },
          "facets": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            }
          },
          "highlight_pre_tag": {
            "type": "string",
            "default": "<em>"
          },
          "highlight_post_tag": {
            "type": "string",
            "default": "</em>"
          },
          "crop_marker": {
            "type": "string",
            "default": ""
          },
          "matching_strategy": {
            "$ref": "#/components/schemas/MatchingStrategy"
          },
          "attributes_to_search_on": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            }
          },
          "ranking_score_threshold": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/RankingScoreThreshold"
              }
            ]
          },
          "locales": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "$ref": "#/components/schemas/Locale"
            }
          },
          "personalize": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/Personalize"
              }
            ]
          }
        }
      },
      "SearchQueryWithIndex": {
        "type": "object",
        "description": "A `SearchQuery` + an index UID and optional FederationOptions.",
        "required": [
          "indexUid",
          "retrieveVectors",
          "cropLength",
          "showRankingScore",
          "showRankingScoreDetails",
          "showMatchesPosition",
          "highlightPreTag",
          "highlightPostTag",
          "cropMarker",
          "matchingStrategy"
        ],
        "properties": {
          "indexUid": {
            "$ref": "#/components/schemas/IndexUid"
          },
          "q": {
            "type": [
              "string",
              "null"
            ]
          },
          "vector": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "number",
              "format": "float"
            }
          },
          "media": {},
          "hybrid": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/HybridQuery"
              }
            ]
          },
          "offset": {
            "type": [
              "integer",
              "null"
            ],
            "minimum": 0
          },
          "limit": {
            "type": [
              "integer",
              "null"
            ],
            "minimum": 0
          },
          "page": {
            "type": [
              "integer",
              "null"
            ],
            "minimum": 0
          },
          "hitsPerPage": {
            "type": [
              "integer",
              "null"
            ],
            "minimum": 0
          },
          "attributesToRetrieve": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "uniqueItems": true
          },
          "retrieveVectors": {
            "type": "boolean"
          },
          "attributesToCrop": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            }
          },
          "cropLength": {
            "type": "integer",
            "minimum": 0
          },
          "attributesToHighlight": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "uniqueItems": true
          },
          "showRankingScore": {
            "type": "boolean"
          },
          "showRankingScoreDetails": {
            "type": "boolean"
          },
          "showMatchesPosition": {
            "type": "boolean"
          },
          "filter": {},
          "sort": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            }
          },
          "distinct": {
            "type": [
              "string",
              "null"
            ]
          },
          "facets": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            }
          },
          "highlightPreTag": {
            "type": "string"
          },
          "highlightPostTag": {
            "type": "string"
          },
          "cropMarker": {
            "type": "string"
          },
          "matchingStrategy": {
            "$ref": "#/components/schemas/MatchingStrategy"
          },
          "attributesToSearchOn": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            }
          },
          "rankingScoreThreshold": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/RankingScoreThreshold"
              }
            ]
          },
          "locales": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "$ref": "#/components/schemas/Locale"
            }
          },
          "federationOptions": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/FederationOptions"
              }
            ]
          }
        }
      },
      "SearchResult": {
        "allOf": [
          {
            "$ref": "#/components/schemas/HitsInfo"
          },
          {
            "type": "object",
            "required": [
              "hits",
              "query",
              "processingTimeMs"
            ],
            "properties": {
              "hits": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/SearchHit"
                }
              },
              "query": {
                "type": "string"
              },
              "queryVector": {
                "type": [
                  "array",
                  "null"
                ],
                "items": {
                  "type": "number",
                  "format": "float"
                }
              },
              "processingTimeMs": {
                "type": "integer",
                "minimum": 0
              },
              "facetDistribution": {
                "type": [
                  "object",
                  "null"
                ],
                "additionalProperties": {},
                "propertyNames": {
                  "type": "string"
                }
              },
              "facetStats": {
                "type": [
                  "object",
                  "null"
                ],
                "additionalProperties": {
                  "$ref": "#/components/schemas/FacetStats"
                },
                "propertyNames": {
                  "type": "string"
                }
              },
              "requestUid": {
                "type": [
                  "string",
                  "null"
                ],
                "format": "uuid"
              },
              "metadata": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "$ref": "#/components/schemas/SearchMetadata"
                  }
                ]
              },
              "semanticHitCount": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int32",
                "minimum": 0
              }
            }
          }
        ]
      },
      "SearchResultWithIndex": {
        "allOf": [
          {
            "$ref": "#/components/schemas/SearchResult"
          },
          {
            "type": "object",
            "required": [
              "indexUid"
            ],
            "properties": {
              "indexUid": {
                "type": "string"
              }
            }
          }
        ]
      },
      "SearchResults": {
        "type": "object",
        "required": [
          "results"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchResultWithIndex"
            }
          }
        }
      },
      "SettingEmbeddingSettings": {
        "type": "object",
        "description": "\"Technical\" type that is required due to utoipa.\n\nWe did not find a way to implement [`utoipa::ToSchema`] for the [`Setting`] enum,\nbut most types can use the `value_type` macro parameter to workaround that issue.\n\nHowever that type is used in the settings route, including through the macro that auto-generate\nall the settings route, so we can't remap the `value_type`.",
        "properties": {
          "inner": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "object",
                "properties": {
                  "source": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "$ref": "#/components/schemas/EmbedderSource",
                        "description": "The source used to provide the embeddings.\n\nWhich embedder parameters are available and mandatory is determined by the value of this setting.\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings.\n\n# Defaults\n\n- Defaults to `openAi`"
                      }
                    ]
                  },
                  "model": {
                    "type": [
                      "string",
                      "null"
                    ],
                    "description": "The name of the model to use.\n\n# Mandatory\n\n- This parameter is mandatory for source `ollama`\n\n# Availability\n\n- This parameter is available for sources `openAi`, `huggingFace`, `ollama`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings.\n\n# Defaults\n\n- For source `openAi`, defaults to `text-embedding-3-small`\n- For source `huggingFace`, defaults to `BAAI/bge-base-en-v1.5`"
                  },
                  "revision": {
                    "type": [
                      "string",
                      "null"
                    ],
                    "description": "The revision (commit SHA1) of the model to use.\n\nIf unspecified, Meilisearch picks the latest revision of the model.\n\n# Availability\n\n- This parameter is available for source `huggingFace`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings\n\n# Defaults\n\n- When `model` is set to default, defaults to `617ca489d9e86b49b8167676d8220688b99db36e`\n- Otherwise, defaults to `null`"
                  },
                  "pooling": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "$ref": "#/components/schemas/OverridePooling",
                        "description": "The pooling method to use.\n\n# Availability\n\n- This parameter is available for source `huggingFace`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings\n\n# Defaults\n\n- Defaults to `useModel`\n\n# Compatibility Note\n\n- Embedders created before this parameter was available default to `forceMean` to preserve the existing behavior."
                      }
                    ]
                  },
                  "apiKey": {
                    "type": [
                      "string",
                      "null"
                    ],
                    "description": "The API key to pass to the remote embedder while making requests.\n\n# Availability\n\n- This parameter is available for source `openAi`, `ollama`, `rest`\n\n#  Reindexing\n\n-  Changing the value of this parameter never regenerates embeddings\n\n# Defaults\n\n- For source `openAi`, the key is read from `OPENAI_API_KEY`, then `MEILI_OPENAI_API_KEY`.\n- For other sources, no bearer token is sent if this parameter is not set.\n\n# Note\n\n- This setting is partially hidden when returned by the settings"
                  },
                  "dimensions": {
                    "type": [
                      "string",
                      "null"
                    ],
                    "description": "The expected dimensions of the embeddings produced by this embedder.\n\n# Mandatory\n\n- This parameter is mandatory for source `userProvided`\n\n# Availability\n\n- This parameter is available for source `openAi`, `ollama`, `rest`, `userProvided`\n\n#  Reindexing\n\n-  When the source is `openAi`, changing the value of this parameter always regenerates embeddings\n-  For other sources, changing the value of this parameter never regenerates embeddings\n\n# Defaults\n\n- For source `openAi`, the dimensions is the maximum allowed by the model.\n- For sources `ollama` and `rest`, the dimensions are inferred by embedding a sample text."
                  },
                  "binaryQuantized": {
                    "type": [
                      "boolean",
                      "null"
                    ],
                    "description": "Whether to binary quantize the embeddings of this embedder.\n\nBinary quantized embeddings are smaller than regular embeddings, which improves\ndisk usage and retrieval speed, at the cost of relevancy.\n\n# Availability\n\n- This parameter is available for all embedders\n\n#  Reindexing\n\n-  When set to `true`, embeddings are not regenerated, but they are binary quantized, which takes time.\n\n# Defaults\n\n- Defaults to `false`\n\n# Note\n\nAs binary quantization is a destructive operation, it is not possible to disable again this setting after\nfirst enabling it. If you are unsure of whether the performance-relevancy tradeoff is right for you,\nwe recommend to use this parameter on a test index first."
                  },
                  "documentTemplate": {
                    "type": [
                      "boolean",
                      "null"
                    ],
                    "description": "A liquid template used to render documents to a text that can be embedded.\n\nMeillisearch interpolates the template for each document and sends the resulting text to the embedder.\nThe embedder then generates document vectors based on this text.\n\n# Availability\n\n- This parameter is available for source `openAi`, `huggingFace`, `ollama` and `rest\n\n#  Reindexing\n\n-  When modified, embeddings are regenerated for documents whose rendering through the template produces a different text."
                  },
                  "documentTemplateMaxBytes": {
                    "type": [
                      "integer",
                      "null"
                    ],
                    "description": "Rendered texts are truncated to this size.\n\n# Availability\n\n- This parameter is available for source `openAi`, `huggingFace`, `ollama` and `rest`\n\n#  Reindexing\n\n-  When increased, embeddings are regenerated for documents whose rendering through the template produces a different text.\n-  When decreased, embeddings are never regenerated\n\n# Default\n\n- Defaults to 400",
                    "minimum": 0
                  },
                  "url": {
                    "type": [
                      "string",
                      "null"
                    ],
                    "description": "URL to reach the remote embedder.\n\n# Mandatory\n\n- This parameter is mandatory for source `rest`\n\n# Availability\n\n- This parameter is available for source `openAi`, `ollama` and `rest`\n\n#  Reindexing\n\n-  When modified for source `openAi`, embeddings are never regenerated\n-  When modified for sources `ollama` and `rest`, embeddings are always regenerated"
                  },
                  "indexingFragments": {
                    "type": [
                      "object",
                      "null"
                    ],
                    "description": "Template fragments that will be reassembled and sent to the remote embedder at indexing time.\n\n# Availability\n\n- This parameter is available for sources `rest`.\n\n#  Reindexing\n\n-  When a fragment is deleted by passing `null` to its name, the corresponding embeddings are removed from documents.\n-  When a fragment is modified, the corresponding embeddings are regenerated if their rendered version changes.",
                    "additionalProperties": {},
                    "propertyNames": {
                      "type": "string"
                    }
                  },
                  "searchFragments": {
                    "type": [
                      "object",
                      "null"
                    ],
                    "description": "Template fragments that will be reassembled and sent to the remote embedder at search time.\n\n# Availability\n\n- This parameter is available for sources `rest`.\n\n#  Reindexing\n\n-  Changing the value of this parameter never regenerates embeddings",
                    "additionalProperties": {},
                    "propertyNames": {
                      "type": "string"
                    }
                  },
                  "request": {
                    "description": "Template request to send to the remote embedder.\n\n# Mandatory\n\n- This parameter is mandatory for source `rest`\n\n# Availability\n\n- This parameter is available for source `rest`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings"
                  },
                  "response": {
                    "description": "Template response indicating how to find the embeddings in the response from the remote embedder.\n\n# Mandatory\n\n- This parameter is mandatory for source `rest`\n\n# Availability\n\n- This parameter is available for source `rest`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings"
                  },
                  "headers": {
                    "type": [
                      "object",
                      "null"
                    ],
                    "description": "Additional headers to send to the remote embedder.\n\n# Availability\n\n- This parameter is available for source `rest`\n\n#  Reindexing\n\n-  Changing the value of this parameter never regenerates embeddings",
                    "additionalProperties": {
                      "type": "string"
                    },
                    "propertyNames": {
                      "type": "string"
                    }
                  },
                  "searchEmbedder": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "$ref": "#/components/schemas/SubEmbeddingSettings"
                      }
                    ]
                  },
                  "indexingEmbedder": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "$ref": "#/components/schemas/SubEmbeddingSettings"
                      }
                    ]
                  },
                  "distribution": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "$ref": "#/components/schemas/DistributionShift",
                        "description": "Affine transformation applied to the semantic score to make it more comparable to the ranking score.\n\n# Availability\n\n- This parameter is available for all embedders\n\n#  Reindexing\n\n-  Changing the value of this parameter never regenerates embeddings"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            ]
          }
        }
      },
      "Settings_Checked": {
        "type": "object",
        "description": "Holds all the settings for an index. `T` can either be `Checked` if they represents settings\nwhose validity is guaranteed, or `Unchecked` if they need to be validated. In the later case, a\ncall to `check` will return a `Settings<Checked>` from a `Settings<Unchecked>`.",
        "properties": {
          "displayedAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Fields displayed in the returned documents.",
            "example": [
              "id",
              "title",
              "description",
              "url"
            ]
          },
          "searchableAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Fields in which to search for matching query words sorted by order of importance.",
            "example": [
              "title",
              "description"
            ]
          },
          "filterableAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "$ref": "#/components/schemas/FilterableAttributesRule"
            },
            "description": "Attributes to use for faceting and filtering. See [Filtering and Faceted Search](https://www.meilisearch.com/docs/learn/filtering_and_sorting/search_with_facet_filters).",
            "example": [
              "release_date",
              "genre"
            ]
          },
          "sortableAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Attributes to use when sorting search results.",
            "example": [
              "release_date"
            ]
          },
          "rankingRules": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of ranking rules sorted by order of importance. The order is customizable.\n[A list of ordered built-in ranking rules](https://www.meilisearch.com/docs/learn/relevancy/relevancy).",
            "example": [
              "words",
              "typo",
              "proximity",
              "attribute",
              "exactness"
            ]
          },
          "stopWords": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of words ignored when present in search queries.",
            "example": [
              "the",
              "a",
              "them",
              "their"
            ]
          },
          "nonSeparatorTokens": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of characters not delimiting where one term begins and ends.",
            "example": [
              " ",
              "\n"
            ]
          },
          "separatorTokens": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of characters delimiting where one term begins and ends.",
            "example": [
              "S"
            ]
          },
          "dictionary": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of strings Meilisearch should parse as a single term.",
            "example": [
              "iPhone pro"
            ]
          },
          "synonyms": {
            "type": [
              "object",
              "null"
            ],
            "description": "List of associated words treated similarly. A word associated to an array of word as synonyms.",
            "additionalProperties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "propertyNames": {
              "type": "string"
            },
            "example": {
              "he": [
                "she",
                "they",
                "them"
              ],
              "phone": [
                "iPhone",
                "android"
              ]
            }
          },
          "distinctAttribute": {
            "type": [
              "string",
              "null"
            ],
            "description": "Search returns documents with distinct (different) values of the given field.",
            "example": "sku"
          },
          "proximityPrecision": {
            "type": [
              "string",
              "null"
            ],
            "description": "Precision level when calculating the proximity ranking rule.",
            "example": "byAttribute"
          },
          "typoTolerance": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/TypoSettings",
                "description": "Customize typo tolerance feature."
              }
            ]
          },
          "faceting": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/FacetingSettings",
                "description": "Faceting settings."
              }
            ]
          },
          "pagination": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/PaginationSettings",
                "description": "Pagination settings."
              }
            ]
          },
          "embedders": {
            "type": [
              "object",
              "null"
            ],
            "description": "Embedder required for performing semantic search queries.",
            "additionalProperties": {
              "$ref": "#/components/schemas/SettingEmbeddingSettings"
            },
            "propertyNames": {
              "type": "string"
            }
          },
          "searchCutoffMs": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int64",
            "description": "Maximum duration of a search query.",
            "example": 50,
            "minimum": 0
          },
          "localizedAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "$ref": "#/components/schemas/LocalizedAttributesRuleView"
            },
            "example": 50
          },
          "facetSearch": {
            "type": [
              "boolean",
              "null"
            ],
            "example": true
          },
          "prefixSearch": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/PrefixSearchSettings"
              }
            ]
          },
          "chat": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/ChatSettings",
                "description": "Customize the chat prompting."
              }
            ]
          },
          "vectorStore": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/VectorStoreBackend"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Settings_Unchecked": {
        "type": "object",
        "description": "Holds all the settings for an index. `T` can either be `Checked` if they represents settings\nwhose validity is guaranteed, or `Unchecked` if they need to be validated. In the later case, a\ncall to `check` will return a `Settings<Checked>` from a `Settings<Unchecked>`.",
        "properties": {
          "displayedAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Fields displayed in the returned documents.",
            "example": [
              "id",
              "title",
              "description",
              "url"
            ]
          },
          "searchableAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Fields in which to search for matching query words sorted by order of importance.",
            "example": [
              "title",
              "description"
            ]
          },
          "filterableAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "$ref": "#/components/schemas/FilterableAttributesRule"
            },
            "description": "Attributes to use for faceting and filtering. See [Filtering and Faceted Search](https://www.meilisearch.com/docs/learn/filtering_and_sorting/search_with_facet_filters).",
            "example": [
              "release_date",
              "genre"
            ]
          },
          "sortableAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Attributes to use when sorting search results.",
            "example": [
              "release_date"
            ]
          },
          "rankingRules": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of ranking rules sorted by order of importance. The order is customizable.\n[A list of ordered built-in ranking rules](https://www.meilisearch.com/docs/learn/relevancy/relevancy).",
            "example": [
              "words",
              "typo",
              "proximity",
              "attribute",
              "exactness"
            ]
          },
          "stopWords": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of words ignored when present in search queries.",
            "example": [
              "the",
              "a",
              "them",
              "their"
            ]
          },
          "nonSeparatorTokens": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of characters not delimiting where one term begins and ends.",
            "example": [
              " ",
              "\n"
            ]
          },
          "separatorTokens": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of characters delimiting where one term begins and ends.",
            "example": [
              "S"
            ]
          },
          "dictionary": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of strings Meilisearch should parse as a single term.",
            "example": [
              "iPhone pro"
            ]
          },
          "synonyms": {
            "type": [
              "object",
              "null"
            ],
            "description": "List of associated words treated similarly. A word associated to an array of word as synonyms.",
            "additionalProperties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "propertyNames": {
              "type": "string"
            },
            "example": {
              "he": [
                "she",
                "they",
                "them"
              ],
              "phone": [
                "iPhone",
                "android"
              ]
            }
          },
          "distinctAttribute": {
            "type": [
              "string",
              "null"
            ],
            "description": "Search returns documents with distinct (different) values of the given field.",
            "example": "sku"
          },
          "proximityPrecision": {
            "type": [
              "string",
              "null"
            ],
            "description": "Precision level when calculating the proximity ranking rule.",
            "example": "byAttribute"
          },
          "typoTolerance": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/TypoSettings",
                "description": "Customize typo tolerance feature."
              }
            ]
          },
          "faceting": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/FacetingSettings",
                "description": "Faceting settings."
              }
            ]
          },
          "pagination": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/PaginationSettings",
                "description": "Pagination settings."
              }
            ]
          },
          "embedders": {
            "type": [
              "object",
              "null"
            ],
            "description": "Embedder required for performing semantic search queries.",
            "additionalProperties": {
              "$ref": "#/components/schemas/SettingEmbeddingSettings"
            },
            "propertyNames": {
              "type": "string"
            }
          },
          "searchCutoffMs": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int64",
            "description": "Maximum duration of a search query.",
            "example": 50,
            "minimum": 0
          },
          "localizedAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "$ref": "#/components/schemas/LocalizedAttributesRuleView"
            },
            "example": 50
          },
          "facetSearch": {
            "type": [
              "boolean",
              "null"
            ],
            "example": true
          },
          "prefixSearch": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/PrefixSearchSettings"
              }
            ]
          },
          "chat": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/ChatSettings",
                "description": "Customize the chat prompting."
              }
            ]
          },
          "vectorStore": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/VectorStoreBackend"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "SimilarQuery": {
        "type": "object",
        "required": [
          "id",
          "offset",
          "limit",
          "embedder",
          "retrieve_vectors",
          "show_ranking_score",
          "show_ranking_score_details",
          "ranking_score_threshold"
        ],
        "properties": {
          "id": {
            "type": "string"
          },
          "offset": {
            "type": "integer",
            "minimum": 0
          },
          "limit": {
            "type": "integer",
            "minimum": 0
          },
          "filter": {},
          "embedder": {
            "type": "string"
          },
          "attributes_to_retrieve": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "uniqueItems": true
          },
          "retrieve_vectors": {
            "type": "boolean"
          },
          "show_ranking_score": {
            "type": "boolean"
          },
          "show_ranking_score_details": {
            "type": "boolean"
          },
          "ranking_score_threshold": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "SimilarResult": {
        "allOf": [
          {
            "$ref": "#/components/schemas/HitsInfo"
          },
          {
            "type": "object",
            "required": [
              "hits",
              "id",
              "processingTimeMs"
            ],
            "properties": {
              "hits": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/SearchHit"
                }
              },
              "id": {
                "type": "string"
              },
              "processingTimeMs": {
                "type": "integer",
                "minimum": 0
              }
            }
          }
        ]
      },
      "Stats": {
        "type": "object",
        "required": [
          "databaseSize",
          "usedDatabaseSize",
          "indexes"
        ],
        "properties": {
          "databaseSize": {
            "type": "integer",
            "format": "u-int64",
            "description": "The disk space used by the database, in bytes.",
            "minimum": 0
          },
          "usedDatabaseSize": {
            "type": "integer",
            "format": "u-int64",
            "description": "The size of the database, in bytes.",
            "minimum": 0
          },
          "lastUpdate": {
            "type": [
              "string",
              "null"
            ],
            "format": "date-time",
            "description": "The date of the last update in the RFC 3339 formats. Can be `null` if no update has ever been processed."
          },
          "indexes": {
            "type": "object",
            "description": "The stats of every individual index your API key lets you access.",
            "additionalProperties": {
              "$ref": "#/components/schemas/IndexStats"
            },
            "propertyNames": {
              "type": "string"
            }
          }
        }
      },
      "Status": {
        "type": "string",
        "description": "The status of a task.",
        "enum": [
          "enqueued",
          "processing",
          "succeeded",
          "failed",
          "canceled"
        ],
        "example": "processing"
      },
      "SubEmbeddingSettings": {
        "type": "object",
        "properties": {
          "source": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/EmbedderSource",
                "description": "The source used to provide the embeddings.\n\nWhich embedder parameters are available and mandatory is determined by the value of this setting.\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings.\n\n# Defaults\n\n- Defaults to `openAi`"
              }
            ]
          },
          "model": {
            "type": [
              "string",
              "null"
            ],
            "description": "The name of the model to use.\n\n# Mandatory\n\n- This parameter is mandatory for source `ollama`\n\n# Availability\n\n- This parameter is available for sources `openAi`, `huggingFace`, `ollama`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings.\n\n# Defaults\n\n- For source `openAi`, defaults to `text-embedding-3-small`\n- For source `huggingFace`, defaults to `BAAI/bge-base-en-v1.5`"
          },
          "revision": {
            "type": [
              "string",
              "null"
            ],
            "description": "The revision (commit SHA1) of the model to use.\n\nIf unspecified, Meilisearch picks the latest revision of the model.\n\n# Availability\n\n- This parameter is available for source `huggingFace`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings\n\n# Defaults\n\n- When `model` is set to default, defaults to `617ca489d9e86b49b8167676d8220688b99db36e`\n- Otherwise, defaults to `null`"
          },
          "pooling": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/OverridePooling",
                "description": "The pooling method to use.\n\n# Availability\n\n- This parameter is available for source `huggingFace`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings\n\n# Defaults\n\n- Defaults to `useModel`\n\n# Compatibility Note\n\n- Embedders created before this parameter was available default to `forceMean` to preserve the existing behavior."
              }
            ]
          },
          "apiKey": {
            "type": [
              "string",
              "null"
            ],
            "description": "The API key to pass to the remote embedder while making requests.\n\n# Availability\n\n- This parameter is available for source `openAi`, `ollama`, `rest`\n\n#  Reindexing\n\n-  Changing the value of this parameter never regenerates embeddings\n\n# Defaults\n\n- For source `openAi`, the key is read from `OPENAI_API_KEY`, then `MEILI_OPENAI_API_KEY`.\n- For other sources, no bearer token is sent if this parameter is not set.\n\n# Note\n\n- This setting is partially hidden when returned by the settings"
          },
          "dimensions": {
            "type": [
              "string",
              "null"
            ],
            "description": "The expected dimensions of the embeddings produced by this embedder.\n\n# Mandatory\n\n- This parameter is mandatory for source `userProvided`\n\n# Availability\n\n- This parameter is available for source `openAi`, `ollama`, `rest`, `userProvided`\n\n#  Reindexing\n\n-  When the source is `openAi`, changing the value of this parameter always regenerates embeddings\n-  For other sources, changing the value of this parameter never regenerates embeddings\n\n# Defaults\n\n- For source `openAi`, the dimensions is the maximum allowed by the model.\n- For sources `ollama` and `rest`, the dimensions are inferred by embedding a sample text."
          },
          "documentTemplate": {
            "type": [
              "boolean",
              "null"
            ],
            "description": "A liquid template used to render documents to a text that can be embedded.\n\nMeillisearch interpolates the template for each document and sends the resulting text to the embedder.\nThe embedder then generates document vectors based on this text.\n\n# Availability\n\n- This parameter is available for source `openAi`, `huggingFace`, `ollama` and `rest\n\n#  Reindexing\n\n-  When modified, embeddings are regenerated for documents whose rendering through the template produces a different text."
          },
          "documentTemplateMaxBytes": {
            "type": [
              "integer",
              "null"
            ],
            "description": "Rendered texts are truncated to this size.\n\n# Availability\n\n- This parameter is available for source `openAi`, `huggingFace`, `ollama` and `rest`\n\n#  Reindexing\n\n-  When increased, embeddings are regenerated for documents whose rendering through the template produces a different text.\n-  When decreased, embeddings are never regenerated\n\n# Default\n\n- Defaults to 400",
            "minimum": 0
          },
          "url": {
            "type": [
              "string",
              "null"
            ],
            "description": "URL to reach the remote embedder.\n\n# Mandatory\n\n- This parameter is mandatory for source `rest`\n\n# Availability\n\n- This parameter is available for source `openAi`, `ollama` and `rest`\n\n#  Reindexing\n\n-  When modified for source `openAi`, embeddings are never regenerated\n-  When modified for sources `ollama` and `rest`, embeddings are always regenerated"
          },
          "indexingFragments": {
            "type": [
              "object",
              "null"
            ],
            "description": "Template fragments that will be reassembled and sent to the remote embedder at indexing time.\n\n# Availability\n\n- This parameter is available for sources `rest`.\n\n#  Reindexing\n\n-  When a fragment is deleted by passing `null` to its name, the corresponding embeddings are removed from documents.\n-  When a fragment is modified, the corresponding embeddings are regenerated if their rendered version changes.",
            "additionalProperties": {},
            "propertyNames": {
              "type": "string"
            }
          },
          "searchFragments": {
            "type": [
              "object",
              "null"
            ],
            "description": "Template fragments that will be reassembled and sent to the remote embedder at search time.\n\n# Availability\n\n- This parameter is available for sources `rest`.\n\n#  Reindexing\n\n-  Changing the value of this parameter never regenerates embeddings",
            "additionalProperties": {},
            "propertyNames": {
              "type": "string"
            }
          },
          "request": {
            "description": "Template request to send to the remote embedder.\n\n# Mandatory\n\n- This parameter is mandatory for source `rest`\n\n# Availability\n\n- This parameter is available for source `rest`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings"
          },
          "response": {
            "description": "Template response indicating how to find the embeddings in the response from the remote embedder.\n\n# Mandatory\n\n- This parameter is mandatory for source `rest`\n\n# Availability\n\n- This parameter is available for source `rest`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings"
          },
          "headers": {
            "type": [
              "object",
              "null"
            ],
            "description": "Additional headers to send to the remote embedder.\n\n# Availability\n\n- This parameter is available for source `rest`\n\n#  Reindexing\n\n-  Changing the value of this parameter never regenerates embeddings",
            "additionalProperties": {
              "type": "string"
            },
            "propertyNames": {
              "type": "string"
            }
          }
        },
        "additionalProperties": false
      },
      "SummarizedTaskView": {
        "type": "object",
        "required": [
          "taskUid",
          "status",
          "type",
          "enqueuedAt"
        ],
        "properties": {
          "taskUid": {
            "type": "integer",
            "format": "u-int32",
            "description": "The task unique identifier.",
            "minimum": 0
          },
          "indexUid": {
            "type": [
              "string",
              "null"
            ],
            "description": "The index affected by this task. May be `null` if the task is not linked to any index."
          },
          "status": {
            "$ref": "#/components/schemas/Status",
            "description": "The status of the task."
          },
          "type": {
            "$ref": "#/components/schemas/Kind",
            "description": "The type of the task."
          },
          "enqueuedAt": {
            "type": "string",
            "format": "date-time",
            "description": "The date on which the task was enqueued."
          },
          "customMetadata": {
            "type": [
              "string",
              "null"
            ]
          }
        }
      },
      "SwapIndexesPayload": {
        "type": "object",
        "required": [
          "indexes",
          "rename"
        ],
        "properties": {
          "indexes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IndexUid"
            },
            "description": "Array of the two indexUids to be swapped"
          },
          "rename": {
            "type": "boolean",
            "description": "If set to true, instead of swapping the left and right indexes it'll change the name of the first index to the second"
          }
        }
      },
      "TaskNetwork": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "origin"
            ],
            "properties": {
              "origin": {
                "$ref": "#/components/schemas/Origin"
              }
            }
          },
          {
            "type": "object",
            "required": [
              "remote_tasks"
            ],
            "properties": {
              "remote_tasks": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/RemoteTask"
                },
                "propertyNames": {
                  "type": "string"
                }
              }
            }
          }
        ]
      },
      "TaskView": {
        "type": "object",
        "required": [
          "uid",
          "status",
          "type",
          "enqueuedAt"
        ],
        "properties": {
          "uid": {
            "type": "integer",
            "format": "u-int32",
            "description": "The unique sequential identifier of the task.",
            "example": 4312,
            "minimum": 0
          },
          "batchUid": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int32",
            "description": "The unique identifier of the index where this task is operated.",
            "example": "movies",
            "minimum": 0
          },
          "indexUid": {
            "type": [
              "string",
              "null"
            ]
          },
          "status": {
            "$ref": "#/components/schemas/Status"
          },
          "type": {
            "$ref": "#/components/schemas/Kind",
            "description": "The type of the task."
          },
          "canceledBy": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int32",
            "description": "The uid of the task that performed the taskCancelation if the task has been canceled.",
            "example": 4326,
            "minimum": 0
          },
          "details": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/DetailsView"
              }
            ]
          },
          "error": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/ResponseError"
              }
            ]
          },
          "duration": {
            "type": [
              "string",
              "null"
            ],
            "description": "Total elasped time the engine was in processing state expressed as a `ISO-8601` duration format.",
            "example": null
          },
          "enqueuedAt": {
            "type": "string",
            "description": "An `RFC 3339` format for date/time/duration.",
            "example": "2024-08-08_14:12:09.393Z"
          },
          "startedAt": {
            "type": "string",
            "description": "An `RFC 3339` format for date/time/duration.",
            "example": "2024-08-08_14:12:09.393Z"
          },
          "finishedAt": {
            "type": "string",
            "description": "An `RFC 3339` format for date/time/duration.",
            "example": "2024-08-08_14:12:09.393Z"
          },
          "network": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/TaskNetwork"
              }
            ]
          },
          "customMetadata": {
            "type": [
              "string",
              "null"
            ]
          }
        }
      },
      "TypoSettings": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": [
              "boolean",
              "null"
            ],
            "example": true
          },
          "minWordSizeForTypos": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/MinWordSizeTyposSetting"
              }
            ]
          },
          "disableOnWords": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "example": [
              "iPhone",
              "phone"
            ],
            "uniqueItems": true
          },
          "disableOnAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "example": [
              "uuid",
              "url"
            ],
            "uniqueItems": true
          },
          "disableOnNumbers": {
            "type": [
              "boolean",
              "null"
            ],
            "example": true
          }
        },
        "additionalProperties": false
      },
      "Unchecked": {
        "default": null
      },
      "UpdateIndexRequest": {
        "type": "object",
        "properties": {
          "primaryKey": {
            "type": [
              "string",
              "null"
            ],
            "description": "The new primary key of the index"
          },
          "uid": {
            "type": [
              "string",
              "null"
            ],
            "description": "The new uid of the index (for renaming)"
          }
        }
      },
      "UpdateStderrLogs": {
        "type": "object",
        "required": [
          "target"
        ],
        "properties": {
          "target": {
            "type": "string",
            "description": "Lets you specify which parts of the code you want to inspect and is formatted like that: code_part=log_level,code_part=log_level\n- If the `code_part` is missing, then the `log_level` will be applied to everything.\n- If the `log_level` is missing, then the `code_part` will be selected in `info` log level.",
            "default": "info",
            "example": "milli=trace,index_scheduler,actix_web=off"
          }
        }
      },
      "Vec": {
        "type": "array",
        "items": {
          "type": "number",
          "format": "float"
        }
      },
      "VectorStoreBackend": {
        "type": "string",
        "enum": [
          "stable",
          "experimental"
        ]
      },
      "VersionResponse": {
        "type": "object",
        "required": [
          "commitSha",
          "commitDate",
          "pkgVersion"
        ],
        "properties": {
          "commitSha": {
            "type": "string",
            "description": "The commit used to compile this build of Meilisearch."
          },
          "commitDate": {
            "type": "string",
            "description": "The date of this build."
          },
          "pkgVersion": {
            "type": "string",
            "description": "The version of Meilisearch."
          }
        }
      },
      "WebhookResults": {
        "type": "object",
        "required": [
          "results"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WebhookWithMetadataRedactedAuthorization"
            }
          }
        }
      },
      "WebhookSettings": {
        "type": "object",
        "properties": {
          "url": {
            "type": [
              "string",
              "null"
            ],
            "example": "https://your.site/on-tasks-completed"
          },
          "headers": {
            "type": [
              "object",
              "null"
            ],
            "additionalProperties": {
              "type": "string"
            },
            "propertyNames": {
              "type": "string"
            },
            "example": {
              "Authorization": "Bearer a-secret-token"
            }
          }
        }
      },
      "WebhookWithMetadataRedactedAuthorization": {
        "allOf": [
          {
            "$ref": "#/components/schemas/WebhookSettings"
          },
          {
            "type": "object",
            "required": [
              "uuid",
              "isEditable"
            ],
            "properties": {
              "uuid": {
                "type": "string",
                "format": "uuid"
              },
              "isEditable": {
                "type": "boolean"
              }
            }
          }
        ]
      },
      "u32": {
        "type": "integer",
        "format": "u-int32",
        "minimum": 0
      }
    },
    "securitySchemes": {
      "Bearer": {
        "type": "http",
        "scheme": "bearer",
        "bearerFormat": "Uuidv4, string or JWT",
        "description": "An API key is a token that you provide when making API calls. Include the token in a header parameter called `Authorization`.\nExample: `Authorization: Bearer 8fece4405662dd830e4cb265e7e047aab2e79672a760a12712d2a263c9003509`"
      }
    }
  },
  "tags": [
    {
      "name": "Stats",
      "description": "Stats gives extended information and metrics about indexes and the Meilisearch database."
    },
    {
      "name": "Tasks",
      "description": "The tasks route gives information about the progress of the [asynchronous operations](https://docs.meilisearch.com/learn/advanced/asynchronous_operations.html).",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/tasks"
      }
    },
    {
      "name": "Batches",
      "description": "The /batches route gives information about the progress of batches of asynchronous operations.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/batches"
      }
    },
    {
      "name": "Indexes",
      "description": "An index is an entity that gathers a set of [documents](https://www.meilisearch.com/docs/learn/getting_started/documents) with its own [settings](https://www.meilisearch.com/docs/reference/api/settings). Learn more about indexes.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/indexes"
      }
    },
    {
      "name": "Documents",
      "description": "Documents are objects composed of fields that can store any type of data. Each field contains an attribute and its associated value. Documents are stored inside [indexes](https://www.meilisearch.com/docs/learn/getting_started/indexes).",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/learn/getting_started/documents"
      }
    },
    {
      "name": "Facet Search",
      "description": "The `/facet-search` route allows you to search for facet values. Facet search supports prefix search and typo tolerance. The returned hits are sorted lexicographically in ascending order. You can configure how facets are sorted using the sortFacetValuesBy property of the faceting index settings.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/facet_search"
      }
    },
    {
      "name": "Similar documents",
      "description": "The /similar route uses AI-powered search to return a number of documents similar to a target document.\n\nMeilisearch exposes two routes for retrieving similar documents: POST and GET. In the majority of cases, POST will offer better performance and ease of use.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/similar"
      }
    },
    {
      "name": "Settings",
      "description": "Use the /settings route to customize search settings for a given index. You can either modify all index settings at once using the update settings endpoint, or use a child route to configure a single setting.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/settings"
      }
    },
    {
      "name": "Compact an index",
      "description": "The /compact route uses compacts the database to reorganize and make it smaller and more efficient.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/compact"
      }
    },
    {
      "name": "Search",
      "description": "Meilisearch exposes two routes to perform searches:\n\n- A POST route: this is the preferred route when using API authentication, as it allows [preflight request](https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request) caching and better performance.\n- A GET route: the usage of this route is discouraged, unless you have good reason to do otherwise (specific caching abilities for example)",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/search"
      }
    },
    {
      "name": "Snapshots",
      "description": "The snapshots route allows the creation of database snapshots. Snapshots are .snapshot files that can be used to launch Meilisearch.\nCreating a snapshot is also referred to as exporting it, whereas launching Meilisearch with a snapshot is referred to as importing it.\nDuring a snapshot export, all indexes of the current instance are exportedtogether with their documents and settingsand saved as a single .snapshot file.\nDuring a snapshot import, all indexes contained in the indicated .snapshot file are imported along with their associated documents and settings.\nSnapshot imports are performed at launch using an option.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/snapshots"
      }
    },
    {
      "name": "Dumps",
      "description": "The `dumps` route allows the creation of database dumps.\nDumps are `.dump` files that can be used to launch Meilisearch. Dumps are compatible between Meilisearch versions.\nCreating a dump is also referred to as exporting it, whereas launching Meilisearch with a dump is referred to as importing it.\nDuring a [dump export](https://www.meilisearch.com/docs/reference/api/dump#create-a-dump), all indexes of the current instance are\nexportedtogether with their documents and settingsand saved as a single `.dump` file. During a dump import,\nall indexes contained in the indicated `.dump` file are imported along with their associated documents and settings.\nAny existing index with the same uid as an index in the dump file will be overwritten.\nDump imports are [performed at launch](https://www.meilisearch.com/docs/learn/advanced/dumps#importing-a-dump) using an option.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/dump"
      }
    },
    {
      "name": "Keys",
      "description": "Manage API `keys` for a Meilisearch instance. Each key has a given set of permissions.\nYou must have the master key or the default admin key to access the keys route. More information about the keys and their rights.\nAccessing any route under `/keys` without having set a master key will result in an error.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/keys"
      }
    },
    {
      "name": "Logs",
      "description": "Everything about retrieving or customizing logs.\nCurrently [experimental](https://www.meilisearch.com/docs/learn/experimental/overview).",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/learn/experimental/log_customization"
      }
    },
    {
      "name": "Multi-search",
      "description": "The `/multi-search` route allows you to perform multiple search queries on one or more indexes by bundling them into a single HTTP request. Multi-search is also known as federated search.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/multi_search"
      }
    },
    {
      "name": "Experimental features",
      "description": "The `/experimental-features` route allows you to activate or deactivate some of Meilisearch's experimental features.\n\nThis route is **synchronous**. This means that no task object will be returned, and any activated or deactivated features will be made available or unavailable immediately.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/experimental_features"
      }
    },
    {
      "name": "Export",
      "description": "The `/export` route allows you to trigger an export process to a remote Meilisearch instance.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/export"
      }
    },
    {
      "name": "Network",
      "description": "The `/network` route allows you to describe the topology of a network of Meilisearch instances.\n\nThis route is **synchronous**. This means that no task object will be returned, and any change to the network will be made available immediately.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/network"
      }
    },
    {
      "name": "Webhooks",
      "description": "The `/webhooks` route allows you to register endpoints to be called once tasks are processed.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/webhooks"
      }
    }
  ]
}