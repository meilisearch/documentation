---
title: Geosearch
sidebarTitle: Geosearch
description: Filter and sort search results based on their geographic location.
sidebarDepth: 3
---

import CodeSamplesGeosearchGuideFilterSettings1 from '/snippets/generated-code-samples/code_samples_geosearch_guide_filter_settings_1.mdx';
import CodeSamplesGeosearchGuideFilterUsage1 from '/snippets/generated-code-samples/code_samples_geosearch_guide_filter_usage_1.mdx';
import CodeSamplesGeosearchGuideFilterUsage3 from '/snippets/generated-code-samples/code_samples_geosearch_guide_filter_usage_3.mdx';
import CodeSamplesGeosearchGuideFilterUsage2 from '/snippets/generated-code-samples/code_samples_geosearch_guide_filter_usage_2.mdx';
import CodeSamplesGeosearchGuideSortSettings1 from '/snippets/generated-code-samples/code_samples_geosearch_guide_sort_settings_1.mdx';
import CodeSamplesGeosearchGuideSortUsage1 from '/snippets/generated-code-samples/code_samples_geosearch_guide_sort_usage_1.mdx';
import CodeSamplesGeosearchGuideSortUsage2 from '/snippets/generated-code-samples/code_samples_geosearch_guide_sort_usage_2.mdx';

Meilisearch allows you to filter and sort results based on their geographic location. This can be useful when you only want results within a specific area or when sorting results based on their distance from a specific location.

## Preparing documents for location-based search

To start filtering documents based on their geographic location, you must make sure they contain a valid `_geo`, `_geojson`, or `_geo_list` field. If you also want to sort documents geographically, they must have a valid `_geo` or `_geo_list` field.

`_geo`, `_geojson`, and `_geo_list` are reserved fields. If you include any of them in your documents, Meilisearch expects their values to conform to a specific format.

When using JSON and NDJSON, `_geo` must contain an object with two keys: `lat` and `lng`. Both fields must contain either a floating point number or a string indicating, respectively, latitude and longitude:

```json
{
  …
  "_geo": {
    "lat": 0.0,
    "lng": "0.0"
  }
}
```

`_geojson` must be an object whose contents follow the [GeoJSON specification](https://geojson.org/):

```json
{
  …
  "_geojson": {
    "type": "Feature",
    "geometry": {
      "type": "Point",
      "coordinates": [0.0, 0.0]
    }
  }
}
```

Meilisearch does not support transmeridian shapes. If your document includes a transmeridian shape, split it into two separate shapes grouped as a `MultiPolygon` or `MultiLine`. Transmeridian shapes are polygons or lines that cross the 180th meridian.

**Meilisearch does not support polygons with holes**. If your polygon consists of an external ring and an inner empty space, Meilisearch ignores the hole and treats the polygon as a solid shape.

`_geo_list` must be a non-empty array of objects, each containing `lat` and `lng` keys. Use `_geo_list` when a single document represents multiple discrete locations, such as a company with several offices:

```json
{
  …
  "_geo_list": [
    { "lat": 48.8566, "lng": 2.3522 },
    { "lat": 45.4642, "lng": 9.1900 },
    { "lat": 41.9028, "lng": 12.4964 }
  ]
}
```

`null` values within the array are ignored and treated as if the point were absent.

<Note>
### Using `_geo`, `_geojson`, and `_geo_list` together

`_geo`, `_geojson`, and `_geo_list` can coexist on the same document. `_geo_list` works with all three geo filter functions (`_geoRadius`, `_geoBoundingBox`, `_geoPolygon`) and with `_geoPoint` sorting.

When filtering, a document matches if *any* point across all its geo fields falls within the specified area. When sorting with `_geoPoint`, Meilisearch uses the *closest* point from all geo fields.

When handling documents with multiple geo fields, Meilisearch:

- Ignores `_geojson` values when sorting
- Ignores `_geo` values when filtering with `_geoPolygon`
- Merges points from `_geo`, `_geojson`, and `_geo_list` when filtering with `_geoRadius` and `_geoBoundingBox`
- Merges points from `_geo` and `_geo_list` when sorting with `_geoPoint`
</Note>

### Examples

Suppose we have a JSON array containing a few restaurants:

```json
[
  {
    "id": 1,
    "name": "Nàpiz' Milano",
    "address": "Viale Vittorio Veneto, 30, 20124, Milan, Italy",
    "type": "pizza",
    "rating": 9
  },
  {
    "id": 2,
    "name": "Bouillon Pigalle",
    "address": "22 Bd de Clichy, 75018 Paris, France",
    "type": "french",
    "rating": 8
  },
  {
    "id": 3,
    "name": "Artico Gelateria Tradizionale",
    "address": "Via Dogana, 1, 20123 Milan, Italy",
    "type": "ice cream",
    "rating": 10
  }
]
```

Our restaurant dataset looks like this once we add `_geo` data:

```json
[
  {
    "id": 1,
    "name": "Nàpiz' Milano",
    "address": "Viale Vittorio Veneto, 30, 20124, Milan, Italy",
    "type": "pizza",
    "rating": 9,
    "_geo": {
      "lat": 45.4777599,
      "lng": 9.1967508
    }
  },
  {
    "id": 2,
    "name": "Bouillon Pigalle",
    "address": "22 Bd de Clichy, 75018 Paris, France",
    "type": "french",
    "rating": 8,
    "_geo": {
      "lat": 48.8826517,
      "lng": 2.3352748
    }
  },
  {
    "id": 3,
    "name": "Artico Gelateria Tradizionale",
    "address": "Via Dogana, 1, 20123 Milan, Italy",
    "type": "ice cream",
    "rating": 10,
    "_geo": {
      "lat": 45.4632046,
      "lng": 9.1719421
    }
  }
]
```

<Warning>
Trying to index a dataset with one or more documents containing badly formatted `_geo` values will cause Meilisearch to throw an [`invalid_document_geo_field`](/reference/errors/error_codes#invalid_document_geo_field) error. In this case, the update will fail and no documents will be added or modified.
</Warning>

### Using `_geo` with CSV

If your dataset is formatted as CSV, the file header must have a `_geo` column. Each row in the dataset must then contain a column with a comma-separated string indicating latitude and longitude:

```csv
"id:number","name:string","address:string","type:string","rating:number","_geo:string"
"1","Nàpiz Milano","Viale Vittorio Veneto, 30, 20124, Milan, Italy","pizzeria",9,"45.4777599,9.1967508"
"2","Bouillon Pigalle","22 Bd de Clichy, 75018 Paris, France","french",8,"48.8826517,2.3352748"
"3","Artico Gelateria Tradizionale","Via Dogana, 1, 20123 Milan, Italy","ice cream",10,"48.8826517,2.3352748"
```

CSV files do not support the `_geojson` or `_geo_list` attributes.

## Filtering results with `_geoRadius`, `_geoBoundingBox`, and `_geoPolygon`

You can use `_geo`, `_geojson`, and `_geo_list` data to filter queries so you only receive results located within a given geographic area.

### Configuration

To filter results based on their location, you must add `_geo`, `_geojson`, or `_geo_list` to the `filterableAttributes` list:

<CodeSamplesGeosearchGuideFilterSettings1 />

Meilisearch will rebuild your index whenever you update `filterableAttributes`. Depending on the size of your dataset, this might take a considerable amount of time.

[You can read more about configuring `filterableAttributes` in our dedicated filtering guide.](/learn/filtering_and_sorting/filter_search_results)

### Usage

Use the [`filter` search parameter](/reference/api/search/search-with-post#body-filter) along with `_geoRadius` and `_geoBoundingBox`. These are special filter rules that ensure Meilisearch only returns results located within a specific geographic area. If you are using GeoJSON for your documents, you may also filter results with `_geoPolygon`.

### `_geoRadius`

```
_geoRadius(lat, lng, distance_in_meters, resolution)
```

### `_geoBoundingBox`

```
_geoBoundingBox([LAT, LNG], [LAT, LNG])
```

### `_geoPolygon`

```
_geoPolygon([LAT, LNG], [LAT, LNG], [LAT, LNG], …)
```

### Examples

Using our <a id="downloadRestaurants" href="/assets/datasets/restaurants.json" download="restaurants.json">example dataset</a>, we can search for places to eat near the center of Milan with `_geoRadius`:

<CodeSamplesGeosearchGuideFilterUsage1 />

We also make a similar query using `_geoBoundingBox`:

<CodeSamplesGeosearchGuideFilterUsage3 />

And with `_geoPolygon`:

<CodeSamplesGeosearchGuideFilterUsage4 />

```json
[
  {
    "id": 1,
    "name": "Nàpiz' Milano",
    "address": "Viale Vittorio Veneto, 30, 20124, Milan, Italy",
    "type": "pizza",
    "rating": 9,
    "_geo": {
      "lat": 45.4777599,
      "lng": 9.1967508
    }
  },
  {
    "id": 3,
    "name": "Artico Gelateria Tradizionale",
    "address": "Via Dogana, 1, 20123 Milan, Italy",
    "type": "ice cream",
    "rating": 10,
    "_geo": {
      "lat": 45.4632046,
      "lng": 9.1719421
    }
  }
]
```

It is also possible to combine `_geoRadius`, `_geoBoundingBox`, and `_geoPolygon` with other filters. We can narrow down our previous search so it only includes pizzerias:

<CodeSamplesGeosearchGuideFilterUsage2 />

```json
[
  {
    "id": 1,
    "name": "Nàpiz' Milano",
    "address": "Viale Vittorio Veneto, 30, 20124, Milan, Italy",
    "type": "pizza",
    "rating": 9,
    "_geo": {
      "lat": 45.4777599,
      "lng": 9.1967508
    }
  }
]
```

<Warning>
`_geo`, `_geoDistance`, and `_geoPoint` are not valid filter rules. Trying to use any of them with the `filter` search parameter will result in an [`invalid_search_filter`](/reference/errors/error_codes#invalid_search_filter) error.
</Warning>

## Sorting results with `_geoPoint`

### Configuration

Before using geosearch for sorting, you must add the `_geo` or `_geo_list` attribute to the [`sortableAttributes` list](/learn/filtering_and_sorting/sort_search_results):

<CodeSamplesGeosearchGuideSortSettings1 />

<Danger>
It is not possible to sort documents based on the `_geojson` attribute. Use `_geo` or `_geo_list` instead.
</Danger>

### Usage

```
_geoPoint(0.0, 0.0):asc
```

### Examples

The `_geoPoint` sorting function can be used like any other sorting rule. We can order documents based on how close they are to the Eiffel Tower:

<CodeSamplesGeosearchGuideSortUsage1 />

With our <a id="downloadRestaurants" href="/assets/datasets/restaurants.json" download="restaurants.json">restaurants dataset</a>, the results look like this:

```json
[
  {
    "id": 2,
    "name": "Bouillon Pigalle",
    "address": "22 Bd de Clichy, 75018 Paris, France",
    "type": "french",
    "rating": 8,
    "_geo": {
      "lat": 48.8826517,
      "lng": 2.3352748
    }
  },
  {
    "id": 3,
    "name": "Artico Gelateria Tradizionale",
    "address": "Via Dogana, 1, 20123 Milan, Italy",
    "type": "ice cream",
    "rating": 10,
    "_geo": {
      "lat": 45.4632046,
      "lng": 9.1719421
    }
  },
  {
    "id": 1,
    "name": "Nàpiz' Milano",
    "address": "Viale Vittorio Veneto, 30, 20124, Milan, Italy",
    "type": "pizza",
    "rating": 9,
    "_geo": {
      "lat": 45.4777599,
      "lng": 9.1967508
    }
  }
]
```

`_geoPoint` also works when used together with other sorting rules. We can sort restaurants based on their proximity to the Eiffel Tower and their rating:

<CodeSamplesGeosearchGuideSortUsage2 />

```json
[
  {
    "id": 2,
    "name": "Bouillon Pigalle",
    "address": "22 Bd de Clichy, 75018 Paris, France",
    "type": "french",
    "rating": 8,
    "_geo": {
      "lat": 48.8826517,
      "lng": 2.3352748
    }
  },
  {
    "id": 3,
    "name": "Artico Gelateria Tradizionale",
    "address": "Via Dogana, 1, 20123 Milan, Italy",
    "type": "ice cream",
    "rating": 10,
    "_geo": {
      "lat": 45.4632046,
      "lng": 9.1719421
    }
  },
  {
    "id": 1,
    "name": "Nàpiz' Milano",
    "address": "Viale Vittorio Veneto, 30, 20124, Milan, Italy",
    "type": "pizza",
    "rating": 9,
    "_geo": {
      "lat": 45.4777599,
      "lng": 9.1967508
    }
  }
]
```
