---
title: Custom ranking rules
description: Custom ranking rules sort results based on the lexicographical order of a specified attribute.
---

There are two types of ranking rules in Meilisearch: [built-in ranking rules](/learn/relevancy/ranking_rules) and custom ranking rules. This article describes the main aspects of using and configuring custom ranking rules.

Custom ranking rules are lexicographical sorts. They order results based on the value of a specific attribute's alphabetic and numeric value.

Custom ranking rules do not take search query relevancy into consideration. In the majority of cases you should place a custom ranking after the built-in ranking rules.

- `attribute_name:asc` sorts results by increasing attribute value. For example, `price:asc` shows a product with `price: 1.00` before a product with `price: 2.00`

- `attribute_name:desc` sorts results by decreasing attribute value. For example, `price:desc` shows a product with `price: 5.00` before a product with `price: 3.00`

**The attribute must have either a numeric or a string value** in all documents contained in that index.

You can add this rule to the existing list of ranking rules using the [update settings endpoint](/reference/api/settings#update-settings) or [update ranking rules endpoint](/reference/api/settings#update-ranking-rules).

<Warning>
Custom ranking rules are simple lexicographical sorts. They sort results by ascending or descending order and ignore search result relevancy.

If you want to promote results with matches in certain attributes, add them at the beginning of the [searchable attributes list](/reference/api/settings#searchable-attributes).
</Warning>

## Example

Suppose you have a movie dataset. The documents contain the fields `release_date` with a timestamp as value, and `movie_ranking`, an integer that represents its ranking.

The following example creates a rule that makes older movies more relevant than recent ones. A movie released in 1999 will appear before a movie released in 2020.

```
release_date:asc
```

The following example will create a rule that makes movies with a good rank more relevant than movies with a lower rank. Movies with a higher ranking will appear first.

```
movie_ranking:desc
```

The following array includes all built-in ranking rules and places the custom rules at the bottom of the processing order:

```json
[
  "words",
  "typo",
  "proximity",
  "attribute",
  "sort",
  "exactness",
  "release_date:asc",
  "movie_ranking:desc"
]
```

## Sorting at search time and custom ranking rules

Meilisearch allows users to define [sorting order at query time](/learn/filtering_and_sorting/sort_search_results) by using the [`sort` search parameter](/reference/api/search#sort). There is some overlap between sorting and custom ranking rules, but the two do have different uses.

In general, `sort` will be most useful when you want to allow users to define what type of results they want to see first. A good use-case for `sort` is creating a webshop interface where customers can sort products by descending or ascending product price.

Custom ranking rules, instead, are always active once configured and are useful when you want to promote certain types of results. A good use-case for custom ranking rules is ensuring discounted products in a webshop always feature among the top results.

<Tip>
Meilisearch does not offer native support for promoting, pinning, and boosting specific documents so they are displayed more prominently than other search results. Consult these Meilisearch blog articles for workarounds on [implementing promoted search results with React InstantSearch](https://blog.meilisearch.com/promoted-search-results-with-react-instantsearch) and [document boosting](https://blog.meilisearch.com/document-boosting).
</Tip>
