---
title: Laravel multitenancy guide — Meilisearch documentation
description: Learn how to implement secure, multitenant search in your Laravel applications.
sidebarDepth: 3
---

# Laravel multitenancy guide

This guide will walk you through implementing search in a multitenant Laravel application.

## Requirements

Before proceeding, you need a working Laravel 10 application with Laravel Scout installed and configured to use the `meilisearch` driver. Follow the official [Scout documentation](https://laravel.com/docs/10.x/scout) to get started.

Additionally, you will need to have a Meilisearch server running and accessible from your Laravel application. If you don't have a Meilisearch server running, follow our [quick start guide](/learn/getting_started/cloud_quick_start) to get started with Meilisearch Cloud. If you prefer self-hosting, read our [installation guide](/learn/getting_started/installation).

To generate tenant tokens, you will need:
- A search API key
- A search API key UID — retrieve it using the [keys endpoints](/references/api/keys)

<Capsule intent="tip">
A _Search API key_ provides **read-only** access to your Meilisearch instance. You can retrieve it in your Meilisearch dashboard.
</Capsule>

## Use case

Let's use the example of a customer relationship manager (CRM) application that allows users to store contacts.

Our CRM is a multitenant application, where each user can only access data belonging to their organization. In our example, this means that users will only be able to search contacts of their organization.

On a technical level, this means:
- A `User` model that belongs to an `Organization`
- A `Contact` model that belongs to an `Organization` (can only be accessed by users from the same organization)
- An `Organization` model that has many `User` and many `Contact`s

Below you will find the Laravel code that defines such relationship between our models.

In `app/Models/Contact.php`:

```php
<?php

namespace App\Models;

use Laravel\Scout\Searchable;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class Contact extends Model
{
    use Searchable;

    public function organization(): BelongsTo
    {
        return $this->belongsTo(Organization::class, 'organization_id');
    }
}
```

In `app/Models/User.php`:

```php
<?php

namespace App\Models;

use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Laravel\Sanctum\HasApiTokens;

class User extends Authenticatable
{
    use HasApiTokens, Notifiable;

    /**
     * The attributes that are mass assignable.
     *
     * @var array<int, string>
     */
    protected $fillable = [
        'name',
        'email',
        'password',
    ];

    /**
     * The attributes that should be hidden for serialization.
     *
     * @var array<int, string>
     */
    protected $hidden = [
        'password',
        'remember_token',
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array<string, string>
     */
    protected $casts = [
        'email_verified_at' => 'datetime',
        'password' => 'hashed',
    ];

    public function organization()
    {
        return $this->belongsTo(Organization::class, 'organization_id');
    }
}
```

And in `app/Models/Organization.php`:

```php
<?php
namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Organization extends Model
{
    public function contacts(): HasMany
    {
        return $this->hasMany(Contact::class);
    }
}
```

Now that we've taken a look at our models and their relationships, let's see how to generate tenant tokens.

## Generating tenant tokens

We want to generate a tenant token for each organization. This token will be used to authenticate requests to Meilisearch and ensure that users can only access data from their organization. All `User` within the same `Organization` will share the same token.

You can choose when you want to generate the token. Here, we will generate the token when the organization is retrieved from the database. If the organization has no token, we will generate one and store it in the `meilisearch_token` attribute.

Let's update the code in our `app/Models/Organization.php` code:

```php
<?php

namespace App\Models;

use DateTime;
use Laravel\Scout\EngineManager;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Support\Facades\Log;

class Organization extends Model
{

    public function contacts(): HasMany
    {
        return $this->hasMany(Contact::class);
    }

    protected static function booted()
    {
        static::retrieved(function (Organization $organization) {
            // We can add some logic to skip generating tokens in certain environments
            if (env('SCOUT_DRIVER') === 'array' && env('APP_ENV') === 'testing') {
                $organization->meilisearch_token = 'fake-tenant-token';
                return;
            }

            // Early return if the organization already has a token
            if ($organization->meilisearch_token) {
                Log::debug('Organization ' . $organization->id . ': already has a token');
                return;
            }
            Log::debug('Generating tenant token for organization ID: ' . $organization->id);

            // The object belows is used to generate a tenant token that:
            // • applies to all indexes
            // • filters only documents where `organization_id` is equal to this org ID
            $searchRules = (object) [
                '*' => (object) [
                    'filter' => 'organization_id = ' . $organization->id,
                ]
            ];

            // Replace with your own Search API key and API key UID
            $meiliApiKey = env('MEILISEARCH_SEARCH_KEY');
            $meiliApiKeyUid = env('MEILISEARCH_SEARCH_KEY_UID');

            // Generate the token
            $token = self::generateMeiliTenantToken($meiliApiKeyUid, $searchRules, $meiliApiKey);

            // Save the token in the database
            $organization->meilisearch_token = $token;
            $organization->save();
        });
    }

    protected static function generateMeiliTenantToken($meiliApiKeyUid, $searchRules, $meiliApiKey)
    {
        $meilisearch = resolve(EngineManager::class)->engine();

        return $meilisearch->generateTenantToken(
            $meiliApiKeyUid,
            $searchRules,
            [
                'apiKey' => $meiliApiKey,
                'expiresAt' => new DateTime('2030-12-31'),
            ]
        );
    }
}
```

Now that our `Organization` model is generating tenant tokens, we need to provide the front-end with these tokens so that it can access Meilisearch securely.

## Using tenant tokens with Laravel Blade

We will use [view composers](https://laravel.com/docs/10.x/views#view-composers) to provide our views with the search token. This way, we can ensure that the token is available in all views, without having to pass it manually.

<Capsule intent="tip">
If you prefer, you can pass the token manually to each view using the `with` method.
</Capsule>

Let's create a `app/View/Composers/AuthComposer.php` file:

```php
<?php

namespace App\View\Composers;

use App\Models\User;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Vite;
use Illuminate\View\View;

class AuthComposer
{
    /**
     * Create a new profile composer.
     */
    public function __construct() {}

    /**
     * Bind data to the view.
     */
    public function compose(View $view): void
    {
        $user = Auth::user();
        $view->with([
            'meilisearchToken' => $user->organization->meilisearch_token,
        ]);
    }
}
```

Now, let's register this view composer in our `AppServiceProvider`:

```php
<?php

namespace App\Providers;

use App\View\Composers\AuthComposer;
use Illuminate\Support\Facades\View;
use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Register any application services.
     */
    public function register(): void
    {
        //
    }

    /**
     * Bootstrap any application services.
     */
    public function boot(): void
    {
        // Use this view composer in all views
        View::composer('*', AuthComposer::class);
    }
}
```

And ta-da! All of our views have access to the `meilisearchToken` variable. We can now use this variable in our frontend.

## Building the search UI

This guide uses **Vue InstantSearch** to build our search interface. Vue InstantSearch is a set of components and helpers to build a search UI in your Vue application. If you prefer other flavours of JavaScript, check out our other [front-end integrations](/learn/front_end/front_end_integration).

```js
// resources/js/vue-app.js

import { createApp } from 'vue'
import InstantSearch from 'vue-instantsearch/vue3/es'

// Vue Components
import Meilisearch from './components/Meilisearch.vue'

const app = createApp({
  components: {
    Meilisearch
  }
})

app.use(InstantSearch)
app.mount('#vue-app')
```

```php
// resources/views/components/search.blade.php

@props(['meilisearchToken'])

<div id="vue-app">
    <meilisearch index-name="companies" api-key="{{ $meilisearchToken }}" host="https://edge.meilisearch.com">
    </meilisearch>
</div>

@push('scripts')
    @vite('resources/js/vue-app.js')
@endpush
```

```html
<!-- resources/js/components/Meilisearch.vue -->

<template>
  <ais-instant-search :search-client="searchClient" :index-name="props.indexName">
    <!-- This slot allows you to render content inside this component -->
    <slot name="default"></slot>
  </ais-instant-search>
</template>

<script setup lang="ts">
import { instantMeiliSearch } from "@meilisearch/instant-meilisearch"

const props = defineProps<{
  host: string,
  apiKey: string,
  indexName: string,
}>()

const searchClient = instantMeiliSearch(
  props.host,
  props.apiKey
)
</script>
```

## Conclusion
