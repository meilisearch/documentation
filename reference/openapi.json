{
  "openapi": "3.1.0",
  "info": {
    "title": "meilisearch",
    "description": "Meilisearch HTTP server",
    "contact": {
      "name": "Quentin de Quelen",
      "email": "quentin@dequelen.me"
    },
    "license": {
      "name": "MIT",
      "identifier": "MIT"
    },
    "version": "1.30.0"
  },
  "servers": [
    {
      "url": "https://your-instance.meilisearch.io",
      "description": "Meilisearch Cloud"
    },
    {
      "url": "http://localhost:7700",
      "description": "Local server"
    }
  ],
  "paths": {
    "/batches": {
      "get": {
        "tags": [
          "Batches"
        ],
        "summary": "Get batches",
        "description": "List all batches, regardless of index. The batch objects are contained in the results array.\nBatches are always returned in descending order of uid. This means that by default, the most recently created batch objects appear first.\nBatch results are paginated and can be filtered with query parameters.",
        "operationId": "get_batches",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "u-int32",
              "default": 20,
              "minimum": 0
            },
            "example": 12
          },
          {
            "name": "from",
            "in": "query",
            "description": "Fetch the next set of results from the given uid.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "u-int32",
              "minimum": 0
            },
            "example": 12421
          },
          {
            "name": "reverse",
            "in": "query",
            "description": "The order you want to retrieve the objects.",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "example": true
          },
          {
            "name": "batchUids",
            "in": "query",
            "description": "Permits to filter tasks by their batch uid. By default, when the `batchUids` query parameter is not set, all task uids are returned. It's possible to specify several batch uids by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "u-int32",
              "minimum": 0
            },
            "example": 12421
          },
          {
            "name": "uids",
            "in": "query",
            "description": "Permits to filter tasks by their uid. By default, when the uids query parameter is not set, all task uids are returned. It's possible to specify several uids by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              231,
              423,
              598,
              "*"
            ]
          },
          {
            "name": "canceledBy",
            "in": "query",
            "description": "Permits to filter tasks using the uid of the task that canceled them. It's possible to specify several task uids by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              374,
              "*"
            ]
          },
          {
            "name": "types",
            "in": "query",
            "description": "Permits to filter tasks by their related type. By default, when `types` query parameter is not set, all task types are returned. It's possible to specify several types by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "example": [
              "documentAdditionOrUpdate",
              "*"
            ]
          },
          {
            "name": "statuses",
            "in": "query",
            "description": "Permits to filter tasks by their status. By default, when `statuses` query parameter is not set, all task statuses are returned. It's possible to specify several statuses by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Status"
              }
            },
            "example": [
              "succeeded",
              "failed",
              "canceled",
              "enqueued",
              "processing",
              "*"
            ]
          },
          {
            "name": "indexUids",
            "in": "query",
            "description": "Permits to filter tasks by their related index. By default, when `indexUids` query parameter is not set, the tasks of all the indexes are returned. It is possible to specify several indexes by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "example": [
              "movies",
              "theater",
              "*"
            ]
          },
          {
            "name": "afterEnqueuedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their enqueuedAt time. Matches tasks enqueued after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "beforeEnqueuedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their enqueuedAt time. Matches tasks enqueued before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "afterStartedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their startedAt time. Matches tasks started after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "beforeStartedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their startedAt time. Matches tasks started before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "afterFinishedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their finishedAt time. Matches tasks finished after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "beforeFinishedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their finishedAt time. Matches tasks finished before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          }
        ],
        "responses": {
          "200": {
            "description": "Return the batches",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AllBatches"
                },
                "example": {
                  "results": [
                    {
                      "uid": 2,
                      "details": {
                        "stopWords": [
                          "of",
                          "the"
                        ]
                      },
                      "progress": null,
                      "stats": {
                        "totalNbTasks": 1,
                        "status": {
                          "succeeded": 1
                        },
                        "types": {
                          "settingsUpdate": 1
                        },
                        "indexUids": {
                          "INDEX_NAME": 1
                        }
                      },
                      "duration": "PT0.110083S",
                      "startedAt": "2024-12-10T15:49:04.995321Z",
                      "finishedAt": "2024-12-10T15:49:05.105404Z"
                    }
                  ],
                  "total": 3,
                  "limit": 1,
                  "from": 2,
                  "next": 1
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "tasks.get",
              "tasks.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'http://MEILISEARCH_URL/batches'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.batches.getBatches();"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.get_batches()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->getBatches();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.batches"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.GetBatches();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let mut query = meilisearch_sdk::batches::BatchesQuery::new(&client);\nquery.with_limit(20);\nlet batches: meilisearch_sdk::batches::BatchesResults =\n  client.get_batches_with(&query).await.unwrap();"
          }
        ]
      }
    },
    "/batches/{batchUid}": {
      "get": {
        "tags": [
          "Batches"
        ],
        "summary": "Get one batch",
        "description": "Get a single batch.",
        "operationId": "get_batch",
        "parameters": [
          {
            "name": "batchUid",
            "in": "path",
            "description": "The unique batch id",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "8685"
          }
        ],
        "responses": {
          "200": {
            "description": "Return the batch",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchView"
                },
                "example": {
                  "uid": 1,
                  "details": {
                    "receivedDocuments": 1,
                    "indexedDocuments": 1
                  },
                  "progress": null,
                  "stats": {
                    "totalNbTasks": 1,
                    "status": {
                      "succeeded": 1
                    },
                    "types": {
                      "documentAdditionOrUpdate": 1
                    },
                    "indexUids": {
                      "INDEX_NAME": 1
                    }
                  },
                  "duration": "PT0.364788S",
                  "startedAt": "2024-12-10T15:48:49.672141Z",
                  "finishedAt": "2024-12-10T15:48:50.036929Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "tasks.get",
              "tasks.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'http://MEILISEARCH_URL/batches/BATCH_UID'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.batches.getBatch(BATCH_UID);"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.get_batch(BATCH_UID)"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->getBatch(BATCH_UID);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.batch(BATCH_UID)"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.GetBatch(BATCH_UID);"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let uid: u32 = 42;\nlet batch: meilisearch_sdk::batches::Batch = client\n  .get_batch(uid)\n  .await\n  .unwrap();"
          }
        ]
      }
    },
    "/dumps": {
      "post": {
        "tags": [
          "Dumps"
        ],
        "summary": "Create a dump",
        "description": "Triggers a dump creation process. Once the process is complete, a dump is created in the\n[dump directory](https://www.meilisearch.com/docs/learn/self_hosted/configure_meilisearch_at_launch#dump-directory).\nIf the dump directory does not exist yet, it will be created.",
        "operationId": "create_dump",
        "responses": {
          "202": {
            "description": "Dump is being created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 0,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "DumpCreation",
                  "enqueuedAt": "2021-01-01T09:39:00.000000Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "dumps.create",
              "dumps.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/dumps'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.createDump()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.create_dump()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->createDump();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.createDump();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.create_dump"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "resp, err := client.CreateDump()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.CreateDumpAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "client\n  .create_dump()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.createDump { result in\n    switch result {\n    case .success(let dumpStatus):\n        print(dumpStatus)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.createDump();"
          }
        ]
      }
    },
    "/experimental-features": {
      "get": {
        "tags": [
          "Experimental features"
        ],
        "summary": "Get all experimental features",
        "description": "Get a list of all experimental features that can be activated via the /experimental-features route and whether or not they are currently activated.",
        "operationId": "get_features",
        "responses": {
          "200": {
            "description": "Experimental features are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RuntimeTogglableFeatures"
                },
                "example": {
                  "metrics": true,
                  "logsRoute": false,
                  "editDocumentsByFunction": false,
                  "containsFilter": false,
                  "network": false,
                  "getTaskDocumentsRoute": false,
                  "compositeEmbedders": false,
                  "chatCompletions": false,
                  "multimodal": false,
                  "vectorStoreSetting": false
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "experimental_features.get",
              "experimental_features.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/experimental-features/'"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.experimental_features"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.ExperimentalFeatures().Get()"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let client = Client::new(\"http://localhost:7700\", Some(\"apiKey\"));\nlet features = ExperimentalFeatures::new(&client);\nlet res = features\n  .get()\n  .await\n  .unwrap();"
          }
        ]
      },
      "patch": {
        "tags": [
          "Experimental features"
        ],
        "summary": "Configure experimental features",
        "description": "Activate or deactivate experimental features.",
        "operationId": "patch_features",
        "responses": {
          "200": {
            "description": "Experimental features are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RuntimeTogglableFeatures"
                },
                "example": {
                  "metrics": true,
                  "logsRoute": false,
                  "editDocumentsByFunction": false,
                  "containsFilter": false,
                  "network": false,
                  "getTaskDocumentsRoute": false,
                  "compositeEmbedders": false,
                  "chatCompletions": false,
                  "multimodal": false,
                  "vectorStoreSetting": false
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "experimental_features.update",
              "experimental_features.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/experimental-features/' \\\n  -H 'Content-Type: application/json'  \\\n  --data-binary '{\n    \"metrics\": true\n  }'"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.update_experimental_features(metrics: true)"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.ExperimentalFeatures().SetMetrics(true).Update()"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let client = Client::new(\"http://localhost:7700\", Some(\"apiKey\"));\nlet features = ExperimentalFeatures::new(&client);\nfeatures.set_metrics(true)\nlet res = features\n  .update()\n  .await\n  .unwrap();"
          }
        ]
      }
    },
    "/export": {
      "post": {
        "tags": [
          "Export"
        ],
        "operationId": "export",
        "responses": {
          "202": {
            "description": "Export successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 1,
                  "status": "enqueued",
                  "type": "export",
                  "enqueuedAt": "2021-08-11T09:25:53.000000Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "export",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/export' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"url\": \"TARGET_INSTANCE_URL\",\n    \"indexes\": {\n      \"*\": {\n        \"overrideSettings\": true\n      }\n    }\n  }'"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "Map<String, ExportIndexFilter> indexes = new HashMap<>();\nindexes.put(\"*\", ExportIndexFilter.builder().overrideSettings(true).build());\nExportRequest request = ExportRequest.builder().url(\"TARGET_INSTANCE_URL\").indexes(indexes).build();\nclient.export(request);"
          }
        ]
      }
    },
    "/health": {
      "get": {
        "tags": [
          "Health"
        ],
        "summary": "Get Health",
        "description": "The health check endpoint enables you to periodically test the health of your Meilisearch instance.",
        "operationId": "get_health",
        "responses": {
          "200": {
            "description": "Instance is healthy",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HealthResponse"
                },
                "example": {
                  "status": "available"
                }
              }
            }
          }
        },
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/health'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.health()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.health()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->health();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.health();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.health"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Health()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.HealthAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "// health() return an Err() if the server is not healthy, so this example would panic due to the unwrap\nclient\n  .health()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.health { (result) in\n    switch result {\n    case .success:\n        print(\"Healthy!\")\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.health();"
          }
        ]
      }
    },
    "/indexes": {
      "get": {
        "tags": [
          "Indexes"
        ],
        "summary": "List indexes",
        "description": "List all indexes.",
        "operationId": "list_indexes",
        "parameters": [
          {
            "name": "offset",
            "in": "query",
            "description": "The number of indexes to skip before starting to retrieve anything",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0
            },
            "example": 100
          },
          {
            "name": "limit",
            "in": "query",
            "description": "The number of indexes to retrieve",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 20,
              "minimum": 0
            },
            "example": 1
          }
        ],
        "responses": {
          "200": {
            "description": "Indexes are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginationView_IndexView"
                },
                "example": {
                  "results": [
                    {
                      "uid": "movies",
                      "primaryKey": "movie_id",
                      "createdAt": "2019-11-20T09:40:33.711324Z",
                      "updatedAt": "2019-11-20T09:40:33.711324Z"
                    }
                  ],
                  "limit": 1,
                  "offset": 0,
                  "total": 1
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "indexes.get",
              "indexes.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes?limit=3'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.getIndexes({ limit: 3 })"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.get_indexes({'limit': 3})"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->getIndexes((new IndexesQuery())->setLimit(3));"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "IndexesQuery query = new IndexesQuery().setLimit(3);\nclient.getIndexes(query);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.indexes(limit: 3)"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.GetIndexes(&meilisearch.IndexesQuery{\n  Limit: 3,\n})"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.GetAllIndexesAsync(new IndexesQuery { Limit = 3 });"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let mut indexes = IndexesQuery::new(&client)\n  .with_limit(3)\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.getIndexes { (result) in\n    switch result {\n    case .success(let indexes):\n        print(indexes)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.getIndexes(params: IndexesQuery(limit: 3));"
          }
        ]
      },
      "post": {
        "tags": [
          "Indexes"
        ],
        "summary": "Create index",
        "description": "Create an index.",
        "operationId": "create_index",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IndexCreateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "indexCreation",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "indexes.create",
              "indexes.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"uid\": \"movies\",\n    \"primaryKey\": \"id\"\n  }'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.createIndex('movies', { primaryKey: 'id' })"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.create_index('movies', {'primaryKey': 'id'})"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->createIndex('movies', ['primaryKey' => 'id']);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.createIndex(\"movies\", \"id\");"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.create_index('movies', primary_key: 'id')"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.CreateIndex(&meilisearch.IndexConfig{\n  Uid: \"movies\",\n  PrimaryKey: \"id\",\n})"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "TaskInfo task = await client.CreateIndexAsync(\"movies\", \"id\");"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "client.create_index(\"movies\", Some(\"id\"))\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.createIndex(uid: \"movies\", primaryKey: \"id\") { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.createIndex('movies', primaryKey: 'id');"
          }
        ]
      }
    },
    "/indexes/{indexUid}": {
      "get": {
        "tags": [
          "Indexes"
        ],
        "summary": "Get index",
        "description": "Get information about an index.",
        "operationId": "get_index",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "The index is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IndexView"
                },
                "example": {
                  "uid": "movies",
                  "primaryKey": "movie_id",
                  "createdAt": "2019-11-20T09:40:33.711324Z",
                  "updatedAt": "2019-11-20T09:40:33.711324Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "Index not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Index `movies` not found.",
                  "code": "index_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#index_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "indexes.get",
              "indexes.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').getRawInfo()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.get_index('movies')"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->fetchRawInfo();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.getIndex(\"movies\");"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.fetch_index('movies')"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.GetIndex(\"movies\")"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.GetIndexAsync(\"movies\");"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let movies: Index = client\n  .get_index(\"movies\")\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.getIndex(\"movies\") { (result) in\n    switch result {\n    case .success(let index):\n        print(index)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.getIndex('movies');"
          }
        ]
      },
      "delete": {
        "tags": [
          "Indexes"
        ],
        "summary": "Delete index",
        "description": "Delete an index.",
        "operationId": "delete_index",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "202": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 0,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "indexDeletion",
                  "enqueuedAt": "2021-01-01T09:39:00.000000Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "indexes.delete",
              "indexes.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.deleteIndex('movies')"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.delete_index('movies')\n// OR\nclient.index('movies').delete()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->deleteIndex('movies');"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.deleteIndex(\"movies\");"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.delete_index('movies')"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.DeleteIndex(\"movies\")\n// OR\nclient.Index(\"movies\").Delete()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.DeleteIndexAsync(\"movies\");"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "client.index(\"movies\")\n  .delete()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"movies\").delete { (result) in\n    switch result {\n    case .success:\n        print(\"Index deleted\")\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').delete();"
          }
        ]
      },
      "patch": {
        "tags": [
          "Indexes"
        ],
        "summary": "Update index",
        "description": "Update the `primaryKey` of an index.\nReturn an error if the index doesn't exists yet or if it contains documents.",
        "operationId": "update_index",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateIndexRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 0,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "indexUpdate",
                  "enqueuedAt": "2021-01-01T09:39:00.000000Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "indexes.update",
              "indexes.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/movies' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{ \"primaryKey\": \"id\" }'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.updateIndex('movies', { primaryKey: 'id' })"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').update(primary_key='id')"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->updateIndex('movies', ['primaryKey' => 'id']);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.updateIndex(\"movies\", \"id\");"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').update(primary_key: 'movie_id')"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"movies\").UpdateIndex(&meilisearch.UpdateIndexRequestParams{\n  PrimaryKey: \"id\",\n})"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "TaskInfo task = await client.UpdateIndexAsync(\"movies\", \"id\");"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task = IndexUpdater::new(\"movies\", &client)\n  .with_primary_key(\"movie_review_id\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"movies\").update(primaryKey: \"id\") { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').update(primaryKey: 'id');"
          }
        ]
      }
    },
    "/indexes/{indexUid}/compact": {
      "post": {
        "tags": [
          "Compact an index"
        ],
        "summary": "Compact an index",
        "operationId": "compact",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "202": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "documentDeletion",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "search",
              "*"
            ]
          }
        ]
      }
    },
    "/indexes/{indexUid}/documents": {
      "get": {
        "tags": [
          "Documents"
        ],
        "summary": "Get documents",
        "description": "Get documents by batches.",
        "operationId": "get_documents",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0
            }
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0
            }
          },
          {
            "name": "fields",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "retrieveVectors",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "filter",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "popularity > 1000"
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The documents are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginationView_Value"
                },
                "example": {
                  "results": [
                    {
                      "id": 25684,
                      "title": "American Ninja 5",
                      "poster": "https://image.tmdb.org/t/p/w1280/iuAQVI4mvjI83wnirpD8GVNRVuY.jpg",
                      "overview": "When a scientists daughter is kidnapped, American Ninja, attempts to find her, but this time he teams up with a youngster he has trained in the ways of the ninja.",
                      "release_date": 725846400
                    },
                    {
                      "id": 45881,
                      "title": "The Bridge of San Luis Rey",
                      "poster": "https://image.tmdb.org/t/p/w500/4X7quIcdkc24Cveg5XdpfRqxtYA.jpg",
                      "overview": "The Bridge of San Luis Rey is American author Thornton Wilder's second novel, first published in 1927 to worldwide acclaim. It tells the story of several interrelated people who die in the collapse of an Inca rope-fiber suspension bridge in Peru, and the events that lead up to their being on the bridge.[ A friar who has witnessed the tragic accident then goes about inquiring into the lives of the victims, seeking some sort of cosmic answer to the question of why each had to die. The novel won the Pulitzer Prize in 1928.",
                      "release_date": 1072915200
                    }
                  ],
                  "limit": 20,
                  "offset": 0,
                  "total": 2
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "Index not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Index `movies` not found.",
                  "code": "index_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#index_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.get",
              "documents.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/documents?limit=2&filter=genres=action'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').getDocuments({\n  limit: 2,\n  filter: 'genres = action'\n})"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').get_documents({\n  'limit':2, 'filter': 'genres=action',\n  'sort': ['rating:desc', 'release_date:asc']  # list format\n})"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->getDocuments((new DocumentsQuery())->setFilter('genres = action')->setLimit(2));"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "DocumentsQuery query = new DocumentsQuery().setLimit(2).setFilter(new String[] {\"genres = action\"});\nclient.index(\"movies\").getDocuments(query, TargetClassName.class);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').get_documents(limit: 2, filter: 'genres = action')"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "var result meilisearch.DocumentsResult\n\nclient.Index(\"movies\").GetDocuments(&meilisearch.DocumentsQuery{\n  Limit: 2,\n  Filter: \"genres = action\",\n}, &result)"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").GetDocumentsAsync<Movie>(new DocumentsQuery() { Limit = 2, Filter = \"genres = action\" });"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let index = client.index(\"movies\");\nlet documents: DocumentsResults = DocumentsQuery::new(&index)\n  .with_filter(\"genres = action\")\n  .with_limit(2)\n  .execute::<Movies>()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"movies\").getDocuments(params: DocumentsQuery(limit: 2)) { (result: Result<DocumentsResults<Movie>, Swift.Error>) in\n    switch result {\n    case .success(let movies):\n        print(movies)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').getDocuments(\n      params: DocumentsQuery(\n        limit: 2,\n        filter: Meili.attr('genres').eq('action'.toMeiliValue()),\n      ),\n    );"
          }
        ]
      },
      "put": {
        "tags": [
          "Documents"
        ],
        "summary": "Add or update documents",
        "description": "Add a list of documents or update them if they already exist.\nIf you send an already existing document (same id) the old document will be only partially updated according to the fields of the new document. Thus, any fields not present in the new document are kept and remained unchanged.\nTo completely overwrite a document, see Add or replace documents route.\n> info\n> If the provided index does not exist, it will be created.\n> info\n> Use the reserved `_geo` object to add geo coordinates to a document. `_geo` is an object made of `lat` and `lng` field.\n>\n> When the vectorStore feature is enabled you can use the reserved `_vectors` field in your documents.\n> It can accept an array of floats, multiple arrays of floats in an outer array or an object.\n> This object accepts keys corresponding to the different embedders defined your index settings.",
        "operationId": "update_documents",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          },
          {
            "name": "primaryKey",
            "in": "query",
            "description": "The primary key of the documents. primaryKey is optional. If you want to set the primary key of your index through this route,\nit only has to be done the first time you add documents to the index. After which it will be ignored if given.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "id"
          },
          {
            "name": "csvDelimiter",
            "in": "query",
            "description": "Customize the csv delimiter when importing CSV documents.",
            "required": true,
            "schema": {
              "type": "string",
              "default": ","
            },
            "example": ";"
          },
          {
            "name": "customMetadata",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "custom"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {}
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "documentAdditionOrUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.add",
              "documents.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/documents' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    {\n      \"id\": 287947,\n      \"title\": \"Shazam \",\n      \"genres\": \"comedy\"\n    }\n  ]'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').updateDocuments([{\n    id: 287947,\n    title: 'Shazam ',\n    genres: 'comedy'\n}])"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').update_documents([{\n    'id': 287947,\n    'title': 'Shazam ',\n    'genres': 'comedy'\n}])"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->updateDocuments([\n  [\n    'id' => 287947,\n    'title' => 'Shazam ',\n    'genres' => 'comedy'\n  ]\n]);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"movies\").updateDocuments(\"[{\n  + \"\\\"id\\\": 287947,\"\n  + \"\\\"title\\\": \\\"Shazam \\\",\"\n  + \"\\\"genres\\\": \\\"comedy\\\"\"\n  + \"}]\"\n);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').update_documents([\n  {\n    id: 287947,\n    title: 'Shazam ',\n    genres: 'comedy'\n  }\n])"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "documents := []map[string]interface{}{\n  {\n    \"id\":     287947,\n    \"title\":  \"Shazam \",\n    \"genres\": \"comedy\",\n  },\n}\nclient.Index(\"movies\").UpdateDocuments(documents, nil)"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "var movie = new[]\n{\n    new Movie { Id = \"287947\", Title = \"Shazam \", Genres = \"comedy\" }\n};\nawait index.UpdateDocumentsAsync(movie);"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "// Define the type of our documents\n#[derive(Serialize, Deserialize)]\nstruct IncompleteMovie {\n  id: usize,\n  title: String,\n  genres: String\n}\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .add_or_update(&[\n    IncompleteMovie {\n      id: 287947,\n      title: \"Shazam \".to_string(),\n      genres: \"comedy\".to_string()\n    }\n  ], None)\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "let documentJsonString = \"\"\"\n[\n  {\n    \"reference_number\": 287947,\n    \"title\": \"Shazam \",\n    \"genres\": \"comedy\"\n  }\n]\n\"\"\"\nlet documents: Data = documentJsonString.data(using: .utf8)!\n\nclient.index(\"movies\").updateDocuments(documents: documents) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').updateDocuments([\n  {\n    'id': 287947,\n    'title': 'Shazam ',\n    'genres': 'comedy',\n  }\n]);"
          }
        ]
      },
      "post": {
        "tags": [
          "Documents"
        ],
        "summary": "Add or replace documents",
        "description": "Add a list of documents or replace them if they already exist.\n\nIf you send an already existing document (same id) the whole existing document will be overwritten by the new document. Fields previously in the document not present in the new document are removed.\n\nFor a partial update of the document see Add or update documents route.\n> info\n> If the provided index does not exist, it will be created.\n> info\n> Use the reserved `_geo` object to add geo coordinates to a document. `_geo` is an object made of `lat` and `lng` field.\n>\n> When the vectorStore feature is enabled you can use the reserved `_vectors` field in your documents.\n> It can accept an array of floats, multiple arrays of floats in an outer array or an object.\n> This object accepts keys corresponding to the different embedders defined your index settings.",
        "operationId": "replace_documents",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          },
          {
            "name": "primaryKey",
            "in": "query",
            "description": "The primary key of the documents. primaryKey is optional. If you want to set the primary key of your index through this route,\nit only has to be done the first time you add documents to the index. After which it will be ignored if given.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "id"
          },
          {
            "name": "csvDelimiter",
            "in": "query",
            "description": "Customize the csv delimiter when importing CSV documents.",
            "required": true,
            "schema": {
              "type": "string",
              "default": ","
            },
            "example": ";"
          },
          {
            "name": "customMetadata",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "custom"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {}
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "documentAdditionOrUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.add",
              "documents.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/documents' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    {\n      \"id\": 287947,\n      \"title\": \"Shazam\",\n      \"poster\": \"https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg\",\n      \"overview\": \"A boy is given the ability to become an adult superhero in times of need with a single magic word.\",\n      \"release_date\": \"2019-03-23\"\n    }\n  ]'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').addDocuments([{\n    id: 287947,\n    title: 'Shazam',\n    poster: 'https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg',\n    overview: 'A boy is given the ability to become an adult superhero in times of need with a single magic word.',\n    release_date: '2019-03-23'\n}])"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').add_documents([{\n  'id': 287947,\n  'title': 'Shazam',\n  'poster': 'https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg',\n  'overview': 'A boy is given the ability to become an adult superhero in times of need with a single magic word.',\n  'release_date': '2019-03-23'\n}])"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->addDocuments([\n  [\n    'id' => 287947,\n    'title' => 'Shazam',\n    'poster' => 'https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg',\n    'overview' => 'A boy is given the ability to become an adult superhero in times of need with a single magic word.',\n    'release_date' => '2019-03-23'\n  ]\n]);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"movies\").addDocuments(\"[{\"\n  + \"\\\"id\\\": 287947,\"\n  + \"\\\"title\\\": \\\"Shazam\\\",\"\n  + \"\\\"poster\\\": \\\"https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg\\\",\"\n  + \"\\\"overview\\\": \\\"A boy is given the ability to become an adult superhero in times of need with a single magic word.\\\",\"\n  + \"\\\"release_date\\\": \\\"2019-03-23\\\"\"\n  + \"}]\"\n);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').add_documents([\n  {\n    id: 287947,\n    title: 'Shazam',\n    poster: 'https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg',\n    overview: 'A boy is given the ability to become an adult superhero in times of need with a single magic word.',\n    release_date: '2019-03-23'\n  }\n])"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "documents := []map[string]interface{}{\n  {\n    \"id\":           287947,\n    \"title\":        \"Shazam\",\n    \"poster\":       \"https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg\",\n    \"overview\":     \"A boy is given the ability to become an adult superhero in times of need with a single magic word.\",\n    \"release_date\": \"2019-03-23\",\n  },\n}\nclient.Index(\"movies\").AddDocuments(documents, nil)"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "var movie = new[]\n{\n    new Movie\n    {\n          Id = \"287947\",\n          Title = \"Shazam\",\n          Poster = \"https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg\",\n          Overview = \"A boy is given the ability to become an adult superhero in times of need with a single magic word.\",\n          ReleaseDate = \"2019-03-23\"\n    }\n};\nawait index.AddDocumentsAsync(movie);"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .add_or_replace(&[\n    Movie {\n      id: 287947,\n      title: \"Shazam\".to_string(),\n      poster: \"https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg\".to_string(),\n      overview: \"A boy is given the ability to become an adult superhero in times of need with a single magic word.\".to_string(),\n      release_date: \"2019-03-23\".to_string(),\n    }\n  ], None)\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "let documentJsonString = \"\"\"\n[\n  {\n    \"reference_number\": 287947,\n    \"title\": \"Shazam\",\n    \"poster\": \"https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg\",\n    \"overview\": \"A boy is given the ability to become an adult superhero in times of need with a single magic word.\",\n    \"release_date\": \"2019-03-23\"\n  }\n]\n\"\"\"\nlet documents: Data = documentJsonString.data(using: .utf8)!\n\nclient.index(\"movies\").addDocuments(documents: documents) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').addDocuments([\n  {\n    'id': 287947,\n    'title': 'Shazam',\n    'poster':\n        'https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg',\n    'overview':\n        'A boy is given the ability to become an adult superhero in times of need with a single magic word.',\n    'release_date': '2019-03-23'\n  }\n]);"
          }
        ]
      },
      "delete": {
        "tags": [
          "Documents"
        ],
        "summary": "Delete all documents",
        "description": "Delete all documents in the specified index.",
        "operationId": "clear_all_documents",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "documentDeletion",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.delete",
              "documents.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/documents'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').deleteAllDocuments()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').delete_all_documents()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->deleteAllDocuments();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"movies\").deleteAllDocuments();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').delete_all_documents"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"movies\").DeleteAllDocuments()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").DeleteAllDocumentsAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .delete_all_documents()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"movies\").deleteAllDocuments() { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').deleteAllDocuments();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/documents/delete": {
      "post": {
        "tags": [
          "Documents"
        ],
        "summary": "Delete documents by filter",
        "description": "Delete a set of documents based on a filter.",
        "operationId": "delete_documents_by_filter",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentDeletionByFilter"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "documentDeletion",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.delete",
              "documents.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X POST MEILISEARCH_URL/indexes/movies/documents/delete \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"filter\": \"genres = action OR genres = adventure\"\n  }'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').deleteDocuments({\n  filter: 'genres = action OR genres = adventure'\n})"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').delete_documents(filter='genres=action OR genres=adventure')"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->deleteDocuments(['filter' => 'genres = action OR genres = adventure']);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "String filter = \"genres = action OR genres = adventure\";\nclient.index(\"movies\").deleteDocumentsByFilter(filter);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').delete_documents(filter: 'genres = action OR genres = adventure')"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"movies\").DeleteDocumentsByFilter(\"genres=action OR genres=adventure\")"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").DeleteDocumentsAsync(new DeleteDocumentsQuery() { Filter = \"genres = action OR genres = adventure\" });"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let index = client.index(\"movies\");\nlet task = DocumentDeletionQuery::new(&index)\n  .with_filter(\"genres = action OR genres = adventure\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').deleteDocuments(\n      DeleteDocumentsQuery(\n        filterExpression: Meili.or([\n          Meili.attr('genres').eq(Meili.value('action')),\n          Meili.attr('genres').eq(Meili.value('adventure')),\n        ]),\n      ),\n    );"
          }
        ]
      }
    },
    "/indexes/{indexUid}/documents/delete-batch": {
      "post": {
        "tags": [
          "Documents"
        ],
        "summary": "Delete documents by batch",
        "description": "Delete a set of documents based on an array of document ids.",
        "operationId": "delete_documents_batch",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {}
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "documentAdditionOrUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.delete",
              "documents.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/documents/delete-batch' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    23488,\n    153738,\n    437035,\n    363869\n  ]'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').deleteDocuments([23488, 153738, 437035, 363869])"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').delete_documents([23488, 153738, 437035, 363869])"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->deleteDocuments([23488, 153738, 437035, 363869]);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"movies\").deleteDocuments(Arrays.asList(new String[]\n{\n  \"23488\",\n  \"153738\",\n  \"437035\",\n  \"363869\"\n}));"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').delete_documents([23488, 153738, 437035, 363869])"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"movies\").DeleteDocuments([]string{\n  \"23488\",\n  \"153738\",\n  \"437035\",\n  \"363869\",\n})"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").DeleteDocumentsAsync(new[] { \"23488\", \"153738\", \"437035\", \"363869\" });"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .delete_documents(&[23488, 153738, 437035, 363869])\n  .await\n  .unwrap();"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').deleteDocuments(\n      DeleteDocumentsQuery(\n        ids: [23488, 153738, 437035, 363869],\n      ),\n    );"
          }
        ]
      }
    },
    "/indexes/{indexUid}/documents/edit": {
      "post": {
        "tags": [
          "Documents"
        ],
        "summary": "Edit documents by function.",
        "description": "Use a [RHAI function](https://rhai.rs/book/engine/hello-world.html) to edit one or more documents directly in Meilisearch.",
        "operationId": "edit_documents_by_function",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentEditionByFunction"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "documentDeletion",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.*",
              "*"
            ]
          }
        ]
      }
    },
    "/indexes/{indexUid}/documents/fetch": {
      "post": {
        "tags": [
          "Documents"
        ],
        "summary": "Get documents with POST",
        "description": "Get a set of documents.",
        "operationId": "documents_by_query_post",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BrowseQuery"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginationView_Value"
                },
                "example": {
                  "results": [
                    {
                      "title": "The Travels of Ibn Battuta",
                      "genres": [
                        "Travel",
                        "Adventure"
                      ],
                      "language": "English",
                      "rating": 4.5
                    },
                    {
                      "title": "Pride and Prejudice",
                      "genres": [
                        "Classics",
                        "Fiction",
                        "Romance",
                        "Literature"
                      ],
                      "language": "English",
                      "rating": 4
                    }
                  ],
                  "offset": 0,
                  "limit": 2,
                  "total": 5
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.delete",
              "documents.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X POST MEILISEARCH_URL/indexes/books/documents/fetch \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"filter\": \"(rating > 3 AND (genres = Adventure OR genres = Fiction)) AND language = English\",\n    \"fields\": [\"title\", \"genres\", \"rating\", \"language\"],\n    \"limit\": 3\n  }'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('books').getDocuments({\n  filter: '(rating > 3 AND (genres = Adventure OR genres = Fiction)) AND language = English',\n  fields: ['title', 'genres', 'rating', 'language'],\n  limit: 3\n})"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('books').get_documents({\n  'limit':3,\n  'fields': ['title', 'genres', 'rating', 'language'],\n  'filter': '(rating > 3 AND (genres=Adventure OR genres=Fiction)) AND language=English',\n  'sort': 'rating:desc, title:asc'  # comma-separated string format\n})"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('books')->getDocuments(\n  (new DocumentsQuery())\n    ->setFilter('(rating > 3 AND (genres = Adventure OR genres = Fiction)) AND language = English')\n    ->setLimit(3)\n    ->setFields(['title', 'genres', 'rating', 'language'])\n);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "DocumentsQuery query = new DocumentsQuery()\n  .setFilter(new String[] {\"(rating > 3 AND (genres = Adventure OR genres = Fiction)) AND language = English\"})\n  .setFields(new String[] {\"title\", \"genres\", \"rating\", \"language\"})\n  .setLimit(3);\nclient.index(\"books\").getDocuments(query, TargetClassName.class);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('books').get_documents(\n  filter: '(rating > 3 AND (genres = Adventure OR genres = Fiction)) AND language = English',\n  limit: 3,\n  fields: ['title', 'genres', 'rating', 'language']\n)"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "var result meilisearch.DocumentsResult\n\nclient.Index(\"books\").GetDocuments(&meilisearch.DocumentsQuery{\n  Fields: []string{\"title\", \"genres\", \"rating\", \"language\"},\n  Filter: \"(rating > 3 AND (genres = Adventure OR genres = Fiction)) AND language = English\",\n}, &result)"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").GetDocumentsAsync<Movie>(new DocumentsQuery() {\n    Limit = 3,\n    Fields = new List<string> { \"title\", \"genres\", \"rating\", \"language\"},\n    Filter = \"(rating > 3 AND (genres=Adventure OR genres=Fiction)) AND language=English\"\n});"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let index = client.index(\"books\");\nlet documents: DocumentsResults = DocumentsQuery::new(&index)\n  .with_filter(\"(rating > 3 AND (genres = Adventure OR genres = Fiction)) AND language = English\")\n  .with_fields([\"title\", \"genres\", \"rating\", \"language\"])\n  .with_limit(2)\n  .execute::<Movies>()\n  .await\n  .unwrap();"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').getDocuments(\n      params: DocumentsQuery(\n        filterExpression: Meili.and([\n          'language'.toMeiliAttribute().eq('English'.toMeiliValue()),\n          Meili.and([\n            'rating'.toMeiliAttribute().gt(3.toMeiliValue()),\n            Meili.or([\n              'genres'.toMeiliAttribute().eq('Adventure'.toMeiliValue()),\n              'genres'.toMeiliAttribute().eq('Fiction'.toMeiliValue()),\n            ]),\n          ]),\n        ]),\n        fields: ['title', 'genres', 'rating', 'language'],\n        limit: 3,\n      ),\n    );"
          }
        ]
      }
    },
    "/indexes/{indexUid}/documents/{documentId}": {
      "get": {
        "tags": [
          "Documents"
        ],
        "summary": "Get one document",
        "description": "Get one document from its primary key.",
        "operationId": "get_document",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          },
          {
            "name": "documentId",
            "in": "path",
            "description": "The document identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "85087"
          },
          {
            "name": "fields",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "retrieveVectors",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The document is returned",
            "content": {
              "application/json": {
                "schema": {},
                "example": {
                  "id": 25684,
                  "title": "American Ninja 5",
                  "poster": "https://image.tmdb.org/t/p/w1280/iuAQVI4mvjI83wnirpD8GVNRVuY.jpg",
                  "overview": "When a scientists daughter is kidnapped, American Ninja, attempts to find her, but this time he teams up with a youngster he has trained in the ways of the ninja.",
                  "release_date": 725846400
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "Document not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Document `a` not found.",
                  "code": "document_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#document_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.get",
              "documents.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/documents/25684?fields=id,title,poster,release_date'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client\n    .index('movies')\n    .getDocument(25684, { fields: ['id', 'title', 'poster', 'release_date'] })"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').get_document(25684, {\n  'fields': ['id', 'title', 'poster', 'release_date']\n})"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->getDocument(25684, ['id', 'title', 'poster', 'release_date']);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "DocumentQuery query = new DocumentQuery().setFields(new String[] {\"id\", \"title\", \"poster\", \"release_date\"});\nclient.index(\"movies\").getDocument(\"25684\", query);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').document(25684, fields: ['id', 'title', 'poster', 'release_date'])"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "var a interface{}\nclient.Index(\"movies\").GetDocument(\"25684\",&meilisearch.DocumentQuery{\n  Fields: []string{\"id\", \"title\", \"poster\", \"release_date\"},\n}, &a)"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").GetDocumentAsync<Movie>(25684, new List<string> { \"id\", \"title\", \"poster\", \"release_date\" });"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let index = client\n  .index(\"movies\");\nlet document = DocumentQuery::new(&index)\n  .with_fields([\"id\", \"title\", \"poster\", \"release_date\"])\n  .execute::<Movie>(\"25684\")\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"movies\").getDocument(25684) { (result: Result<Movie, Swift.Error>) in\n    switch result {\n    case .success(let movie):\n        print(movie)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').getDocument(25684,\n    fields: ['id', 'title', 'poster', 'release_date']);"
          }
        ]
      },
      "delete": {
        "tags": [
          "Documents"
        ],
        "summary": "Delete a document",
        "description": "Delete a single document by id.",
        "operationId": "delete_document",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          },
          {
            "name": "documentId",
            "in": "path",
            "description": "Document Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "853"
          }
        ],
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "documentAdditionOrUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.delete",
              "documents.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/documents/25684'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').deleteDocument(25684)"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').delete_document(25684)"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->deleteDocument(25684);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"movies\").deleteDocument(\"25684\");"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').delete_document(25684)"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"movies\").DeleteDocument(\"25684\")"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").DeleteOneDocumentAsync(\"25684\");"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .delete_document(25684)\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"movies\").deleteDocument(\"25684\") { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').deleteDocument(25684);"
          }
        ]
      }
    },
    "/indexes/{indexUid}/facet-search": {
      "post": {
        "tags": [
          "Facet Search"
        ],
        "summary": "Perform a facet search",
        "description": "Search for a facet value within a given facet.",
        "operationId": "search",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FacetSearchQuery"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The documents are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResult"
                },
                "example": {
                  "hits": [
                    {
                      "id": 2770,
                      "title": "American Pie 2",
                      "poster": "https://image.tmdb.org/t/p/w1280/q4LNgUnRfltxzp3gf1MAGiK5LhV.jpg",
                      "overview": "The whole gang are back and as close as ever. They decide to get even closer by spending the summer together at a beach house. They decide to hold the biggest",
                      "release_date": 997405200
                    },
                    {
                      "id": 190859,
                      "title": "American Sniper",
                      "poster": "https://image.tmdb.org/t/p/w1280/svPHnYE7N5NAGO49dBmRhq0vDQ3.jpg",
                      "overview": "U.S. Navy SEAL Chris Kyle takes his sole missionprotect his comradesto heart and becomes one of the most lethal snipers in American history. His pinpoint accuracy not only saves countless lives but also makes him a prime",
                      "release_date": 1418256000
                    }
                  ],
                  "offset": 0,
                  "limit": 2,
                  "estimatedTotalHits": 976,
                  "processingTimeMs": 35,
                  "query": "american "
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "Index not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Index `movies` not found.",
                  "code": "index_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#index_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "search",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/books/facet-search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"facetQuery\": \"fiction\",\n    \"facetName\": \"genres\",\n    \"filter\": \"rating > 3\"\n  }'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('books').searchForFacetValues({\n  facetQuery: 'fiction',\n  facetName: 'genres'\n  filter: 'rating > 3'\n})"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('books').facet_search('genres', 'fiction', {\n  'filter': 'rating > 3'\n})"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('books')->facetSearch(\n  (new FacetSearchQuery())\n      ->setFacetQuery('fiction')\n      ->setFacetName('genres')\n      ->setFilter(['rating > 3'])\n);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "FacetSearchRequest fsr = FacetSearchRequest.builder().facetName(\"genres\").facetQuery(\"fiction\").filter(new String[]{\"rating > 3\"}).build();\nclient.index(\"books\").facetSearch(fsr);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('books').facet_search('genres', 'fiction', filter: 'rating > 3')"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"books\").FacetSearch(&meilisearch.FacetSearchRequest{\n  FacetQuery: \"fiction\",\n  FacetName: \"genres\",\n  Filter: \"rating > 3\",\n})"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "var query = new SearchFacetsQuery()\n{\n  FacetQuery = \"fiction\",\n  Filter = \"rating > 3\"\n};\nawait client.Index(\"books\").FacetSearchAsync(\"genres\", query);"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let res = client.index(\"books\")\n  .facet_search(\"genres\")\n  .with_facet_query(\"fiction\")\n  .with_filter(\"rating > 3\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('books').facetSearch(\n      FacetSearchQuery(\n        facetQuery: 'fiction',\n        facetName: 'genres',\n        filter: 'rating > 3',\n      ),\n    );"
          }
        ]
      }
    },
    "/indexes/{indexUid}/search": {
      "get": {
        "tags": [
          "Indexes",
          "Search"
        ],
        "summary": "Search an index with GET",
        "description": "Search for documents matching a specific query in the given index.",
        "operationId": "search_with_url_query",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          },
          {
            "name": "q",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "vector",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "number",
                "format": "float"
              }
            },
            "explode": false
          },
          {
            "name": "offset",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "default": 0,
              "minimum": 0
            }
          },
          {
            "name": "limit",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "default": 20,
              "minimum": 0
            }
          },
          {
            "name": "page",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0
            }
          },
          {
            "name": "hitsPerPage",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0
            }
          },
          {
            "name": "attributesToRetrieve",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "explode": false
          },
          {
            "name": "retrieveVectors",
            "in": "query",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "attributesToCrop",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "explode": false
          },
          {
            "name": "cropLength",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "default": 10,
              "minimum": 0
            }
          },
          {
            "name": "attributesToHighlight",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "explode": false
          },
          {
            "name": "filter",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "distinct",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "showMatchesPosition",
            "in": "query",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "showRankingScore",
            "in": "query",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "showRankingScoreDetails",
            "in": "query",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "facets",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "explode": false
          },
          {
            "name": "highlightPreTag",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "default": "<em>"
            }
          },
          {
            "name": "highlightPostTag",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "default": "</em>"
            }
          },
          {
            "name": "cropMarker",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "default": ""
            }
          },
          {
            "name": "matchingStrategy",
            "in": "query",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/MatchingStrategy"
            }
          },
          {
            "name": "attributesToSearchOn",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "explode": false
          },
          {
            "name": "hybridEmbedder",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "hybridSemanticRatio",
            "in": "query",
            "required": true,
            "schema": {
              "type": "number",
              "format": "float"
            }
          },
          {
            "name": "rankingScoreThreshold",
            "in": "query",
            "required": true,
            "schema": {
              "type": "number",
              "format": "float"
            }
          },
          {
            "name": "locales",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Locale"
              }
            },
            "explode": false
          },
          {
            "name": "personalizeUserContext",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The documents are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResult"
                },
                "example": {
                  "hits": [
                    {
                      "id": 2770,
                      "title": "American Pie 2",
                      "poster": "https://image.tmdb.org/t/p/w1280/q4LNgUnRfltxzp3gf1MAGiK5LhV.jpg",
                      "overview": "The whole gang are back and as close as ever. They decide to get even closer by spending the summer together at a beach house. They decide to hold the biggest",
                      "release_date": 997405200
                    },
                    {
                      "id": 190859,
                      "title": "American Sniper",
                      "poster": "https://image.tmdb.org/t/p/w1280/svPHnYE7N5NAGO49dBmRhq0vDQ3.jpg",
                      "overview": "U.S. Navy SEAL Chris Kyle takes his sole missionprotect his comradesto heart and becomes one of the most lethal snipers in American history. His pinpoint accuracy not only saves countless lives but also makes him a prime",
                      "release_date": 1418256000
                    }
                  ],
                  "offset": 0,
                  "limit": 2,
                  "estimatedTotalHits": 976,
                  "processingTimeMs": 35,
                  "query": "american "
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "Index not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Index `movies` not found.",
                  "code": "index_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#index_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "search",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/search?q=american%20ninja'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').searchGet('American ninja')"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').search('American ninja');"
          }
        ]
      },
      "post": {
        "tags": [
          "Indexes",
          "Search"
        ],
        "summary": "Search with POST",
        "description": "Search for documents matching a specific query in the given index.",
        "operationId": "search_with_post",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SearchQuery"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The documents are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResult"
                },
                "example": {
                  "hits": [
                    {
                      "id": 2770,
                      "title": "American Pie 2",
                      "poster": "https://image.tmdb.org/t/p/w1280/q4LNgUnRfltxzp3gf1MAGiK5LhV.jpg",
                      "overview": "The whole gang are back and as close as ever. They decide to get even closer by spending the summer together at a beach house. They decide to hold the biggest",
                      "release_date": 997405200
                    },
                    {
                      "id": 190859,
                      "title": "American Sniper",
                      "poster": "https://image.tmdb.org/t/p/w1280/svPHnYE7N5NAGO49dBmRhq0vDQ3.jpg",
                      "overview": "U.S. Navy SEAL Chris Kyle takes his sole missionprotect his comradesto heart and becomes one of the most lethal snipers in American history. His pinpoint accuracy not only saves countless lives but also makes him a prime",
                      "release_date": 1418256000
                    }
                  ],
                  "offset": 0,
                  "limit": 2,
                  "estimatedTotalHits": 976,
                  "processingTimeMs": 35,
                  "query": "american "
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "Index not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Index `movies` not found.",
                  "code": "index_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#index_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "search",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{ \"q\": \"american ninja\" }'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').search('American ninja')"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').search('American ninja')"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->search('american ninja');"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"movies\").search(\"American ninja\");"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').search('american ninja')"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"movies\").Search(\"american ninja\", &meilisearch.SearchRequest{})"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").SearchAsync<Movie>(\"American ninja\");"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let results: SearchResults<Movie> = client\n  .index(\"movies\")\n  .search()\n  .with_query(\"american ninja\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "let searchParameters = SearchParameters(query: \"American ninja\")\nclient.index(\"movies\").search(searchParameters) { (result: Result<Searchable<Movie>, Swift.Error>) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').search('American ninja');"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "All settings",
        "description": "This route allows you to retrieve, configure, or reset all of an index's settings at once.",
        "operationId": "get_all",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "Settings are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Settings_Unchecked"
                },
                "example": {}
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/settings'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').getSettings()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').get_settings()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->getSettings();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"movies\").getSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').settings"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"movies\").GetSettings()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").GetSettingsAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let settings: Settings = client\n  .index(\"movies\")\n  .get_settings()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"movies\").getSettings { (result) in\n    switch result {\n    case .success(let setting):\n        print(setting)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').getSettings();"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset settings",
        "description": "Reset all the settings of an index to their default value.",
        "operationId": "delete_all",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/settings'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').resetSettings()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').reset_settings()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->resetSettings();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"movies\").resetSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').reset_settings"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"movies\").ResetSettings()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").ResetSettingsAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .reset_settings()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"movies\").resetSettings { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').resetSettings();"
          }
        ]
      },
      "patch": {
        "tags": [
          "Settings"
        ],
        "summary": "Update settings",
        "description": "Update the settings of an index.\nPassing null to an index setting will reset it to its default value.\nUpdates in the settings route are partial. This means that any parameters not provided in the body will be left unchanged.\nIf the provided index does not exist, it will be created.",
        "operationId": "update_all",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Settings_Unchecked"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/movies/settings' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"rankingRules\": [\n      \"words\",\n      \"typo\",\n      \"proximity\",\n      \"attribute\",\n      \"sort\",\n      \"exactness\",\n      \"release_date:desc\",\n      \"rank:desc\"\n    ],\n    \"distinctAttribute\": \"movie_id\",\n    \"searchableAttributes\": [\n      \"title\",\n      \"overview\",\n      \"genres\"\n    ],\n    \"displayedAttributes\": [\n      \"title\",\n      \"overview\",\n      \"genres\",\n      \"release_date\"\n    ],\n    \"stopWords\": [\n      \"the\",\n      \"a\",\n      \"an\"\n    ],\n    \"sortableAttributes\": [\n      \"title\",\n      \"release_date\"\n    ],\n    \"synonyms\": {\n      \"wolverine\": [\n        \"xmen\",\n        \"logan\"\n    ],\n      \"logan\": [\"wolverine\"]\n    },\n    \"typoTolerance\": {\n      \"minWordSizeForTypos\": {\n        \"oneTypo\": 8,\n        \"twoTypos\": 10\n      },\n      \"disableOnAttributes\": [\"title\"]\n    },\n    \"pagination\": {\n      \"maxTotalHits\": 5000\n    },\n    \"faceting\": {\n      \"maxValuesPerFacet\": 200\n    },\n    \"searchCutoffMs\": 150\n  }'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').updateSettings({\n    rankingRules: [\n        'words',\n        'typo',\n        'proximity',\n        'attribute',\n        'sort',\n        'exactness',\n        'release_date:desc',\n        'rank:desc'\n    ],\n    distinctAttribute: 'movie_id',\n    searchableAttributes: [\n        'title',\n        'overview',\n        'genres'\n    ],\n    displayedAttributes: [\n        'title',\n        'overview',\n        'genres',\n        'release_date'\n    ],\n    stopWords: [\n        'the',\n        'a',\n        'an'\n    ],\n    sortableAttributes: [\n      'title',\n      'release_date'\n    ],\n    synonyms: {\n        'wolverine': ['xmen', 'logan'],\n        'logan': ['wolverine']\n    },\n    typoTolerance: {\n        'minWordSizeForTypos': {\n            'oneTypo': 8,\n            'twoTypos': 10\n        },\n        'disableOnAttributes': [\n            'title'\n        ]\n    },\n    pagination: {\n        maxTotalHits: 5000\n    },\n    faceting: {\n        maxValuesPerFacet: 200\n    },\n    searchCutoffMs: 150\n})"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').update_settings({\n  'rankingRules': [\n    'words',\n    'typo',\n    'proximity',\n    'attribute',\n    'sort',\n    'exactness',\n    'release_date:desc',\n    'rank:desc'\n  ],\n  'distinctAttribute': 'movie_id',\n  'searchableAttributes': [\n    'title',\n    'overview',\n    'genres'\n  ],\n  'displayedAttributes': [\n    'title',\n    'overview',\n    'genres',\n    'release_date'\n  ],\n  'sortableAttributes': [\n    'title',\n    'release_date'\n  ],\n  'stopWords': [\n    'the',\n    'a',\n    'an'\n  ],\n  'synonyms': {\n    'wolverine': ['xmen', 'logan'],\n    'logan': ['wolverine']\n  },\n  'typoTolerance': {\n    'minWordSizeForTypos': {\n        'oneTypo': 8,\n        'twoTypos': 10\n    },\n    'disableOnAttributes': ['title']\n  },\n  'pagination': {\n    'maxTotalHits': 5000\n  },\n  'faceting': {\n    'maxValuesPerFacet': 200\n  },\n  'searchCutoffMs': 150\n})"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->updateSettings([\n  'rankingRules' => [\n    'words',\n    'typo',\n    'proximity',\n    'attribute',\n    'sort',\n    'exactness',\n    'release_date:desc',\n    'rank:desc'\n  ],\n  'distinctAttribute' => 'movie_id',\n  'searchableAttributes' => [\n    'title',\n    'overview',\n    'genres'\n  ],\n  'displayedAttributes' => [\n    'title',\n    'overview',\n    'genres',\n    'release_date'\n  ],\n  'stopWords' => [\n    'the',\n    'a',\n    'an'\n  ],\n  'sortableAttributes' => [\n    'title',\n    'release_date'\n  ],\n  'synonyms' => [\n    'wolverine' => ['xmen', 'logan'],\n    'logan' => ['wolverine']\n  ],\n  'typoTolerance' => [\n      'minWordSizeForTypos' => [\n        'oneTypo' => 8,\n        'twoTypos' => 10\n      ],\n      'disableOnAttributes' => ['title']\n  ],\n  'pagination' => [\n    'maxTotalHits' => 5000\n  ],\n  'faceting' => [\n    'maxValuesPerFacet' => 200\n  ],\n  'searchCutoffMs' => 150\n]);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "Settings settings = new Settings();\nsettings.setRankingRules(\n  new String[] {\n      \"words\",\n      \"typo\",\n      \"proximity\",\n      \"attribute\",\n      \"sort\",\n      \"exactness\",\n      \"release_date:desc\",\n      \"rank:desc\"\n  });\nsettings.setDistinctAttribute(\"movie_id\");\nsettings.setSearchableAttributes(\n  new String[] {\n    \"title\",\n    \"overview\",\n    \"genres\"\n  });\nsettings.setDisplayedAttributes(\n  new String[] {\n    \"title\",\n    \"overview\",\n    \"genres\",\n    \"release_date\"\n  });\nsettings.setStopWords(\n  new String[] {\n    \"the\",\n    \"a\",\n    \"an\"\n  });\nsettings.setSortableAttributes(\n  new String[] {\n    \"title\",\n    \"release_date\"\n  });\n\nHashMap<String, String[]> synonyms = new HashMap<String, String[]>();\nsynonyms.put(\"wolverine\", new String[] {\"xmen\", \"logan\"});\nsynonyms.put(\"logan\", new String[] {\"wolverine\"});\nsettings.setSynonyms(synonyms);\n\nHashMap<String, Integer> minWordSizeTypos =\n  new HashMap<String, Integer>() {\n    {\n      put(\"oneTypo\", 8);\n      put(\"twoTypos\", 10);\n    }\n  };\nTypoTolerance typoTolerance = new TypoTolerance();\ntypoTolerance.setMinWordSizeForTypos(minWordSizeTypos);\nsettings.setTypoTolerance(typoTolerance);\nsettings.setSearchCutoffMs(150);\nclient.index(\"movies\").updateSettings(settings);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').update_settings({\n  ranking_rules: [\n    'words',\n    'typo',\n    'proximity',\n    'attribute',\n    'sort',\n    'exactness',\n    'release_date:desc',\n    'rank:desc'\n  ],\n  distinct_attribute: 'movie_id',\n  searchable_attributes: [\n    'title',\n    'overview',\n    'genres'\n  ],\n  displayed_attributes: [\n    'title',\n    'overview',\n    'genres',\n    'release_date'\n  ],\n  stop_words: [\n    'the',\n    'a',\n    'an'\n  ],\n  sortable_attributes: [\n    'title',\n    'release_date'\n  ],\n  synonyms: {\n    wolverine: ['xmen', 'logan'],\n    logan: ['wolverine']\n  },\n  pagination: {\n    max_total_hits: 5000\n  },\n  faceting: {\n    max_values_per_facet: 200\n  },\n  search_cutoff_ms: 150\n})"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "distinctAttribute := \"movie_id\"\nsettings := meilisearch.Settings{\n  RankingRules: []string{\n    \"words\",\n    \"typo\",\n    \"proximity\",\n    \"attribute\",\n    \"sort\",\n    \"exactness\",\n    \"release_date:desc\",\n    \"rank:desc\",\n  },\n  DistinctAttribute: &distinctAttribute,\n  SearchableAttributes: []string{\n    \"title\",\n    \"overview\",\n    \"genres\",\n  },\n  DisplayedAttributes: []string{\n    \"title\",\n    \"overview\",\n    \"genres\",\n    \"release_date\",\n  },\n  StopWords: []string{\n    \"the\",\n    \"a\",\n    \"an\",\n  },\n  SortableAttributes: []string{\n    \"title\",\n    \"release_date\",\n  },\n  Synonyms: map[string][]string{\n    \"wolverine\": []string{\"xmen\", \"logan\"},\n    \"logan\":     []string{\"wolverine\"},\n  },\n  TypoTolerance: &meilisearch.TypoTolerance{\n    MinWordSizeForTypos: meilisearch.MinWordSizeForTypos{\n      OneTypo:  8,\n      TwoTypos: 10,\n    },\n    DisableOnAttributes: []string{\"title\"},\n  },\n  Pagination: &meilisearch.Pagination{\n    MaxTotalHits: 5000,\n  },\n  Faceting: &meilisearch.Faceting{\n    MaxValuesPerFacet: 200,\n  },\n  SearchCutoffMs: 150,\n}\nclient.Index(\"movies\").UpdateSettings(&settings)"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "Settings newSettings = new Settings\n{\n  RankingRules = new string[]\n  {\n    \"words\",\n    \"typo\",\n    \"proximity\",\n    \"attribute\",\n    \"sort\",\n    \"exactness\",\n    \"release_date:desc\",\n    \"rank:desc\"\n  },\n  DistinctAttribute = \"movie_id\",\n  SearchableAttributes = new string[] { \"title\", \"overview\", \"genres\" },\n  DisplayedAttributes = new string[] { \"title\", \"overview\", \"genres\", \"release_date\" },\n  SortableAttributes = new string[] { \"title\", \"release_date\" },\n  StopWords = new string[] { \"the\", \"a\", \"an\" },\n  Synonyms = new Dictionary<string, IEnumerable<string>>\n  {\n      { \"wolverine\", new string[] { \"xmen\", \"logan\" } },\n      { \"logan\", new string[] { \"wolverine\" } },\n  },\n  FilterableAttributes = new string[] { },\n  TypoTolerance = new TypoTolerance\n  {\n      DisableOnAttributes = new string[] { \"title\" },\n      MinWordSizeForTypos = new TypoTolerance.TypoSize\n      {\n          OneTypo = 8,\n          TwoTypos = 10\n      }\n  },\n  SearchCutoffMs = 150\n};\nTaskInfo task = await client.Index(\"movies\").UpdateSettingsAsync(newFilters);"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let mut synonyms = std::collections::HashMap::new();\nsynonyms.insert(String::from(\"wolverine\"), vec![\"xmen\", \"logan\"]);\nsynonyms.insert(String::from(\"logan\"), vec![\"wolverine\"]);\n\nlet min_word_size_for_typos = MinWordSizeForTypos {\n  one_typo: Some(4),\n  two_typos; Some(12)\n}\nlet typo_tolerance = TypoToleranceSettings {\n  enabled: Some(true),\n  disable_on_attributes: Some(vec![\"title\".to_string()]),\n  disable_on_words: Some(vec![])\n  min_word_size_for_typos: Some(min_word_size_for_typos),\n};\n\nlet settings = Settings::new()\n  .with_ranking_rules([\n    \"words\",\n    \"typo\",\n    \"proximity\",\n    \"attribute\",\n    \"sort\",\n    \"exactness\",\n    \"release_date:desc\",\n    \"rank:desc\"\n  ])\n  .with_distinct_attribute(Some(\"movie_id\"))\n  .with_searchable_attributes([\n    \"title\",\n    \"overview\",\n    \"genres\"\n  ])\n  .with_displayed_attributes([\n    \"title\",\n    \"overview\",\n    \"genres\",\n    \"release_date\"\n  ])\n  .with_stop_words([\n    \"the\",\n    \"a\",\n    \"an\"\n  ])\n  .with_sortable_attributes([\n    \"title\",\n    \"release_date\"\n  ])\n  .with_synonyms(synonyms)\n  .with_typo_tolerance(typo_tolerance)\n  .with_search_cutoff(150);\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_settings(&settings)\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "let settings = Setting(rankingRules: [\n    \"words\",\n    \"typo\",\n    \"proximity\",\n    \"attribute\",\n    \"sort\",\n    \"exactness\",\n    \"release_date:desc\",\n    \"rank:desc\"\n], searchableAttributes: [\n    \"title\",\n    \"overview\",\n    \"genres\"\n], displayedAttributes: [\n    \"title\",\n    \"overview\",\n    \"genres\",\n    \"release_date\"\n], stopWords: [\n    \"the\",\n    \"a\",\n    \"an\"\n], synonyms: [\n    \"wolverine\": [\"xmen\", \"logan\"],\n    \"logan\": [\"wolverine\"]\n], distinctAttribute: \"movie_id\",\nsortableAttributes: [\n    \"title\",\n    \"release_date\"\n])\nclient.index(\"movies\").updateSettings(settings) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').updateSettings(\n      IndexSettings(\n        rankingRules: [\n          'words',\n          'typo',\n          'proximity',\n          'attribute',\n          'sort',\n          'exactness',\n          'release_date:desc',\n          'rank:desc'\n        ],\n        distinctAttribute: 'movie_id',\n        searchableAttributes: ['title', 'overview', 'genres'],\n        displayedAttributes: [\n          'title',\n          'overview',\n          'genres',\n          'release_date'\n        ],\n        stopWords: ['the', 'a', 'an'],\n        sortableAttributes: ['title', 'release_date'],\n        synonyms: {\n          'wolverine': ['xmen', 'logan'],\n          'logan': ['wolverine'],\n        },\n      ),\n    );"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/chat": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get chat",
        "description": "Get an user defined chat",
        "operationId": "getchat",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "chat is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatSettings"
                },
                "example": {}
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset chat",
        "description": "Reset an index's chat to its default value",
        "operationId": "deletechat",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ]
      },
      "patch": {
        "tags": [
          "Settings"
        ],
        "summary": "Update chat",
        "description": "Update an index's user defined chat",
        "operationId": "patchchat",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/dictionary": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get dictionary",
        "description": "Get an user defined dictionary",
        "operationId": "getdictionary",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "dictionary is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "uniqueItems": true
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/books/settings/dictionary'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('books').getDictionary()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('books').get_dictionary()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('books')->getDictionary();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"books\").getDictionarySettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('books').dictionary"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"books\").GetDictionary()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "var indexDictionary = await client.Index(\"books\").GetDictionaryAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index('books')\n  .get_dictionary()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"books\").getDictionary { result in\n  // handle result\n}"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update dictionary",
        "description": "Update an index's user defined dictionary",
        "operationId": "putdictionary",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/books/settings/dictionary' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"J. R. R.\",\n    \"W. E. B.\"\n  ]'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('books').updateDictionary(['J. R. R.', 'W. E. B.'])"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('books').update_dictionary([\"J. R. R.\", \"W. E. B.\"])"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('books')->updateDictionary(['J. R. R.', 'W. E. B.']);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"books\").updateDictionarySettings(new String[] {\"J. R. R.\", \"W. E. B.\"});"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('books').update_dictionary(['J. R. R.', 'W. E. B.'])"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"books\").UpdateDictionary([]string{\n  \"J. R. R.\",\n  \"W. E. B.\",\n})"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "var newDictionary = new string[] { \"J. R. R.\", \"W. E. B.\" };\nawait client.Index(\"books\").UpdateDictionaryAsync(newDictionary);"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index('books')\n  .set_dictionary(['J. R. R.', 'W. E. B.'])\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"books\").updateDictionary([\"J. R. R.\", \"W. E. B.\"]) { result in\n  // handle result\n}"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset dictionary",
        "description": "Reset an index's dictionary to its default value",
        "operationId": "deletedictionary",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/books/settings/dictionary'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('books').resetDictionary()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('books').reset_dictionary()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('books')->resetDictionary();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"books\").resetDictionarySettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('books').reset_dictionary"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"books\").ResetDictionary()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"books\").ResetDictionaryAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index('books')\n  .reset_dictionary()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"books\").resetDictionary { result in\n  // handle result\n}"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/displayed-attributes": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get displayedAttributes",
        "description": "Get an user defined displayedAttributes",
        "operationId": "getdisplayedAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "displayedAttributes is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/settings/displayed-attributes'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').getDisplayedAttributes()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').get_displayed_attributes()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->getDisplayedAttributes();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"movies\").getDisplayedAttributesSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').get_displayed_attributes"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"movies\").GetDisplayedAttributes()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").GetDisplayedAttributesAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let displayed_attributes: Vec<String> = client\n  .index(\"movies\")\n  .get_displayed_attributes()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"movies\").getDisplayedAttributes { (result) in\n    switch result {\n    case .success(let displayedAttributes):\n        print(displayedAttributes)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').getDisplayedAttributes();"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update displayedAttributes",
        "description": "Update an index's user defined displayedAttributes",
        "operationId": "putdisplayedAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/displayed-attributes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"title\",\n    \"overview\",\n    \"genres\",\n    \"release_date\"\n  ]'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').updateDisplayedAttributes([\n  'title',\n  'overview',\n  'genres',\n  'release_date'\n])"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').update_displayed_attributes([\n    'title',\n    'overview',\n    'genres',\n    'release_date'\n])"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->updateDisplayedAttributes([\n  'title',\n  'overview',\n  'genres',\n  'release_date'\n]);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"movies\").updateDisplayedAttributesSettings(new String[]\n{\n  \"title\",\n  \"overview\",\n  \"genres\",\n  \"release_date\"\n});"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').update_displayed_attributes([\n  'title',\n  'overview',\n  'genres',\n  'release_date'\n])"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "displayedAttributes := []string{\n  \"title\",\n  \"overview\",\n  \"genres\",\n  \"release_date\",\n}\nclient.Index(\"movies\").UpdateDisplayedAttributes(&displayedAttributes)"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").UpdateDisplayedAttributesAsync(new[]\n{\n  \"title\",\n  \"overview\",\n  \"genres\",\n  \"release_date\"\n});"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let displayed_attributes = [\n  \"title\",\n  \"overview\",\n  \"genres\",\n  \"release_date\"\n];\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_displayed_attributes(&displayed_attributes)\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "let displayedAttributes: [String] = [\"title\", \"overview\", \"genres\", \"release_date\"]\nclient.index(\"movies\").updateDisplayedAttributes(displayedAttributes) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').updateDisplayedAttributes([\n  'title',\n  'overview',\n  'genres',\n  'release_date',\n]);"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset displayedAttributes",
        "description": "Reset an index's displayedAttributes to its default value",
        "operationId": "deletedisplayedAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/settings/displayed-attributes'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').resetDisplayedAttributes()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').reset_displayed_attributes()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->resetDisplayedAttributes();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"movies\").resetDisplayedAttributesSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').reset_displayed_attributes"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"movies\").ResetDisplayedAttributes()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").ResetDisplayedAttributesAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .reset_displayed_attributes()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"movies\").resetDisplayedAttributes { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').resetDisplayedAttributes();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/distinct-attribute": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get distinctAttribute",
        "description": "Get an user defined distinctAttribute",
        "operationId": "getdistinctAttribute",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "distinctAttribute is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                },
                "example": ""
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/shoes/settings/distinct-attribute'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('shoes').getDistinctAttribute()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('shoes').get_distinct_attribute()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('shoes')->getDistinctAttribute();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"shoes\").getDistinctAttributeSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('shoes').distinct_attribute"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"shoes\").GetDistinctAttribute()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "string result = await client.Index(\"shoes\").GetDistinctAttributeAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let distinct_attribute: Option<String> = client\n  .index(\"shoes\")\n  .get_distinct_attribute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"shoes\").getDistinctAttribute { (result) in\n    switch result {\n    case .success(let distinctAttribute):\n        print(distinctAttribute)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('shoes').getDistinctAttribute();"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update distinctAttribute",
        "description": "Update an index's user defined distinctAttribute",
        "operationId": "putdistinctAttribute",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/shoes/settings/distinct-attribute' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '\"skuid\"'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('shoes').updateDistinctAttribute('skuid')"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('shoes').update_distinct_attribute('skuid')"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('shoes')->updateDistinctAttribute('skuid');"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"shoes\").updateDistinctAttributeSettings(\"skuid\");"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('shoes').update_distinct_attribute('skuid')"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"shoes\").UpdateDistinctAttribute(\"skuid\")"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "TaskInfo result = await client.Index(\"shoes\").UpdateDistinctAttributeAsync(\"skuid\");"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"shoes\")\n  .set_distinct_attribute(\"skuid\")\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"shoes\").updateDistinctAttribute(\"skuid\") { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('shoes').updateDistinctAttribute('skuid');"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset distinctAttribute",
        "description": "Reset an index's distinctAttribute to its default value",
        "operationId": "deletedistinctAttribute",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/shoes/settings/distinct-attribute'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('shoes').resetDistinctAttribute()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('shoes').reset_distinct_attribute()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('shoes')->resetDistinctAttribute();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"shoes\").resetDistinctAttributeSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('shoes').reset_distinct_attribute"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"shoes\").ResetDistinctAttribute()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "TaskInfo result = await client.Index(\"shoes\").ResetDistinctAttributeAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"shoes\")\n  .reset_distinct_attribute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"shoes\").resetDistinctAttribute { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('shoes').resetDistinctAttribute();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/embedders": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get embedders",
        "description": "Get an user defined embedders",
        "operationId": "getembedders",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "embedders is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/SettingEmbeddingSettings"
                  },
                  "propertyNames": {
                    "type": "string"
                  }
                },
                "example": {}
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/INDEX_NAME/settings/embedders'"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('INDEX_NAME').embedders"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let embedders = index.get_embedders().await.unwrap();"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset embedders",
        "description": "Reset an index's embedders to its default value",
        "operationId": "deleteembedders",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/SettingEmbeddingSettings"
                },
                "propertyNames": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/INDEX_NAME/settings/embedders'"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('INDEX_NAME').reset_embedders"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "index.reset_embedders().await.unwrap();"
          }
        ]
      },
      "patch": {
        "tags": [
          "Settings"
        ],
        "summary": "Update embedders",
        "description": "Update an index's user defined embedders",
        "operationId": "patchembedders",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/SettingEmbeddingSettings"
                },
                "propertyNames": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/INDEX_NAME/settings/embedders' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"default\": {\n      \"source\":  \"openAi\",\n      \"apiKey\": \"OPEN_AI_API_KEY\",\n      \"model\": \"text-embedding-3-small\",\n      \"documentTemplate\": \"A document titled '{{doc.title}}' whose description starts with {{doc.overview|truncatewords: 20}}\"\n    }\n  }'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('INDEX_NAME').updateEmbedders({\n  default: {\n    source: 'openAi',\n    apiKey: 'OPEN_AI_API_KEY',\n    model: 'text-embedding-3-small',\n    documentTemplate: 'A document titled '{{doc.title}}' whose description starts with {{doc.overview|truncatewords: 20}}'\n  }\n});"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->updateEmbedders([\n  'default' => [\n    'source' => 'openAi',\n    'apiKey' => 'OPEN_AI_API_KEY',\n    'model' => 'text-embedding-3-small',\n    'documentTemplate' => 'A document titled '{{doc.title}}' whose description starts with {{doc.overview|truncatewords: 20}}'\n  ]\n]);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('INDEX_NAME').update_embedders(\n  default: {\n    source:  'openAi',\n    api_key: 'OPEN_AI_API_KEY',\n    model: 'text-embedding-3-small',\n    document_template: \"A document titled '{{doc.title}}' whose description starts with {{doc.overview|truncatewords: 20}}\"\n  }\n)"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let embedders = HashMap::from([(\n  String::from(\"default\"),\n  Embedder {\n    source: EmbedderSource::OpenAi,\n    api_key: Some(String::from(\"OPEN_AI_API_KEY\")),\n    model: Some(String::from(\"text-embedding-3-small\")),\n    document_template: Some(String::from(\"A document titled '{{doc.title}}' whose description starts with {{doc.overview|truncatewords: 20}}\")),\n    ..Embedder::default()\n  }\n)]);\nlet task = index\n  .set_embedders(&embedders)\n  .await\n  .unwrap();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/facet-search": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get facetSearch",
        "description": "Get an user defined facetSearch",
        "operationId": "getfacetSearch",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "facetSearch is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "boolean"
                },
                "example": false
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/INDEX_UID/settings/facet-search'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('INDEX_NAME').getFacetSearch();"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('books').get_facet_search_settings()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('INDEX_NAME')->getFacetSearch();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('INDEX_UID').facet_search_setting"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"books\").GetFacetSearch()"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let facet_search: bool = client\n  .index(INDEX_UID)\n  .get_facet_search()\n  .await\n  .unwrap();"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update facetSearch",
        "description": "Update an index's user defined facetSearch",
        "operationId": "putfacetSearch",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "text/plain": {
              "schema": {
                "type": "boolean"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/INDEX_UID/settings/facet-search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary 'false'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('INDEX_NAME').updateFacetSearch(false);"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('books').update_facet_search_settings(False)"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('INDEX_NAME')->updateFacetSearch(false);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('INDEX_UID').update_facet_search_setting(false)"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"books\").UpdateFacetSearch(false)"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index(INDEX_UID)\n  .set_facet_search(false)\n  .await\n  .unwrap();"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset facetSearch",
        "description": "Reset an index's facetSearch to its default value",
        "operationId": "deletefacetSearch",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "text/plain": {
              "schema": {
                "type": "boolean"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/INDEX_UID/settings/facet-search'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('INDEX_NAME').resetFacetSearch();"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('books').reset_facet_search_settings()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('INDEX_NAME')->resetFacetSearch();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('INDEX_UID').reset_facet_search_setting"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"books\").ResetFacetSearch()"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index(INDEX_UID)\n  .reset_facet_search()\n  .await\n  .unwrap();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/faceting": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get faceting",
        "description": "Get an user defined faceting",
        "operationId": "getfaceting",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "faceting is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FacetingSettings"
                },
                "example": {}
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/books/settings/faceting'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('books').getFaceting()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('books').get_faceting_settings()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('books')->getFaceting();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"books\").getFacetingSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('books').faceting"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"books\").GetFaceting()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").GetFacetingAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let faceting: FacetingSettings = client\n  .index(\"books\")\n  .get_faceting()\n  .await\n  .unwrap();"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').getFaceting();"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset faceting",
        "description": "Reset an index's faceting to its default value",
        "operationId": "deletefaceting",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FacetingSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/books/settings/faceting'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('books').resetFaceting()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('books').reset_faceting_settings()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('books')->resetFaceting();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"books\").resetFacetingSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "index('books').reset_faceting"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"books\").ResetFaceting()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").ResetFacetingAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"books\")\n  .reset_faceting()\n  .await\n  .unwrap();"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').resetFaceting();"
          }
        ]
      },
      "patch": {
        "tags": [
          "Settings"
        ],
        "summary": "Update faceting",
        "description": "Update an index's user defined faceting",
        "operationId": "patchfaceting",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FacetingSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/books/settings/faceting' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"maxValuesPerFacet\": 2,\n    \"sortFacetValuesBy\": {\n      \"*\": \"alpha\",\n      \"genres\": \"count\"\n    }\n  }'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('books').updateFaceting({\n  maxValuesPerFacet: 2\n  sortFacetValuesBy: {\n    '*': 'alpha',\n    genres: 'count'\n  }\n})"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "params = {\n  'maxValuesPerFacet': 2,\n  'sortFacetValuesBy': {\n      '*': 'count',\n      'genres': 'count'\n    }\n}\nclient.index('books').update_faceting_settings(params)"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('books')->updateFaceting([\n  'maxValuesPerFacet' => 2,\n  'sortFacetValuesBy' => ['*' => 'alpha', 'genres' => 'count']\n]);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "Faceting newFaceting = new Faceting();\nnewFaceting.setMaxValuesPerFacet(2);\nHashMap<String, FacetSortValue> facetSortValues = new HashMap<>();\nfacetSortValues.put(\"*\", FacetSortValue.ALPHA);\nfacetSortValues.put(\"genres\", FacetSortValue.COUNT);\nnewFaceting.setSortFacetValuesBy(facetSortValues);\nclient.index(\"books\").updateFacetingSettings(newFaceting);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('books').update_faceting({\n  max_values_per_facet: 2,\n  sort_facet_values_by: {\n    '*': 'alpha',\n    genres: 'count'\n  }\n})"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"books\").UpdateFaceting(&meilisearch.Faceting{\n    MaxValuesPerFacet: 2,\n    SortFacetValuesBy: {\n       \"*\":      SortFacetTypeAlpha,\n       \"genres\": SortFacetTypeCount,\n    }\n})"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "var faceting = new Faceting\n{\n    MaxValuesPerFacet = 2,\n    SortFacetValuesBy = new Dictionary<string, SortFacetValuesByType>\n    {\n        [\"*\"] = SortFacetValuesByType.Alpha,\n        [\"genres\"] = SortFacetValuesByType.Count\n    }\n};\nawait client.Index(\"books\").UpdateFacetingAsync(faceting);"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let mut facet_sort_setting = BTreeMap::new();\nfacet_sort_setting.insert(String::from(\"*\"), FacetSortValue::Alpha);\nfacet_sort_setting.insert(String::from(\"genres\"), FacetSortValue::Count);\nlet mut faceting = FacetingSettings {\n  max_values_per_facet: 2,\n  sort_facet_values_by: Some(facet_sort_setting),\n};\n\nlet task: TaskInfo = client\n  .index(\"books\")\n  .set_faceting(&faceting)\n  .await\n  .unwrap();"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('books').updateFaceting(Faceting(\n        maxValuesPerFacet: 2,\n        sortFacetValuesBy: {\n          '*': FacetingSortTypes.alpha,\n          'genres': FacetingSortTypes.count\n        }));"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/filterable-attributes": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get filterableAttributes",
        "description": "Get an user defined filterableAttributes",
        "operationId": "getfilterableAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "filterableAttributes is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/FilterableAttributesRule"
                  }
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/settings/filterable-attributes'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').getFilterableAttributes()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').get_filterable_attributes()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->getFilterableAttributes();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"movies\").getFilterableAttributesSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').filterable_attributes"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"movies\").GetFilterableAttributes()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "IEnumerable<string> attributes = await client.Index(\"movies\").GetFilterableAttributesAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let filterable_attributes: Vec<String> = client\n  .index(\"movies\")\n  .get_filterable_attributes()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"movies\").getFilterableAttributes { (result) in\n    switch result {\n    case .success(let attributes):\n        print(attributes)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').getFilterableAttributes();"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update filterableAttributes",
        "description": "Update an index's user defined filterableAttributes",
        "operationId": "putfilterableAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/FilterableAttributesRule"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/filterable-attributes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"genres\",\n    \"director\",\n    {\n      \"attributePatterns\": [\"*_ratings\"],\n      \"features\": {\n        \"facetSearch\": false,\n        \"filter\": {\n          \"equality\": true,\n          \"comparison\": false\n        }\n      }\n    }\n  ]'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies')\n  .updateFilterableAttributes([\n    \"genres\",\n    {\n      attributePatterns: [\"genre\"],\n      features: {\n        facetSearch: true,\n        filter: { equality: true, comparison: false },\n      },\n    }\n  ])"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').update_filterable_attributes([\n  'genres',\n  'director'\n])"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->updateFilterableAttributes([\n  'author',\n  [\n      'attributePatterns' => ['genres'],\n      'features' => [\n          'facetSearch' => true,\n          'filter' => [\n              'equality' => true,\n              'comparison' => false,\n          ],\n      ],\n  ],\n]);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "Settings settings = new Settings();\nsettings.setFilterableAttributes(new String[] {\"genres\", \"director\"});\nclient.index(\"movies\").updateSettings(settings);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').update_filterable_attributes([\n  'genres',\n  'director'\n])"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "filterableAttributes := []interface{}{\n  \"genres\",\n  \"director\",\n  AttributeRule{\n    AttributePatterns: []string{\"tag\"}\n    Features: AttributeFeatures{\n      FacetSearch: false,\n      Filter: FilterFeatures{\n        Equality:   true,\n        Comparison: false,\n      }\n    }\n  },\n  map[string]interface{}{\n    \"attributePatterns\": []interface{}{\"year\"}\n    \"features\": map[string]interface{}{\n      \"facetSearch\": false,\n      \"filter\": map[string]interface{}{\n        \"equality\":   true,\n        \"comparison\": true,\n      }\n    }\n  }\n}\nclient.Index(\"movies\").UpdateFilterableAttributes(&filterableAttributes)"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "List<string> attributes = new() { \"genres\", \"director\" };\nTaskInfo result = await client.Index(\"movies\").UpdateFilterableAttributesAsync(attributes);"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let filterable_attributes = [\n  \"genres\",\n  \"director\"\n];\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_filterable_attributes(&filterable_attributes)\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"movies\").updateFilterableAttributes([\"genre\", \"director\"]) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client\n    .index('movies')\n    .updateFilterableAttributes(['genres', 'director']);"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset filterableAttributes",
        "description": "Reset an index's filterableAttributes to its default value",
        "operationId": "deletefilterableAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/FilterableAttributesRule"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/settings/filterable-attributes'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').resetFilterableAttributes()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').reset_filterable_attributes()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->resetFilterableAttributes();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"movies\").resetFilterableAttributesSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').reset_filterable_attributes"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"movies\").ResetFilterableAttributes()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "TaskInfo result = await client.Index(\"movies\").ResetFilterableAttributesAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .reset_filterable_attributes()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"movies\").resetFilterableAttributes { (result) in\n    switch result {\n    case .success(let attributes):\n        print(attributes)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').resetFilterableAttributes();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/localized-attributes": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get localizedAttributes",
        "description": "Get an user defined localizedAttributes",
        "operationId": "getlocalizedAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "localizedAttributes is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/LocalizedAttributesRuleView"
                  }
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/INDEX_NAME/settings/localized-attributes'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('INDEX_NAME').getLocalizedAttributes()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('INDEX_NAME').get_localized_attributes()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('INDEX_NAME')->getLocalizedAttributes();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"INDEX_NAME\").getLocalizedAttributesSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('INDEX_NAME').localized_attributes"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.index(\"INDEX_NAME\").GetLocalizedAttributes()"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let localized_attributes: Option<Vec<LocalizedAttributes>> = client\n  .index(\"books\")\n  .get_localized_attributes()\n  .await\n  .unwrap();"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update localizedAttributes",
        "description": "Update an index's user defined localizedAttributes",
        "operationId": "putlocalizedAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/LocalizedAttributesRuleView"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/INDEX_NAME/settings/localized-attributes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    {\"locales\": [\"jpn\"], \"attributePatterns\": [\"*_ja\"]}\n  ]'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('INDEX_NAME').updateLocalizedAttributes([\n  { attributePatterns: ['*_ja'], locales: ['jpn'] },\n])"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('INDEX_NAME').update_localized_attributes([\n  {'attribute_patterns': ['*_ja'], 'locales': ['jpn']}\n])"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('INDEX_NAME')->updateLocalizedAttributes([\n  'locales' => ['jpn'],\n  'attributePatterns' => ['*_ja']\n]);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "LocalizedAttribute attribute = new LocalizedAttribute();\nattribute.setAttributePatterns(new String[] {\"jpn\"});\nattribute.setLocales(new String[] {\"*_ja\"});\n\nclient.index(\"INDEX_NAME\").updateLocalizedAttributesSettings(\n  new LocalizedAttributes[] {attribute}\n);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('INDEX_NAME').update_localized_attributes([\n  { attribute_patterns: ['*_ja'], locales: ['jpn'] },\n])"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.index(\"INDEX_NAME\").UpdateLocalizedAttributes([]*LocalizedAttributes{\n    { AttributePatterns: [\"*_ja\"], Locales: [\"jpn\"] },\n})"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let localized_attributes = vec![LocalizedAttributes {\n    locales: vec![\"jpn\".to_string()],\n    attribute_patterns: vec![\"*_ja\".to_string()],\n}];\nlet task: TaskInfo = client\n  .index(\"books\")\n  .set_localized_attributes(&localizced_attributes)\n  .await\n  .unwrap();"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset localizedAttributes",
        "description": "Reset an index's localizedAttributes to its default value",
        "operationId": "deletelocalizedAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/LocalizedAttributesRuleView"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/INDEX_NAME/settings/localized-attributes'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('INDEX_NAME').resetLocalizedAttributes()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('INDEX_NAME').reset_localized_attributes()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('INDEX_NAME')->resetLocalizedAttributes();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"INDEX_NAME\").resetLocalizedAttributesSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('INDEX_NAME').reset_localized_attributes"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.index(\"INDEX_NAME\").ResetLocalizedAttributes()"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"books\")\n  .reset_localized_attributes()\n  .await\n  .unwrap();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/non-separator-tokens": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get nonSeparatorTokens",
        "description": "Get an user defined nonSeparatorTokens",
        "operationId": "getnonSeparatorTokens",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "nonSeparatorTokens is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "uniqueItems": true
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/articles/settings/non-separator-tokens'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('books').getNonSeparatorTokens()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('articles').get_non_separator_tokens()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('articles')->getNonSeparatorTokens();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"articles\").getNonSeparatorTokensSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('articles').non_separator_tokens"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"articles\").GetNonSeparatorTokens()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").GetNonSeparatorTokensAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index('articles')\n  .get_non_separator_tokens()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"books\").getNonSeparatorTokens { result in\n  // handle result\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('articles').getNonSeparatorTokens();"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update nonSeparatorTokens",
        "description": "Update an index's user defined nonSeparatorTokens",
        "operationId": "putnonSeparatorTokens",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/articles/settings/non-separator-tokens' \\\n  -H 'Content-Type: application/json'  \\\n  --data-binary '[\"@\", \"#\"]'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('books').updateNonSeparatorTokens(['@', '#'])"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('articles').update_non_separator_tokens([\"@\", \"#\"])"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('articles')->updateNonSeparatorTokens(['@', '#']);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "String[] newSeparatorTokens = { \"@\", \"#\" };\nclient.index(\"articles\").updateNonSeparatorTokensSettings(newSeparatorTokens);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('articles').update_non_separator_tokens(['@', '#'])"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"articles\").UpdateNonSeparatorTokens([]string{\n  \"@\",\n  \"#\",\n})"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").UpdateNonSeparatorTokensAsync(new[] { \"@\", \"#\" });"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index('articles')\n  .set_non_separator_tokens(&vec!['@'.to_string(), '#'.to_string()])\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"books\").updateNonSeparatorTokens([\"@\", \"#\"]) { result in\n  // handle result\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('articles').updateNonSeparatorTokens([\"@\", \"#\"]);"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset nonSeparatorTokens",
        "description": "Reset an index's nonSeparatorTokens to its default value",
        "operationId": "deletenonSeparatorTokens",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/articles/settings/non-separator-tokens'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('books').resetNonSeparatorTokens()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('articles').reset_non_separator_tokens()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('articles')->resetNonSeparatorTokens();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"articles\").resetNonSeparatorTokensSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('articles').reset_non_separator_tokens"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"articles\").ResetNonSeparatorTokens()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").ResetNonSeparatorTokensAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index('articles')\n  .reset_non_separator_tokens()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"books\").resetNonSeparatorTokens { result in\n  // handle result\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('articles').resetNonSeparatorTokens();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/pagination": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get pagination",
        "description": "Get an user defined pagination",
        "operationId": "getpagination",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "pagination is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginationSettings"
                },
                "example": {}
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/books/settings/pagination'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('books').getPagination()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('books').get_pagination_settings()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('books')->getPagination();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"books\").getPaginationSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "index('books').pagination"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"books\").GetPagination()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").GetPaginationAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let pagination: PaginationSetting = client\n  .index(\"books\")\n  .get_pagination()\n  .await\n  .unwrap();"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').getPagination();"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset pagination",
        "description": "Reset an index's pagination to its default value",
        "operationId": "deletepagination",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PaginationSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/books/settings/pagination'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('books').resetPagination()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('books').reset_pagination_settings()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('books')->resetPagination();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"books\").resetPaginationSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "index('books').reset_pagination"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"books\").ResetPagination()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").ResetPaginationAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"books\")\n  .reset_pagination()\n  .await\n  .unwrap();"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').resetPagination();"
          }
        ]
      },
      "patch": {
        "tags": [
          "Settings"
        ],
        "summary": "Update pagination",
        "description": "Update an index's user defined pagination",
        "operationId": "patchpagination",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PaginationSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/books/settings/pagination' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"maxTotalHits\": 100\n  }'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('books').updateSettings({ pagination: { maxTotalHits: 100 }})"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('books').update_pagination_settings({'maxTotalHits': 100})"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('books')->updateSettings([\n  'pagination' => [\n    'maxTotalHits' => 100\n  ]\n]);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "Pagination newPagination = new Pagination();\nnewPagination.setMaxTotalHits(100);\nclient.index(\"books\").updatePaginationSettings(newPagination);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "index('books').update_pagination({ max_total_hits: 100 })"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"books\").UpdatePagination(&meilisearch.Pagination{\n    MaxTotalHits: 100,\n})"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "var pagination = new Pagination {\n  MaxTotalHits = 20\n};\nawait client.Index(\"movies\").UpdatePaginationAsync(pagination);"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let pagination = PaginationSetting {max_total_hits:100};\n\nlet task: TaskInfo = client\n  .index(\"books\")\n  .set_pagination(pagination)\n  .await\n  .unwrap();"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client\n    .index('books')\n    .updatePagination(Pagination(maxTotalHits: 100));"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/prefix-search": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get prefixSearch",
        "description": "Get an user defined prefixSearch",
        "operationId": "getprefixSearch",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "prefixSearch is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PrefixSearchSettings"
                },
                "example": "indexingTime"
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/INDEX_UID/settings/prefix-search'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('INDEX_NAME').getPrefixSearch();"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('books').get_prefix_search()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('INDEX_NAME')->getPrefixSearch();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('INDEX_UID').prefix_search"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"books\").GetPrefixSearch()"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let prefix_search: PrefixSearchSettings = client\n  .index(INDEX_UID)\n  .get_prefix_search()\n  .await\n  .unwrap();"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update prefixSearch",
        "description": "Update an index's user defined prefixSearch",
        "operationId": "putprefixSearch",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PrefixSearchSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/INDEX_UID/settings/prefix-search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '\"disabled\"'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('INDEX_NAME').updatePrefixSearch('disabled');"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('books').update_prefix_search(PrefixSearch.DISABLED)"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('INDEX_NAME')->updatePrefixSearch('disabled');"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('INDEX_UID').update_prefix_search('disabled')"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"books\").UpdatePrefixSearch(\"disabled\")"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index(INDEX_UID)\n  .set_prefix_search(PrefixSearchSettings::Disabled)\n  .await\n  .unwrap();"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset prefixSearch",
        "description": "Reset an index's prefixSearch to its default value",
        "operationId": "deleteprefixSearch",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PrefixSearchSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/INDEX_UID/settings/prefix-search'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('INDEX_NAME').resetPrefixSearch();"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('books').reset_prefix_search()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('INDEX_NAME')->resetPrefixSearch();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('INDEX_UID').reset_prefix_search"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"books\").ResetPrefixSearch()"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index(INDEX_UID)\n  .reset_prefix_search()\n  .await\n  .unwrap();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/proximity-precision": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get proximityPrecision",
        "description": "Get an user defined proximityPrecision",
        "operationId": "getproximityPrecision",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "proximityPrecision is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProximityPrecisionView"
                },
                "example": "byWord"
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/books/settings/proximity-precision'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('books').getProximityPrecision()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('books').get_proximity_precision()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('books')->getProximityPrecision();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"books\").getProximityPrecisionSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('books').proximity_precision"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"books\").GetProximityPrecision()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"books\").GetProximityPrecisionAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let proximity_precision: String = client\n  .index(\"books\")\n  .get_proximity_precision()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "let precisionValue = try await self.client.index(\"books\").getProximityPrecision()"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update proximityPrecision",
        "description": "Update an index's user defined proximityPrecision",
        "operationId": "putproximityPrecision",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ProximityPrecisionView"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/books/settings/proximity-precision' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '\"byAttribute\"'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('books').updateProximityPrecision('byAttribute')"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('books').update_proximity_precision(ProximityPrecision.BY_ATTRIBUTE)"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('books')->updateProximityPrecision('byAttribute');"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"books\").updateProximityPrecisionSettings(\"byAttribute\");"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('books').update_proximity_precision('byAttribute')"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"books\").UpdateProximityPrecision(ByAttribute)"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"books\").UpdateProximityPrecisionAsync(\"byAttribute\");"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"books\")\n  .set_proximity_precision(\"byAttribute\".to_string())\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "let task = try await self.client.index(\"books\").updateProximityPrecision(.byWord)"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset proximityPrecision",
        "description": "Reset an index's proximityPrecision to its default value",
        "operationId": "deleteproximityPrecision",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ProximityPrecisionView"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/books/settings/proximity-precision'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('books').resetProximityPrecision()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('books').reset_proximity_precision()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('books')->resetProximityPrecision();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"books\").resetProximityPrecisionSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('books').reset_proximity_precision"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"books\").ResetProximityPrecision()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"books\").ResetProximityPrecisionAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"books\")\n  .reset_proximity_precision()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "let task = try await self.client.index(\"books\").resetProximityPrecision()"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/ranking-rules": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get rankingRules",
        "description": "Get an user defined rankingRules",
        "operationId": "getrankingRules",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "rankingRules is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RankingRuleView"
                  }
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/settings/ranking-rules'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').getRankingRules()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').get_ranking_rules()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->getRankingRules();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"movies\").getRankingRulesSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').ranking_rules"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"movies\").GetRankingRules()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").GetRankingRulesAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let ranking_rules: Vec<String> = client\n  .index(\"movies\")\n  .get_ranking_rules()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"movies\").getRankingRules { (result) in\n    switch result {\n    case .success(let rankingRules):\n        print(rankingRules)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').getRankingRules();"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update rankingRules",
        "description": "Update an index's user defined rankingRules",
        "operationId": "putrankingRules",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/RankingRuleView"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/ranking-rules' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"words\",\n    \"typo\",\n    \"proximity\",\n    \"attribute\",\n    \"sort\",\n    \"exactness\",\n    \"release_date:asc\",\n    \"rank:desc\"\n  ]'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').updateRankingRules([\n    'words',\n    'typo',\n    'proximity',\n    'attribute',\n    'sort',\n    'exactness',\n    'release_date:asc',\n    'rank:desc'\n])"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').update_ranking_rules([\n    'words',\n    'typo',\n    'proximity',\n    'attribute',\n    'sort',\n    'exactness',\n    'release_date:asc',\n    'rank:desc'\n])"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->updateRankingRules([\n  'words',\n  'typo',\n  'proximity',\n  'attribute',\n  'sort',\n  'exactness',\n  'release_date:asc',\n  'rank:desc'\n]);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "Settings settings = new Settings();\nsettings.setRankingRules(new String[]\n{\n  \"words\",\n  \"typo\",\n  \"proximity\",\n  \"attribute\",\n  \"sort\",\n  \"exactness\",\n  \"release_date:asc\",\n  \"rank:desc\"\n});\nclient.index(\"movies\").updateSettings(settings);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').update_ranking_rules([\n  'words',\n  'typo',\n  'proximity',\n  'attribute',\n  'sort',\n  'exactness',\n  'release_date:asc',\n  'rank:desc'\n])"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "rankingRules := []string{\n  \"words\",\n  \"typo\",\n  \"proximity\",\n  \"attribute\",\n  \"sort\",\n  \"exactness\",\n  \"release_date:asc\",\n  \"rank:desc\",\n}\nclient.Index(\"movies\").UpdateRankingRules(&rankingRules)"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").UpdateRankingRulesAsync(new[]\n{\n    \"words\",\n    \"typo\",\n    \"proximity\",\n    \"attribute\",\n    \"sort\",\n    \"exactness\",\n    \"release_date:asc\",\n    \"rank:desc\"\n});"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let ranking_rules = [\n  \"words\",\n  \"typo\",\n  \"proximity\",\n  \"attribute\",\n  \"sort\",\n  \"exactness\",\n  \"release_date:asc\",\n  \"rank:desc\",\n];\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_ranking_rules(&ranking_rules)\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "let rankingRules: [String] = [\n    \"words\",\n    \"typo\",\n    \"proximity\",\n    \"attribute\",\n    \"sort\",\n    \"exactness\",\n    \"release_date:asc\",\n    \"rank:desc\"\n]\nclient.index(\"movies\").updateRankingRules(rankingRules) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').updateRankingRules([\n  'words',\n  'typo',\n  'proximity',\n  'attribute',\n  'sort',\n  'exactness',\n  'release_date:asc',\n  'rank:desc',\n]);"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset rankingRules",
        "description": "Reset an index's rankingRules to its default value",
        "operationId": "deleterankingRules",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/RankingRuleView"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/settings/ranking-rules'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').resetRankingRules()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').reset_ranking_rules()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->resetRankingRules();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"movies\").resetRankingRulesSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').reset_ranking_rules"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"movies\").ResetRankingRules()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").ResetRankingRulesAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .reset_ranking_rules()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"movies\").resetRankingRules { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').resetRankingRules();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/search-cutoff-ms": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get searchCutoffMs",
        "description": "Get an user defined searchCutoffMs",
        "operationId": "getsearchCutoffMs",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "searchCutoffMs is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "integer",
                  "format": "u-int64",
                  "minimum": 0
                },
                "example": 0
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/settings/search-cutoff-ms'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').getSearchCutoffMs()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').get_search_cutoff_ms()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->getSearchCutoffMs();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"movies\").getSearchCutoffMsSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').search_cutoff_ms"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"movies\").GetSearchCutoffMs()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "var searchCutoff = await client.Index(\"movies\").GetSearchCutoffMsAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let search_cutoff_ms: String = client\n  .index(\"movies\")\n  .get_search_cutoff_ms()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "let precisionValue = try await self.client.index(\"books\").getSearchCutoffMs()"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update searchCutoffMs",
        "description": "Update an index's user defined searchCutoffMs",
        "operationId": "putsearchCutoffMs",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "text/plain": {
              "schema": {
                "type": "integer",
                "format": "u-int64",
                "minimum": 0
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/search-cutoff-ms' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '150'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').updateSearchCutoffMs(150)"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').update_search_cutoff_ms(150)"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->updateSearchCutoffMs(150);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"movies\").updateSearchCutoffMsSettings(150);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').update_search_cutoff_ms(150)"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"movies\").UpdateSearchCutoffMs(150)"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").UpdateSearchCutoffMsAsync(150);"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .set_search_cutoff_ms(Some(150))\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "let task = try await self.client.index(\"books\").updateSearchCutoffMs(150)"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset searchCutoffMs",
        "description": "Reset an index's searchCutoffMs to its default value",
        "operationId": "deletesearchCutoffMs",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "text/plain": {
              "schema": {
                "type": "integer",
                "format": "u-int64",
                "minimum": 0
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/settings/search-cutoff-ms'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').resetSearchCutoffMs()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').reset_search_cutoff_ms()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->resetSearchCutoffMs();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"movies\").resetSearchCutoffMsSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').reset_search_cutoff_ms"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"books\").ResetSearchCutoffMs()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").ResetSearchCutoffMsAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .reset_search_cutoff_ms()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "let task = try await self.client.index(\"books\").resetSearchCutoffMs()"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/searchable-attributes": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get searchableAttributes",
        "description": "Get an user defined searchableAttributes",
        "operationId": "getsearchableAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "searchableAttributes is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/settings/searchable-attributes'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').getSearchableAttributes()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').get_searchable_attributes()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->getSearchableAttributes();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"movies\").getSearchableAttributesSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').searchable_attributes"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"movies\").GetSearchableAttributes()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").GetSearchableAttributesAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let searchable_attributes: Vec<String> = client\n  .index(\"movies\")\n  .get_searchable_attributes()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"movies\").getSearchableAttributes { (result) in\n    switch result {\n    case .success(let searchableAttributes):\n        print(searchableAttributes)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').getSearchableAttributes();"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update searchableAttributes",
        "description": "Update an index's user defined searchableAttributes",
        "operationId": "putsearchableAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/searchable-attributes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"title\",\n    \"overview\",\n    \"genres\"\n  ]'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').updateSearchableAttributes([\n  'title',\n  'overview',\n  'genres'\n])"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').update_searchable_attributes([\n    'title',\n    'overview',\n    'genres'\n])"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->updateSearchableAttributes([\n  'title',\n  'overview',\n  'genres'\n]);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"movies\").updateSearchableAttributesSettings(new String[]\n{\n  \"title\",\n  \"overview\",\n  \"genres\"\n});"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').update_searchable_attributes([\n  'title',\n  'overview',\n  'genres'\n])"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "searchableAttributes := []string{\n  \"title\",\n  \"overview\",\n  \"genres\",\n}\nclient.Index(\"movies\").UpdateSearchableAttributes(&searchableAttributes)"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").UpdateSearchableAttributesAsync(new[] {\"title\", \"overview\", \"genres\"});"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let searchable_attributes = [\n  \"title\",\n  \"overview\",\n  \"genres\"\n];\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_searchable_attributes(&searchable_attributes)\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "let searchableAttributes: [String] = [\"title\", \"overview\", \"genres\"]\nclient.index(\"movies\").updateSearchableAttributes(searchableAttributes) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client\n    .index('movies')\n    .updateSearchableAttributes(['title', 'overview', 'genres']);"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset searchableAttributes",
        "description": "Reset an index's searchableAttributes to its default value",
        "operationId": "deletesearchableAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/settings/searchable-attributes'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').resetSearchableAttributes()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').reset_searchable_attributes()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->resetSearchableAttributes();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"movies\").resetSearchableAttributesSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').reset_searchable_attributes"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"movies\").ResetSearchableAttributes()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").ResetSearchableAttributesAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .reset_searchable_attributes()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"movies\").resetSearchableAttributes { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').resetSearchableAttributes();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/separator-tokens": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get separatorTokens",
        "description": "Get an user defined separatorTokens",
        "operationId": "getseparatorTokens",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "separatorTokens is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "uniqueItems": true
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/articles/settings/separator-tokens'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('books').getSeparatorTokens()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('articles').get_separator_tokens()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('articles')->getSeparatorTokens();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"articles\").getSeparatorTokensSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('articles').separator_tokens"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"articles\").GetSeparatorTokens()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").GetSeparatorTokensAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index('articles')\n  .get_separator_tokens()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"books\").getSeparatorTokens { result in\n  // handle result\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('articles').getSeparatorTokens();"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update separatorTokens",
        "description": "Update an index's user defined separatorTokens",
        "operationId": "putseparatorTokens",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/articles/settings/separator-tokens' \\\n  -H 'Content-Type: application/json'  \\\n  --data-binary '[\"|\", \"&hellip;\"]'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('books').updateSeparatorTokens(['|', '&hellip;'])"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('articles').update_separator_tokens([\"|\", \"&hellip;\"])"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('articles')->updateSeparatorTokens(['|', '&hellip;']);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "String[] newSeparatorTokens = { \"|\", \"&hellip;\" };\nclient.index(\"articles\").updateSeparatorTokensSettings(newSeparatorTokens);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('articles').update_separator_tokens(['|', '&hellip;'])"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"articles\").UpdateSeparatorTokens([]string{\n  \"|\",\n  \"&hellip;\",\n})"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").UpdateSeparatorTokensAsync(new[] { \"|\", \"&hellip;\" });"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index('articles')\n  .set_separator_tokens(&vec!['|'.to_string(), '&hellip;'.to_string()])\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"books\").updateSeparatorTokens([\"|\", \"&hellip;\"]) { result in\n  // handle result\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('articles').updateSeparatorTokens([\"|\", \"&hellip;\"]);"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset separatorTokens",
        "description": "Reset an index's separatorTokens to its default value",
        "operationId": "deleteseparatorTokens",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/articles/settings/separator-tokens'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('books').resetSeparatorTokens()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('articles').reset_separator_tokens()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('articles')->resetSeparatorTokens();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"articles\").resetSeparatorTokensSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('articles').reset_separator_tokens"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"articles\").ResetSeparatorTokens()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").ResetSeparatorTokensAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index('articles')\n  .reset_separator_tokens()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"books\").resetSeparatorTokens { result in\n  // handle result\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('articles').resetSeparatorTokens();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/sortable-attributes": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get sortableAttributes",
        "description": "Get an user defined sortableAttributes",
        "operationId": "getsortableAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "sortableAttributes is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "uniqueItems": true
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/books/settings/sortable-attributes'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('books').getSortableAttributes()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('books').get_sortable_attributes()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('books')->getSortableAttributes();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"books\").getSortableAttributesSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('books').sortable_attributes"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"books\").GetSortableAttributes()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"books\").GetSortableAttributesAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let sortable_attributes: Vec<String> = client\n  .index(\"books\")\n  .get_sortable_attributes()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"books\").getSortableAttributes { (result: Result<Searchable<Book>, Swift.Error>) in\n  switch result {\n  case .success(let attributes):\n    print(attributes)\n  case .failure(let error):\n    print(error)\n  }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('books').getSortableAttributes();"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update sortableAttributes",
        "description": "Update an index's user defined sortableAttributes",
        "operationId": "putsortableAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/books/settings/sortable-attributes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"price\",\n    \"author\"\n  ]'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('books')\n  .updateSortableAttributes([\n    'price',\n    'author'\n  ])"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('books').update_sortable_attributes([\n  'price',\n  'author'\n])"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('books')->updateSortableAttributes([\n  'price',\n  'author'\n]);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"books\").updateSortableAttributesSettings(new String[] {\"price\", \"author\"});"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('books').update_sortable_attributes([\n  'price',\n  'author'\n])"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "sortableAttributes := []string{\n  \"price\",\n  \"author\",\n}\nclient.Index(\"books\").UpdateSortableAttributes(&sortableAttributes)"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"books\").UpdateSortableAttributesAsync(new [] { \"price\", \"author\" });"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let sortable_attributes = [\n  \"price\",\n  \"author\"\n];\n\nlet task: TaskInfo = client\n  .index(\"books\")\n  .set_sortable_attributes(&sortable_attributes)\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"books\").updateSortableAttributes([\"price\", \"author\"]) { (result) in\n  switch result {\n  case .success(let task):\n    print(task)\n  case .failure(let error):\n    print(error)\n  }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('books').updateSortableAttributes(['price', 'author']);"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset sortableAttributes",
        "description": "Reset an index's sortableAttributes to its default value",
        "operationId": "deletesortableAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/books/settings/sortable-attributes'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('books').resetSortableAttributes()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('books').reset_sortable_attributes()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('books')->resetSortableAttributes();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"books\").resetSortableAttributesSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('books').reset_sortable_attributes"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"books\").ResetSortableAttributes()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"books\").ResetSortableAttributesAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"books\")\n  .reset_sortable_attributes()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"books\").resetSortableAttributes() { (result) in\n  switch result {\n  case .success(let attributes):\n    print(attributes)\n  case .failure(let error):\n    print(error)\n  }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('books').resetSortableAttributes();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/stop-words": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get stopWords",
        "description": "Get an user defined stopWords",
        "operationId": "getstopWords",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "stopWords is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "uniqueItems": true
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/settings/stop-words'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').getStopWords()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').get_stop_words()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->getStopWords();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"movies\").getStopWordsSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').stop_words"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"movies\").GetStopWords()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").GetStopWordsAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let stop_words: Vec<String> = client\n  .index(\"movies\")\n  .get_stop_words()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"movies\").getStopWords { (result) in\n    switch result {\n    case .success(let stopWords):\n        print(stopWords)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').getStopWords();"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update stopWords",
        "description": "Update an index's user defined stopWords",
        "operationId": "putstopWords",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/stop-words' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"the\",\n    \"of\",\n    \"to\"\n  ]'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').updateStopWords(['of', 'the', 'to'])"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').update_stop_words(['of', 'the', 'to'])"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->updateStopWords(['the', 'of', 'to']);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"movies\").updateStopWordsSettings(new String[] {\"of\", \"the\", \"to\"});"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').update_stop_words(['of', 'the', 'to'])"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "stopWords := []string{\"of\", \"the\", \"to\"}\nclient.Index(\"movies\").UpdateStopWords(&stopWords)"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").UpdateStopWordsAsync(new[] {\"of\", \"the\", \"to\"});"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let stop_words = [\"of\", \"the\", \"to\"];\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_stop_words(&stop_words)\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "let stopWords: [String] = [\"of\", \"the\", \"to\"]\nclient.index(\"movies\").updateStopWords(stopWords) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').updateStopWords(['of', 'the', 'to']);"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset stopWords",
        "description": "Reset an index's stopWords to its default value",
        "operationId": "deletestopWords",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/settings/stop-words'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').resetStopWords()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').reset_stop_words()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->resetStopWords();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"movies\").resetStopWordsSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').reset_stop_words"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"movies\").ResetStopWords()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").ResetStopWordsAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .reset_stop_words()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"movies\").resetStopWords { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').resetStopWords();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/synonyms": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get synonyms",
        "description": "Get an user defined synonyms",
        "operationId": "getsynonyms",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "synonyms is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "propertyNames": {
                    "type": "string"
                  }
                },
                "example": {}
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/settings/synonyms'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').getSynonyms()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').get_synonyms()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->getSynonyms();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"movies\").getSynonymsSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').synonyms"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"movies\").GetSynonyms()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").GetSynonymsAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let synonyms: HashMap<String, Vec<String>> = client\n  .index(\"movies\")\n  .get_synonyms()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"movies\").getSynonyms { (result) in\n    switch result {\n    case .success(let synonyms):\n        print(synonyms)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').getSynonyms();"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update synonyms",
        "description": "Update an index's user defined synonyms",
        "operationId": "putsynonyms",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "additionalProperties": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "propertyNames": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/synonyms' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"wolverine\": [\n      \"xmen\",\n      \"logan\"\n    ],\n    \"logan\": [\n      \"wolverine\",\n      \"xmen\"\n    ],\n    \"wow\": [\"world of warcraft\"]\n  }'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').updateSynonyms({\n  wolverine: ['xmen', 'logan'],\n  logan: ['wolverine', 'xmen'],\n  wow: ['world of warcraft']\n})"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').update_synonyms({\n  'wolverine': ['xmen', 'logan'],\n  'logan': ['wolverine', 'xmen'],\n  'wow': ['world of warcraft']\n})"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->updateSynonyms([\n  'wolverine' => ['xmen', 'logan'],\n  'logan' => ['wolverine', 'xmen'],\n  'wow' => ['world of warcraft']\n]);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "HashMap<String, String[]> synonyms = new HashMap<String, String[]>();\nsynonyms.put(\"wolverine\", new String[] {\"xmen\", \"logan\"});\nsynonyms.put(\"logan\", new String[] {\"wolverine\"});\nclient.index(\"movies\").updateSynonymsSettings(synonyms);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').update_synonyms({\n  wolverine: ['xmen', 'logan'],\n  logan: ['wolverine', 'xmen'],\n  wow: ['world of warcraft']\n})"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "synonyms := map[string][]string{\n  \"wolverine\": []string{\"xmen\", \"logan\"},\n  \"logan\":     []string{\"wolverine\", \"xmen\"},\n  \"wow\":       []string{\"world of warcraft\"},\n}\nclient.Index(\"movies\").UpdateSynonyms(&synonyms)"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "var synonyms = new Dictionary<string, IEnumerable<string>>\n{\n    { \"wolverine\", new string[] { \"xmen\", \"logan\" } },\n    { \"logan\", new string[] { \"wolverine\", \"xmen\" } },\n    { \"wow\", new string[] { \"world of warcraft\" } }\n};\nawait client.Index(\"movies\").UpdateSynonymsAsync(synonyms);"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let mut synonyms = std::collections::HashMap::new();\nsynonyms.insert(String::from(\"wolverine\"), vec![String::from(\"xmen\"), String::from(\"logan\")]);\nsynonyms.insert(String::from(\"logan\"), vec![String::from(\"xmen\"), String::from(\"wolverine\")]);\nsynonyms.insert(String::from(\"wow\"), vec![String::from(\"world of warcraft\")]);\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_synonyms(&synonyms)\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "let synonyms: [String: [String]] = [\n    \"wolverine\": [\"xmen\", \"logan\"],\n    \"logan\": [\"wolverine\", \"xmen\"],\n    \"wow\": [\"world of warcraft\"]\n]\nclient.index(\"movies\").updateSynonyms(synonyms) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').updateSynonyms({\n  'wolverine': ['xmen', 'logan'],\n  'logan': ['wolverine', 'xmen'],\n  'wow': ['world of warcraft'],\n});"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset synonyms",
        "description": "Reset an index's synonyms to its default value",
        "operationId": "deletesynonyms",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "additionalProperties": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "propertyNames": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/settings/synonyms'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').resetSynonyms()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').reset_synonyms()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->resetSynonyms();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"movies\").resetSynonymsSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').reset_synonyms"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"movies\").ResetSynonyms()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").ResetSynonymsAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .reset_synonyms()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"movies\").resetSynonyms { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').resetSynonyms();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/typo-tolerance": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get typoTolerance",
        "description": "Get an user defined typoTolerance",
        "operationId": "gettypoTolerance",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "typoTolerance is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TypoSettings"
                },
                "example": {}
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/books/settings/typo-tolerance'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('books').getTypoTolerance()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('books').get_typo_tolerance()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('books')->getTypoTolerance();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"books\").getTypoToleranceSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "index('books').typo_tolerance"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"books\").GetTypoTolerance()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"books\").GetTypoToleranceAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let typo_tolerance: TypoToleranceSettings = client\n  .index(\"books\")\n  .get_typo_tolerance()\n  .await\n  .unwrap();"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('books').getTypoTolerance();"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset typoTolerance",
        "description": "Reset an index's typoTolerance to its default value",
        "operationId": "deletetypoTolerance",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TypoSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/books/settings/typo-tolerance'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('books').resetTypoTolerance()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('books').reset_typo_tolerance()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('books')->resetTypoTolerance();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"books\").resetTypoToleranceSettings();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "index('books').reset_typo_tolerance"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"books\").ResetTypoTolerance()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"books\").ResetTypoToleranceAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"books\")\n  .reset_typo_tolerance()\n  .await\n  .unwrap();"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('books').resetTypoTolerance();"
          }
        ]
      },
      "patch": {
        "tags": [
          "Settings"
        ],
        "summary": "Update typoTolerance",
        "description": "Update an index's user defined typoTolerance",
        "operationId": "patchtypoTolerance",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TypoSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/books/settings/typo-tolerance' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"minWordSizeForTypos\": {\n      \"oneTypo\": 4,\n      \"twoTypos\": 10\n    },\n    \"disableOnAttributes\": [\"title\"]\n  }'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('books').updateTypoTolerance({\n  minWordSizeForTypos: {\n      oneTypo: 4,\n      twoTypos: 10\n    },\n    disableOnAttributes: [\n      'title'\n  ]\n})"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('books').update_typo_tolerance({\n  'minWordSizeForTypos': {\n      'oneTypo': 4,\n      'twoTypos': 10\n    },\n    'disableOnAttributes': [\n       'title'\n    ]\n})"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('books')->updateTypoTolerance([\n  'minWordSizeForTypos' => [\n      'oneTypo' => 4,\n      'twoTypos' => 10\n    ],\n    'disableOnAttributes' => [\n      'title'\n  ]\n]);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "TypoTolerance typoTolerance = new TypoTolerance();\nHashMap<String, Integer> minWordSizeTypos =\n        new HashMap<String, Integer>() {\n            {\n                put(\"oneTypo\", 4);\n                put(\"twoTypos\", 10);\n            }\n        };\n\ntypoTolerance.setMinWordSizeForTypos(minWordSizeTypos);\ntypoTolerance.setDisableOnAttributes(new String[] {\"title\"});\n\nclient.index(\"books\").updateTypoToleranceSettings(typoTolerance);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "index('books').update_typo_tolerance({\n  min_word_size_for_typos: {\n    one_typo: 4,\n    two_typos: 10\n  },\n  disable_on_attributes: ['title']\n})"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"books\").UpdateTypoTolerance(&meilisearch.TypoTolerance{\n  MinWordSizeForTypos: meilisearch.MinWordSizeForTypos{\n      OneTypo: 4,\n      TwoTypos: 10,\n    },\n    DisableOnAttributes: []string{\"title\"},\n})"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "var typoTolerance = new TypoTolerance {\n  DisableOnAttributes = new string[] { \"title\" },\n  MinWordSizeTypos = new TypoTolerance.TypoSize {\n      OneTypo = 4,\n      TwoTypos = 10\n  }\n};\n\nawait client.Index(\"books\").UpdateTypoToleranceAsync(typoTolerance);"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let typo_tolerance = TypoToleranceSettings {\n  enabled: Some(false),\n  disable_on_attributes: None,\n  disable_on_words: None,\n  min_word_size_for_typos: None,\n};\n\nlet task: TaskInfo = client\n  .index(\"books\")\n  .set_typo_tolerance(&typo_tolerance)\n  .await\n  .unwrap();"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "final toUpdate = TypoTolerance(\n  minWordSizeForTypos: MinWordSizeForTypos(\n    oneTypo: 4,\n    twoTypos: 10,\n  ),\n  disableOnAttributes: ['title'],\n);\nawait client.index('books').updateTypoTolerance(toUpdate);"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/vector-store": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get vectorStore",
        "description": "Get an user defined vectorStore",
        "operationId": "getvectorStore",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "vectorStore is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VectorStoreBackend"
                },
                "example": "stable"
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/INDEX_UID/settings/vector-store'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset vectorStore",
        "description": "Reset an index's vectorStore to its default value",
        "operationId": "deletevectorStore",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VectorStoreBackend"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/INDEX_UID/settings/vector-store'"
          }
        ]
      },
      "patch": {
        "tags": [
          "Settings"
        ],
        "summary": "Update vectorStore",
        "description": "Update an index's user defined vectorStore",
        "operationId": "patchvectorStore",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VectorStoreBackend"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/INDEX_UID/settings/vector-store' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '\"experimental\"'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/similar": {
      "get": {
        "tags": [
          "Similar documents"
        ],
        "summary": "Get similar documents with GET",
        "description": "Retrieve documents similar to a specific search result.",
        "operationId": "similar_get",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          },
          {
            "name": "id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "default": 0,
              "minimum": 0
            }
          },
          {
            "name": "limit",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "default": 20,
              "minimum": 0
            }
          },
          {
            "name": "attributes_to_retrieve",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "retrieve_vectors",
            "in": "query",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "show_ranking_score",
            "in": "query",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "show_ranking_score_details",
            "in": "query",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "ranking_score_threshold",
            "in": "query",
            "required": false,
            "schema": {
              "type": "number",
              "format": "float"
            }
          },
          {
            "name": "embedder",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The documents are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimilarResult"
                },
                "example": {
                  "hits": [
                    {
                      "id": 2770,
                      "title": "American Pie 2",
                      "poster": "https://image.tmdb.org/t/p/w1280/q4LNgUnRfltxzp3gf1MAGiK5LhV.jpg",
                      "overview": "The whole gang are back and as close as ever. They decide to get even closer by spending the summer together at a beach house. They decide to hold the biggest",
                      "release_date": 997405200
                    },
                    {
                      "id": 190859,
                      "title": "American Sniper",
                      "poster": "https://image.tmdb.org/t/p/w1280/svPHnYE7N5NAGO49dBmRhq0vDQ3.jpg",
                      "overview": "U.S. Navy SEAL Chris Kyle takes his sole missionprotect his comradesto heart and becomes one of the most lethal snipers in American history. His pinpoint accuracy not only saves countless lives but also makes him a prime",
                      "release_date": 1418256000
                    }
                  ],
                  "offset": 0,
                  "limit": 2,
                  "estimatedTotalHits": 976,
                  "processingTimeMs": 35,
                  "query": "american "
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "Index not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Index `movies` not found.",
                  "code": "index_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#index_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "search",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/INDEX_NAME/similar?id=TARGET_DOCUMENT_ID&embedder=EMBEDDER_NAME'"
          }
        ]
      },
      "post": {
        "tags": [
          "Similar documents"
        ],
        "summary": "Get similar documents with POST",
        "description": "Retrieve documents similar to a specific search result.",
        "operationId": "similar_post",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SimilarQuery"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The documents are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimilarResult"
                },
                "example": {
                  "hits": [
                    {
                      "id": 2770,
                      "title": "American Pie 2",
                      "poster": "https://image.tmdb.org/t/p/w1280/q4LNgUnRfltxzp3gf1MAGiK5LhV.jpg",
                      "overview": "The whole gang are back and as close as ever. They decide to get even closer by spending the summer together at a beach house. They decide to hold the biggest",
                      "release_date": 997405200
                    },
                    {
                      "id": 190859,
                      "title": "American Sniper",
                      "poster": "https://image.tmdb.org/t/p/w1280/svPHnYE7N5NAGO49dBmRhq0vDQ3.jpg",
                      "overview": "U.S. Navy SEAL Chris Kyle takes his sole missionprotect his comradesto heart and becomes one of the most lethal snipers in American history. His pinpoint accuracy not only saves countless lives but also makes him a prime",
                      "release_date": 1418256000
                    }
                  ],
                  "offset": 0,
                  "limit": 2,
                  "estimatedTotalHits": 976,
                  "processingTimeMs": 35,
                  "query": "american "
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "Index not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Index `movies` not found.",
                  "code": "index_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#index_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "search",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/INDEX_NAME/similar' \\\n  -H 'Content-Type: application/json' \\\n  -H 'Authorization: Bearer DEFAULT_SEARCH_API_KEY' \\\n  --data-binary '{\n    \"id\": TARGET_DOCUMENT_ID,\n    \"embedder\": \"EMBEDDER_NAME\"\n  }'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('INDEX_NAME').searchSimilarDocuments({ id: 'TARGET_DOCUMENT_ID', embedder: 'default' })"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index(\"INDEX_NAME\").get_similar_documents({\"id\": \"TARGET_DOCUMENT_ID\", \"embedder\": \"default\"})"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$similarQuery = new SimilarDocumentsQuery('TARGET_DOCUMENT_ID', 'default');\n$client->index('INDEX_NAME')->searchSimilarDocuments($similarQuery);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "SimilarDocumentRequest query = new SimilarDocumentRequest() .setId(\"143\") .setEmbedder(\"manual\"); client.index(\"movies\").searchSimilarDocuments(query)"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('INDEX_NAME').search_similar_documents('TARGET_DOCUMENT_ID', embedder: 'default')"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "resp := new(meilisearch.SimilarDocumentResult)\nclient.Index(\"INDEX_NAME\").SearchSimilarDocuments(&meilisearch.SimilarDocumentQuery{\n  Id: \"TARGET_DOCUMENT_ID\",\n  Embedder: \"default\",\n}, resp)"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let results = index\n  .similar_search(\"TARGET_DOCUMENT_ID\", \"EMBEDDER_NAME\")\n  .execute()\n  .await\n  .unwrap();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/stats": {
      "get": {
        "tags": [
          "Stats"
        ],
        "summary": "Get stats of index",
        "description": "Get the stats of an index.",
        "operationId": "get_index_stats",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "The stats of the index",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IndexStats"
                },
                "example": {
                  "numberOfDocuments": 10,
                  "rawDocumentDbSize": 10,
                  "avgDocumentSize": 10,
                  "numberOfEmbeddings": 10,
                  "numberOfEmbeddedDocuments": 10,
                  "isIndexing": true,
                  "fieldDistribution": {
                    "genre": 10,
                    "author": 9
                  }
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "Index not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Index `movies` not found.",
                  "code": "index_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#index_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "stats.get",
              "stats.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/stats'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.index('movies').getStats()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').get_stats()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->index('movies')->stats();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"movies\").getStats();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.index('movies').stats"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.Index(\"movies\").GetStats()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.Index(\"movies\").GetStatsAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let stats: IndexStats = client\n  .index(\"movies\")\n  .get_stats()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.index(\"movies\").stats { (result) in\n    switch result {\n    case .success(let stats):\n        print(stats)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.index('movies').getStats();"
          }
        ]
      }
    },
    "/indexes{indexUid}/compact": {
      "post": {
        "tags": [
          "Compact an index"
        ],
        "summary": "Compact an index",
        "operationId": "compact",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "202": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "documentDeletion",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "search",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/INDEX_UID/compact'"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.index('movies').compact()"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.index(\"INDEX_NAME\").compact();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"INDEX_UID\")\n  .compact()\n  .await\n  .unwrap();"
          }
        ]
      }
    },
    "/keys": {
      "get": {
        "tags": [
          "Keys"
        ],
        "summary": "Get API Keys",
        "description": "List all API Keys",
        "operationId": "list_api_keys",
        "parameters": [
          {
            "name": "offset",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "default": 0,
              "minimum": 0
            }
          },
          {
            "name": "limit",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "default": 20,
              "minimum": 0
            }
          }
        ],
        "responses": {
          "202": {
            "description": "List of keys",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginationView_KeyView"
                },
                "example": {
                  "results": [
                    {
                      "uid": "01b4bc42-eb33-4041-b481-254d00cce834",
                      "key": "d0552b41536279a0ad88bd595327b96f01176a60c2243e906c52ac02375f9bc4",
                      "name": "An API Key",
                      "description": null,
                      "actions": [
                        "documents.add"
                      ],
                      "indexes": [
                        "movies"
                      ],
                      "expiresAt": "2022-11-12T10:00:00Z",
                      "createdAt": "2021-11-12T10:00:00Z",
                      "updatedAt": "2021-11-12T10:00:00Z"
                    }
                  ],
                  "limit": 20,
                  "offset": 0,
                  "total": 1
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "keys.get",
              "keys.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/keys?limit=3' \\\n  -H 'Authorization: Bearer MASTER_KEY'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.getKeys({ limit: 3 })"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.get_keys({'limit': 3})"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->getKeys((new KeysQuery())->setLimit(3));"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "KeysQuery query = new KeysQuery().setLimit(3);\nclient.getKeys(query);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.keys(limit: 3)"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.GetKeys(&meilisearch.KeysQuery{\n  Limit: 3\n});"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "ResourceResults<Key> keyResult = await client.GetKeysAsync(new KeysQuery { Limit = 3 });"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let mut query = KeysQuery::new()\n  .with_limit(3)\n  .execute(&client)\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.getKeys(params: KeysQuery(limit: 3)) { result in\n    switch result {\n    case .success(let keys):\n        print(keys)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.getKeys(params: KeysQuery(limit: 3));"
          }
        ]
      },
      "post": {
        "tags": [
          "Keys"
        ],
        "summary": "Create an API Key",
        "description": "Create an API Key.",
        "operationId": "create_api_key",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateApiKey"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Key has been created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/KeyView"
                },
                "example": {
                  "uid": "01b4bc42-eb33-4041-b481-254d00cce834",
                  "key": "d0552b41536279a0ad88bd595327b96f01176a60c2243e906c52ac02375f9bc4",
                  "name": "Indexing Products API key",
                  "description": null,
                  "actions": [
                    "documents.add"
                  ],
                  "indexes": [
                    "products"
                  ],
                  "expiresAt": "2021-11-13T00:00:00Z",
                  "createdAt": "2021-11-12T10:00:00Z",
                  "updatedAt": "2021-11-12T10:00:00Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "keys.create",
              "keys.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/keys' \\\n  -H 'Authorization: Bearer MASTER_KEY' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"description\": \"Add documents: Products API key\",\n    \"actions\": [\"documents.add\"],\n    \"indexes\": [\"products\"],\n    \"expiresAt\": \"2042-04-02T00:42:42Z\"\n  }'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.createKey({\n  description: 'Add documents: Products API key',\n  actions: ['documents.add'],\n  indexes: ['products'],\n  expiresAt: '2021-11-13T00:00:00Z'\n})"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.create_key(options={\n  'description': 'Add documents: Products API key',\n  'actions': ['documents.add'],\n  'indexes': ['products'],\n  'expiresAt': '2042-04-02T00:42:42Z'\n})"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->createKey([\n  'description' => 'Add documents: Products API key',\n  'actions' => ['documents.add'],\n  'indexes' => ['products'],\n  'expiresAt' => '2042-04-02T00:42:42Z',\n]);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\");\nDate dateParsed = format.parse(\"2042-04-02T00:42:42Z\");\n\nKey keyInfo = new Key();\n\nkeyInfo.setDescription(\"Add documents: Products API key\");\nkeyInfo.setActions(new String[] {\"documents.add\"});\nkeyInfo.setIndexes(new String[] {\"products\"});\nkeyInfo.setExpiresAt(dateParsed);\n\nclient.createKey(keyInfo);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.create_key(\n  description: 'Add documents: Products API key',\n  actions: ['documents.add'],\n  indexes: ['products'],\n  expires_at: '2042-04-02T00:42:42Z'\n)"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.CreateKey(&meilisearch.Key{\n  Description: \"Add documents: Products API key\",\n  Actions: []string{\"documents.add\"},\n  Indexes: []string{\"products\"},\n  ExpiresAt: time.Date(2042, time.April, 02, 0, 42, 42, 0, time.UTC),\n})"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "Key keyOptions = new Key\n{\n    Description = \"Add documents: Products API key\",\n    Actions = new KeyAction[] { KeyAction.DocumentsAdd },\n    Indexes = new string[] { \"products\" },\n    ExpiresAt = DateTime.Parse(\"2042-04-02T00:42:42Z\")\n};\nKey createdKey = await this.client.CreateKeyAsync(keyOptions);"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let mut key_options = KeyBuilder::new();\nkey_options\n  .with_name(\"Add documents: Products API key\")\n  .with_action(Action::DocumentsAdd)\n  .with_expires_at(time::macros::datetime!(2042 - 04 - 02 00:42:42 UTC))\n  .with_index(\"products\");\nlet new_key = client\n  .create_key(key_options)\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "let keyParams = KeyParams(\n  description: \"Add documents: Products API key\",\n  actions: [\"documents.add\"],\n  indexes: [\"products\"],\n  expiresAt: \"2042-04-02T00:42:42Z\"\n)\nclient.createKey(keyParams) { result in\n    switch result {\n    case .success(let key):\n        print(key)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.createKey(\n    description: 'Add documents: Products API key',\n    actions: ['documents.add'],\n    indexes: ['products'],\n    expiresAt: DateTime(2042, 04, 02));"
          }
        ]
      }
    },
    "/keys/{uidOrKey}": {
      "get": {
        "tags": [
          "Keys"
        ],
        "summary": "Get an API Key",
        "description": "Get an API key from its `uid` or its `key` field.",
        "operationId": "get_api_key",
        "parameters": [
          {
            "name": "uidOrKey",
            "in": "path",
            "description": "The `uid` or `key` field of an existing API key",
            "required": true,
            "schema": {
              "type": "string",
              "format": "password"
            },
            "example": "7b198a7f-52a0-4188-8762-9ad93cd608b2"
          }
        ],
        "responses": {
          "200": {
            "description": "The key is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/KeyView"
                },
                "example": {
                  "uid": "01b4bc42-eb33-4041-b481-254d00cce834",
                  "key": "d0552b41536279a0ad88bd595327b96f01176a60c2243e906c52ac02375f9bc4",
                  "name": "An API Key",
                  "description": null,
                  "actions": [
                    "documents.add"
                  ],
                  "indexes": [
                    "movies"
                  ],
                  "expiresAt": "2022-11-12T10:00:00Z",
                  "createdAt": "2021-11-12T10:00:00Z",
                  "updatedAt": "2021-11-12T10:00:00Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "keys.get",
              "keys.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/keys/6062abda-a5aa-4414-ac91-ecd7944c0f8d' \\\n  -H 'Authorization: Bearer MASTER_KEY'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.getKey('6062abda-a5aa-4414-ac91-ecd7944c0f8d')"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.get_key('6062abda-a5aa-4414-ac91-ecd7944c0f8d')"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->getKey('6062abda-a5aa-4414-ac91-ecd7944c0f8d');"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.getKey(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\");"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.key('6062abda-a5aa-4414-ac91-ecd7944c0f8d')"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.GetKey(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\")"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "Key key = await client.GetKeyAsync(\"d0552b41536279a0ad88bd595327b96f01176a60c2243e906c52ac02375f9bc4\");"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let key = client\n  .get_key(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\")\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.getKey(keyOrUid: \"6062abda-a5aa-4414-ac91-ecd7944c0f8d\") { result in\n    switch result {\n    case .success(let key):\n        print(key)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.getKey('6062abda-a5aa-4414-ac91-ecd7944c0f8d');"
          }
        ]
      },
      "delete": {
        "tags": [
          "Keys"
        ],
        "summary": "Delete a key",
        "description": "Delete the specified API key.",
        "operationId": "delete_api_key",
        "parameters": [
          {
            "name": "uidOrKey",
            "in": "path",
            "description": "The `uid` or `key` field of an existing API key",
            "required": true,
            "schema": {
              "type": "string",
              "format": "password"
            },
            "example": "7b198a7f-52a0-4188-8762-9ad93cd608b2"
          }
        ],
        "responses": {
          "204": {
            "description": "The key have been removed"
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "keys.delete",
              "keys.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/keys/6062abda-a5aa-4414-ac91-ecd7944c0f8d' \\\n  -H 'Authorization: Bearer MASTER_KEY'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.deleteKey('6062abda-a5aa-4414-ac91-ecd7944c0f8d')"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.delete_key('6062abda-a5aa-4414-ac91-ecd7944c0f8d')"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->deleteKey('6062abda-a5aa-4414-ac91-ecd7944c0f8d');"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.deleteKey(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\")"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.delete_key('6062abda-a5aa-4414-ac91-ecd7944c0f8d')"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.DeleteKey(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\")"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "client.DeleteKeyAsync(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\")"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let key = client\n  .get_key(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\")\n  .await\n  .unwrap();\nclient\n  .delete_key(&key)\n  .await?;"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.deleteKey(keyOrUid: \"6062abda-a5aa-4414-ac91-ecd7944c0f8d\") { result in\n    switch result {\n    case .success:\n        print(\"success\")\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.deleteKey('6062abda-a5aa-4414-ac91-ecd7944c0f8d');"
          }
        ]
      },
      "patch": {
        "tags": [
          "Keys"
        ],
        "summary": "Update a Key",
        "description": "Update the name and description of an API key.\nUpdates to keys are partial. This means you should provide only the fields you intend to update, as any fields not present in the payload will remain unchanged.",
        "operationId": "patch_api_key",
        "parameters": [
          {
            "name": "uidOrKey",
            "in": "path",
            "description": "The `uid` or `key` field of an existing API key",
            "required": true,
            "schema": {
              "type": "string",
              "format": "password"
            },
            "example": "7b198a7f-52a0-4188-8762-9ad93cd608b2"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PatchApiKey"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The key have been updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/KeyView"
                },
                "example": {
                  "uid": "01b4bc42-eb33-4041-b481-254d00cce834",
                  "key": "d0552b41536279a0ad88bd595327b96f01176a60c2243e906c52ac02375f9bc4",
                  "name": "An API Key",
                  "description": null,
                  "actions": [
                    "documents.add"
                  ],
                  "indexes": [
                    "movies"
                  ],
                  "expiresAt": "2022-11-12T10:00:00Z",
                  "createdAt": "2021-11-12T10:00:00Z",
                  "updatedAt": "2021-11-12T10:00:00Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "keys.update",
              "keys.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/keys/6062abda-a5aa-4414-ac91-ecd7944c0f8d' \\\n  -H 'Authorization: Bearer MASTER_KEY' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"name\": \"Products/Reviews API key\",\n    \"description\": \"Manage documents: Products/Reviews API key\"\n  }'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.updateKey('6062abda-a5aa-4414-ac91-ecd7944c0f8d', {\n    name: 'Products/Reviews API key',\n    description: 'Manage documents: Products/Reviews API key',\n})"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.update_key(key_or_uid='6062abda-a5aa-4414-ac91-ecd7944c0f8d',\n  options={\n    'name': 'Products/Reviews API key',\n    'description': 'Manage documents: Products/Reviews API key'\n})"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->updateKey('6062abda-a5aa-4414-ac91-ecd7944c0f8d',\n  [\n    'name' => 'Products/Reviews API key',\n    'description' => 'Manage documents: Products/Reviews API key'\n  ]);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "KeyUpdate keyChanges = new KeyUpdate();\nkeyChanges.setName(\"Products/Reviews API key\");\nkeyChanges.setDescription(\"Manage documents: Products/Reviews API key\");\n\nclient.updateKey(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\", keyChanges);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.update_key(\n  '6062abda-a5aa-4414-ac91-ecd7944c0f8d',\n  {\n    description: 'Manage documents: Products/Reviews API key',\n    name: 'Products/Reviews API key'\n  }\n)"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.UpdateKey(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\", &meilisearch.Key{\n  Description: \"Manage documents: Products/Reviews API key\",\n  Actions: []string{\"documents.add\", \"document.delete\"},\n  Indexes: []string{\"products\", \"reviews\"},\n  ExpiresAt: time.Date(2042, time.April, 02, 0, 42, 42, 0, time.UTC),\n})"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.UpdateKeyAsync(\n  \"6062abda-a5aa-4414-ac91-ecd7944c0f8d\",\n  description: \"Manage documents: Products/Reviews API key\",\n  name: \"Products/Reviews API key\"\n)"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let mut key = client\n  .get_key(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\")\n  .await\n  .unwrap();\nkey\n    .with_description(\"Manage documents: Products/Reviews API key\".to_string())\n    .with_name(\"Products/Reviews API key\".to_string())\n    .update(&client)\n    .await\n    .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "let keyParams = KeyUpdateParams(\n  description: \"Manage documents: Products/Reviews API key\",\n  name: \"Products/Reviews API key\"\n)\n\nclient.updateKey(keyOrUid: \"6062abda-a5aa-4414-ac91-ecd7944c0f8d\", keyParams: keyParams) { result in\n  switch result {\n  case .success(let key):\n      print(key)\n  case .failure(let error):\n      print(error)\n  }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.updateKey(\n  '6062abda-a5aa-4414-ac91-ecd7944c0f8d',\n  description: 'Manage documents: Products/Reviews API key',\n  name: 'Products/Reviews API key',\n);"
          }
        ]
      }
    },
    "/logs/stderr": {
      "post": {
        "tags": [
          "Logs"
        ],
        "summary": "Update target of the console logs",
        "description": "This route lets you specify at runtime the level of the console logs outputted on stderr.",
        "operationId": "update_stderr_target",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateStderrLogs"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "The console logs have been updated"
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "metrics.get",
              "metrics.*",
              "*"
            ]
          }
        ]
      }
    },
    "/logs/stream": {
      "post": {
        "tags": [
          "Logs"
        ],
        "summary": "Retrieve logs",
        "description": "Stream logs over HTTP. The format of the logs depends on the configuration specified in the payload.\nThe logs are sent as multi-part, and the stream never stops, so make sure your clients correctly handle that.\nTo make the server stop sending you logs, you can call the `DELETE /logs/stream` route.\n\nThere can only be one listener at a timeand an error will be returned if you call this route while it's being used by another client.",
        "operationId": "get_logs",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetLogs"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Logs are being returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                },
                "example": "\n2024-10-08T13:35:02.643750Z  WARN HTTP request{method=GET host=\"localhost:7700\" route=/metrics query_parameters= user_agent=HTTPie/3.2.3 status_code=400 error=Getting metrics requires enabling the `metrics` experimental feature. See https://github.com/meilisearch/product/discussions/625}: tracing_actix_web::middleware: Error encountered while processing the incoming HTTP request: ResponseError { code: 400, message: \"Getting metrics requires enabling the `metrics` experimental feature. See https://github.com/meilisearch/product/discussions/625\", error_code: \"feature_not_enabled\", error_type: \"invalid_request\", error_link: \"https://docs.meilisearch.com/errors#feature_not_enabled\" }\n2024-10-08T13:35:02.644191Z  INFO HTTP request{method=GET host=\"localhost:7700\" route=/metrics query_parameters= user_agent=HTTPie/3.2.3 status_code=400 error=Getting metrics requires enabling the `metrics` experimental feature. See https://github.com/meilisearch/product/discussions/625}: meilisearch: close time.busy=1.66ms time.idle=658s\n2024-10-08T13:35:18.564152Z  INFO HTTP request{method=PATCH host=\"localhost:7700\" route=/experimental-features query_parameters= user_agent=curl/8.6.0 status_code=200}: meilisearch: close time.busy=1.17ms time.idle=127s\n2024-10-08T13:35:23.094987Z  INFO HTTP request{method=GET host=\"localhost:7700\" route=/metrics query_parameters= user_agent=HTTPie/3.2.3 status_code=200}: meilisearch: close time.busy=2.12ms time.idle=595s\n"
              }
            }
          },
          "400": {
            "description": "The route is already being used",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The `/logs/stream` route is currently in use by someone else.",
                  "code": "bad_request",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#bad_request"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "metrics.get",
              "metrics.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X POST MEILISEARCH_URL/logs/stderr \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n      \"target\": \"milli=trace,index_scheduler=info,actix_web=off\"\n  }'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Logs"
        ],
        "summary": "Stop retrieving logs",
        "description": "Call this route to make the engine stops sending logs through the `POST /logs/stream` route.",
        "operationId": "cancel_logs",
        "responses": {
          "204": {
            "description": "Logs are being returned"
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "metrics.get",
              "metrics.*",
              "*"
            ]
          }
        ]
      }
    },
    "/metrics": {
      "get": {
        "tags": [
          "Stats"
        ],
        "summary": "Get prometheus metrics",
        "description": "Retrieve metrics on the engine. See https://www.meilisearch.com/docs/learn/experimental/metrics\nCurrently, [the feature is experimental](https://www.meilisearch.com/docs/learn/experimental/overview)\nwhich means it must be enabled.",
        "operationId": "get_metrics",
        "responses": {
          "200": {
            "description": "The metrics of the instance",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                },
                "example": "\n# HELP meilisearch_db_size_bytes Meilisearch DB Size In Bytes\n# TYPE meilisearch_db_size_bytes gauge\nmeilisearch_db_size_bytes 1130496\n# HELP meilisearch_batch_running_progress_trace The currently running progress trace\n# TYPE meilisearch_batch_running_progress_trace gauge\nmeilisearch_batch_running_progress_trace{batch_uid=\"0\",step_name=\"document\"} 0.710618582519409\nmeilisearch_batch_running_progress_trace{batch_uid=\"0\",step_name=\"extracting word proximity\"} 0.2222222222222222\nmeilisearch_batch_running_progress_trace{batch_uid=\"0\",step_name=\"indexing\"} 0.6666666666666666\nmeilisearch_batch_running_progress_trace{batch_uid=\"0\",step_name=\"processing tasks\"} 0\n# HELP meilisearch_http_requests_total Meilisearch HTTP requests total\n# TYPE meilisearch_http_requests_total counter\nmeilisearch_http_requests_total{method=\"GET\",path=\"/metrics\",status=\"400\"} 1\nmeilisearch_http_requests_total{method=\"PATCH\",path=\"/experimental-features\",status=\"200\"} 1\n# HELP meilisearch_http_response_time_seconds Meilisearch HTTP response times\n# TYPE meilisearch_http_response_time_seconds histogram\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"0.005\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"0.01\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"0.025\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"0.05\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"0.075\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"0.1\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"0.25\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"0.5\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"0.75\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"1\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"2.5\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"5\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"7.5\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"10\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"+Inf\"} 0\nmeilisearch_http_response_time_seconds_sum{method=\"GET\",path=\"/metrics\"} 0\nmeilisearch_http_response_time_seconds_count{method=\"GET\",path=\"/metrics\"} 0\n# HELP meilisearch_last_finished_batches_progress_trace_ms The last few batches progress trace in milliseconds\n# TYPE meilisearch_last_finished_batches_progress_trace_ms gauge\nmeilisearch_last_finished_batches_progress_trace_ms{batch_uid=\"0\",step_name=\"processing tasks\"} 19360\nmeilisearch_last_finished_batches_progress_trace_ms{batch_uid=\"0\",step_name=\"processing tasks > computing document changes\"} 368\nmeilisearch_last_finished_batches_progress_trace_ms{batch_uid=\"0\",step_name=\"processing tasks > computing document changes > preparing payloads\"} 367\nmeilisearch_last_finished_batches_progress_trace_ms{batch_uid=\"0\",step_name=\"processing tasks > computing document changes > preparing payloads > payload\"} 367\nmeilisearch_last_finished_batches_progress_trace_ms{batch_uid=\"0\",step_name=\"processing tasks > indexing\"} 18970\n# HELP meilisearch_index_count Meilisearch Index Count\n# TYPE meilisearch_index_count gauge\nmeilisearch_index_count 1\n# HELP meilisearch_index_docs_count Meilisearch Index Docs Count\n# TYPE meilisearch_index_docs_count gauge\nmeilisearch_index_docs_count{index=\"mieli\"} 2\n# HELP meilisearch_is_indexing Meilisearch Is Indexing\n# TYPE meilisearch_is_indexing gauge\nmeilisearch_is_indexing 0\n# HELP meilisearch_last_update Meilisearch Last Update\n# TYPE meilisearch_last_update gauge\nmeilisearch_last_update 1726675964\n# HELP meilisearch_nb_tasks Meilisearch Number of tasks\n# TYPE meilisearch_nb_tasks gauge\nmeilisearch_nb_tasks{kind=\"indexes\",value=\"mieli\"} 39\nmeilisearch_nb_tasks{kind=\"statuses\",value=\"canceled\"} 0\nmeilisearch_nb_tasks{kind=\"statuses\",value=\"enqueued\"} 0\nmeilisearch_nb_tasks{kind=\"statuses\",value=\"failed\"} 4\nmeilisearch_nb_tasks{kind=\"statuses\",value=\"processing\"} 0\nmeilisearch_nb_tasks{kind=\"statuses\",value=\"succeeded\"} 35\nmeilisearch_nb_tasks{kind=\"types\",value=\"documentAdditionOrUpdate\"} 9\nmeilisearch_nb_tasks{kind=\"types\",value=\"documentDeletion\"} 0\nmeilisearch_nb_tasks{kind=\"types\",value=\"documentEdition\"} 0\nmeilisearch_nb_tasks{kind=\"types\",value=\"dumpCreation\"} 0\nmeilisearch_nb_tasks{kind=\"types\",value=\"indexCreation\"} 0\nmeilisearch_nb_tasks{kind=\"types\",value=\"indexDeletion\"} 8\nmeilisearch_nb_tasks{kind=\"types\",value=\"indexSwap\"} 0\nmeilisearch_nb_tasks{kind=\"types\",value=\"indexUpdate\"} 0\nmeilisearch_nb_tasks{kind=\"types\",value=\"settingsUpdate\"} 22\nmeilisearch_nb_tasks{kind=\"types\",value=\"snapshotCreation\"} 0\nmeilisearch_nb_tasks{kind=\"types\",value=\"taskCancelation\"} 0\nmeilisearch_nb_tasks{kind=\"types\",value=\"taskDeletion\"} 0\n# HELP meilisearch_used_db_size_bytes Meilisearch Used DB Size In Bytes\n# TYPE meilisearch_used_db_size_bytes gauge\nmeilisearch_used_db_size_bytes 409600\n"
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "metrics.get",
              "metrics.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/metrics'"
          }
        ]
      }
    },
    "/multi-search": {
      "post": {
        "tags": [
          "Multi-search"
        ],
        "summary": "Perform a multi-search",
        "description": "Bundle multiple search queries in a single API request. Use this endpoint to search through multiple indexes at once.",
        "operationId": "multi_search_with_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FederatedSearch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Federated multi-search",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FederatedSearchResult"
                },
                "example": {
                  "hits": [
                    {
                      "id": 42,
                      "title": "Batman returns",
                      "overview": "The overview of batman returns",
                      "_federation": {
                        "indexUid": "movies",
                        "queriesPosition": 0
                      }
                    },
                    {
                      "comicsId": "batman-killing-joke",
                      "description": "This comic is really awesome",
                      "title": "Batman: the killing joke",
                      "_federation": {
                        "indexUid": "comics",
                        "queriesPosition": 1
                      }
                    }
                  ],
                  "processingTimeMs": 0,
                  "limit": 20,
                  "offset": 0,
                  "estimatedTotalHits": 2,
                  "semanticHitCount": 0
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "search",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/multi-search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"queries\": [\n      {\n        \"indexUid\": \"movies\",\n        \"q\": \"pooh\",\n        \"limit\": 5\n      },\n      {\n        \"indexUid\": \"movies\",\n        \"q\": \"nemo\",\n        \"limit\": 5\n      },\n      {\n        \"indexUid\": \"movie_ratings\",\n        \"q\": \"us\"\n      }\n    ]\n  }'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.multiSearch({ queries: [\n  {\n    indexUid: 'movies',\n    q: 'pooh',\n    limit: 5,\n  },\n  {\n    indexUid: 'movies',\n    q: 'nemo',\n    limit: 5,\n  },\n  {\n    indexUid: 'movie_ratings',\n    q: 'us',\n  },\n]})"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.multi_search(\n  [\n    {'indexUid': 'movies', 'q': 'pooh', 'limit': 5},\n    {'indexUid': 'movies', 'q': 'nemo', 'limit': 5},\n    {'indexUid': 'movie_ratings', 'q': 'us'}\n  ]\n)"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->multiSearch([\n    (new SearchQuery())\n        ->setIndexUid('movies')\n        ->setQuery('pooh')\n        ->setLimit(5),\n    (new SearchQuery())\n        ->setIndexUid('movies')\n        ->setQuery('nemo')\n        ->setLimit(5),\n    (new SearchQuery())\n        ->setIndexUid('movie_ratings')\n        ->setQuery('us')\n  ]);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "MultiSearchRequest multiSearchRequest = new MultiSearchRequest();\nmultiIndexSearch.addQuery(new IndexSearchRequest(\"movies\").setQuery(\"pooh\").setLimit(5));\nmultiIndexSearch.addQuery(new IndexSearchRequest(\"movies\").setQuery(\"nemo\").setLimit(5));\nmultiIndexSearch.addQuery(new IndexSearchRequest(\"movie_ratings\").setQuery(\"us\"));\n\nclient.multiSearch(multiSearchRequest);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.multi_search([\n  { index_uid: 'books', q: 'prince' },\n  { index_uid: 'movies', q: 'pooh', limit: 5 }\n  { index_uid: 'movies', q: 'nemo', limit: 5 }\n  { index_uid: 'movie_ratings', q: 'us' }\n])"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.MultiSearch(&MultiSearchRequest{\n  Queries: []SearchRequest{\n    {\n      IndexUID: \"movies\",\n      Query:    \"pooh\",\n      Limit:    5,\n    },\n    {\n      IndexUID: \"movies\",\n      Query:    \"nemo\",\n      Limit:    5,\n    },\n    {\n      IndexUID: \"movie_ratings\",\n      Query:    \"us\",\n    },\n  },\n})"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.MultiSearchAsync(new MultiSearchQuery()\n{\n    Queries = new System.Collections.Generic.List<SearchQuery>()\n    {\n        new SearchQuery() {\n          IndexUid = \"movies\",\n          Q = \"booh\",\n          Limit = 5\n        },\n        new SearchQuery() {\n          IndexUid = \"movies\",\n          Q = \"nemo\",\n          Limit = 5\n        },\n        new SearchQuery() {\n          IndexUid = \"movie_ratings\",\n          Q = \"us\",\n        },\n    }\n});"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let movie = client.index(\"movie\");\nlet movie_ratings = client.index(\"movie_ratings\");\n\nlet search_query_1 = SearchQuery::new(&movie)\n    .with_query(\"pooh\")\n    .with_limit(5)\n    .build();\nlet search_query_2 = SearchQuery::new(&movie)\n    .with_query(\"nemo\")\n    .with_limit(5)\n    .build();\nlet search_query_3 = SearchQuery::new(&movie_ratings)\n    .with_query(\"us\")\n    .build();\n\nlet response = client\n    .multi_search()\n    .with_search_query(search_query_1)\n    .with_search_query(search_query_2)\n    .with_search_query(search_query_3)\n    .execute::<Document>()\n    .await\n    .unwrap();"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.multiSearch(MultiSearchQuery(queries: [\n  IndexSearchQuery(query: 'pooh', indexUid: 'movies', limit: 5),\n  IndexSearchQuery(query: 'nemo', indexUid: 'movies', limit: 5),\n  IndexSearchQuery(query: 'us', indexUid: 'movies_ratings'),\n]));"
          }
        ]
      }
    },
    "/network": {
      "get": {
        "tags": [
          "Network"
        ],
        "summary": "Get network topology",
        "description": "Get a list of all Meilisearch instances currently known to this instance.",
        "operationId": "get_network",
        "responses": {
          "200": {
            "description": "Known nodes are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Network"
                },
                "example": {
                  "self": "ms-0",
                  "remotes": {
                    "ms-0": {
                      "url": "http://localhost:7700",
                      "searchApiKey": null,
                      "writeApiKey": null
                    },
                    "ms-1": {
                      "url": "http://localhost:7701",
                      "searchApiKey": "foo",
                      "writeApiKey": "bar"
                    },
                    "ms-2": {
                      "url": "http://localhost:7702",
                      "searchApiKey": "bar",
                      "writeApiKey": "foo"
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "network.get",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/network'"
          }
        ]
      },
      "patch": {
        "tags": [
          "Network"
        ],
        "summary": "Configure Network",
        "description": "Add or remove nodes from network.",
        "operationId": "patch_network",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Network"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "New network state is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Network"
                },
                "example": {
                  "self": "ms-0",
                  "remotes": {
                    "ms-0": {
                      "url": "http://localhost:7700",
                      "searchApiKey": null,
                      "writeApiKey": null
                    },
                    "ms-1": {
                      "url": "http://localhost:7701",
                      "searchApiKey": "foo",
                      "writeApiKey": "bar"
                    },
                    "ms-2": {
                      "url": "http://localhost:7702",
                      "searchApiKey": "bar",
                      "writeApiKey": "foo"
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "network.update",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/network' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"self\": \"ms-00\",\n    \"remotes\": {\n      \"ms-00\": {\n        \"url\": \"http://INSTANCE_URL\",\n        \"searchApiKey\": \"INSTANCE_API_KEY\"\n      },\n      \"ms-01\": {\n        \"url\": \"http://ANOTHER_INSTANCE_URL\",\n        \"searchApiKey\": \"ANOTHER_INSTANCE_API_KEY\"\n      }\n    }\n  }'"
          }
        ]
      }
    },
    "/snapshots": {
      "post": {
        "tags": [
          "Snapshots"
        ],
        "summary": "Create a snapshot",
        "description": "Triggers a snapshot creation process. Once the process is complete, a snapshot is created in the snapshot directory. If the snapshot directory does not exist yet, it will be created.",
        "operationId": "create_snapshot",
        "responses": {
          "202": {
            "description": "Snapshot is being created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 0,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "snapshotCreation",
                  "enqueuedAt": "2021-01-01T09:39:00.000000Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "snapshots.create",
              "snapshots.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/snapshots'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.createSnapshot()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.create_snapshot()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->createSnapshot();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.createSnapshot();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.create_snapshot"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.CreateSnapshot()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.CreateSnapshotAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "client\n  .create_snapshot()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "let task = try await self.client.createSnapshot()"
          }
        ]
      }
    },
    "/stats": {
      "get": {
        "tags": [
          "Stats"
        ],
        "summary": "Get stats of all indexes.",
        "description": "Get stats of all indexes.",
        "operationId": "get_stats",
        "responses": {
          "200": {
            "description": "The stats of the instance",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Stats"
                },
                "example": {
                  "databaseSize": 567,
                  "usedDatabaseSize": 456,
                  "lastUpdate": "2019-11-20T09:40:33.711324Z",
                  "indexes": {
                    "movies": {
                      "numberOfDocuments": 10,
                      "rawDocumentDbSize": 100,
                      "maxDocumentSize": 16,
                      "avgDocumentSize": 10,
                      "isIndexing": true,
                      "fieldDistribution": {
                        "genre": 10,
                        "author": 9
                      }
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "stats.get",
              "stats.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/stats'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.getStats()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.get_all_stats()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->stats();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.getStats();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.stats"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.GetStats()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.GetStatsAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let stats: ClientStats = client\n  .get_stats()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.allStats { (result) in\n    switch result {\n    case .success(let stats):\n        print(stats)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.getStats();"
          }
        ]
      }
    },
    "/swap-indexes": {
      "post": {
        "tags": [
          "Indexes"
        ],
        "summary": "Swap indexes",
        "description": "Swap the documents, settings, and task history of two or more indexes. You can only swap indexes in pairs. However, a single request can swap as many index pairs as you wish.\nSwapping indexes is an atomic transaction: either all indexes are successfully swapped, or none are.\nSwapping indexA and indexB will also replace every mention of indexA by indexB and vice-versa in the task history. enqueued tasks are left unmodified.",
        "operationId": "swap_indexes",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/SwapIndexesPayload"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 3,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "indexSwap",
                  "enqueuedAt": "2021-08-12T10:00:00.000000Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "search",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/swap-indexes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    {\n      \"indexes\": [\n        \"indexA\",\n        \"indexB\"\n      ]\n    },\n    {\n      \"indexes\": [\n        \"indexX\",\n        \"indexY\"\n      ]\n    }\n  ]'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.swapIndexes([\n  { 'indexes': ['indexA', 'indexB'] },\n  { 'indexes': ['indexX', 'indexY'] }\n])"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.swap_indexes([{'indexes': ['indexA', 'indexB']}, {'indexes': ['indexX', 'indexY']}])"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->swapIndexes([['indexA', 'indexB'], ['indexX', 'indexY']]);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "SwapIndexesParams[] params =\n        new SwapIndexesParams[] {\n            new SwapIndexesParams().setIndexes(new String[] {\"indexA\", \"indexB\"}),\n            new SwapIndexesParams().setIndexes(new String[] {\"indexX\", \"indexY\"})\n        };\nTaskInfo task = client.swapIndexes(params);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.swap_indexes(['indexA', 'indexB'], ['indexX', 'indexY'])"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.SwapIndexes([]SwapIndexesParams{\n  {Indexes: []string{\"indexA\", \"indexB\"}},\n  {Indexes: []string{\"indexX\", \"indexY\"}},\n})"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.SwapIndexesAsync(new List<IndexSwap> { new IndexSwap(\"indexA\", \"indexB\"), new IndexSwap(\"indexX\", \"indexY\") } });"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "client.swap_indexes([\n  &SwapIndexes {\n    indexes: (\n        \"indexA\".to_string(),\n        \"indexB\".to_string(),\n    ),\n  }, &SwapIndexes {\n    indexes: (\n        \"indexX\".to_string(),\n        \"indexY\".to_string(),\n    ),\n}])"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "let task = try await self.client.swapIndexes([\n  (\"indexA\", \"indexB\"),\n  (\"indexX\", \"indexY\")\n])"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.swapIndexes([\n  SwapIndex(['indexA', 'indexB']),\n  SwapIndex(['indexX', 'indexY']),\n]);"
          }
        ]
      }
    },
    "/tasks": {
      "get": {
        "tags": [
          "Tasks"
        ],
        "summary": "Get all tasks",
        "description": "Get all [tasks](https://docs.meilisearch.com/learn/advanced/asynchronous_operations.html)",
        "operationId": "get_tasks",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "u-int32",
              "default": 20,
              "minimum": 0
            },
            "example": 12
          },
          {
            "name": "from",
            "in": "query",
            "description": "Fetch the next set of results from the given uid.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "u-int32",
              "minimum": 0
            },
            "example": 12421
          },
          {
            "name": "reverse",
            "in": "query",
            "description": "The order you want to retrieve the objects.",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "example": true
          },
          {
            "name": "batchUids",
            "in": "query",
            "description": "Permits to filter tasks by their batch uid. By default, when the `batchUids` query parameter is not set, all task uids are returned. It's possible to specify several batch uids by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "u-int32",
              "minimum": 0
            },
            "example": 12421
          },
          {
            "name": "uids",
            "in": "query",
            "description": "Permits to filter tasks by their uid. By default, when the uids query parameter is not set, all task uids are returned. It's possible to specify several uids by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              231,
              423,
              598,
              "*"
            ]
          },
          {
            "name": "canceledBy",
            "in": "query",
            "description": "Permits to filter tasks using the uid of the task that canceled them. It's possible to specify several task uids by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              374,
              "*"
            ]
          },
          {
            "name": "types",
            "in": "query",
            "description": "Permits to filter tasks by their related type. By default, when `types` query parameter is not set, all task types are returned. It's possible to specify several types by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "example": [
              "documentAdditionOrUpdate",
              "*"
            ]
          },
          {
            "name": "statuses",
            "in": "query",
            "description": "Permits to filter tasks by their status. By default, when `statuses` query parameter is not set, all task statuses are returned. It's possible to specify several statuses by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Status"
              }
            },
            "example": [
              "succeeded",
              "failed",
              "canceled",
              "enqueued",
              "processing",
              "*"
            ]
          },
          {
            "name": "indexUids",
            "in": "query",
            "description": "Permits to filter tasks by their related index. By default, when `indexUids` query parameter is not set, the tasks of all the indexes are returned. It is possible to specify several indexes by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "example": [
              "movies",
              "theater",
              "*"
            ]
          },
          {
            "name": "afterEnqueuedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their enqueuedAt time. Matches tasks enqueued after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "beforeEnqueuedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their enqueuedAt time. Matches tasks enqueued before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "afterStartedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their startedAt time. Matches tasks started after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "beforeStartedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their startedAt time. Matches tasks started before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "afterFinishedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their finishedAt time. Matches tasks finished after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "beforeFinishedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their finishedAt time. Matches tasks finished before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          }
        ],
        "responses": {
          "200": {
            "description": "Get all tasks",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AllTasks"
                },
                "example": {
                  "results": [
                    {
                      "uid": 144,
                      "indexUid": "mieli",
                      "status": "succeeded",
                      "type": "settingsUpdate",
                      "canceledBy": null,
                      "details": {
                        "settings": {
                          "filterableAttributes": [
                            "play_count"
                          ]
                        }
                      },
                      "error": null,
                      "duration": "PT0.009330S",
                      "enqueuedAt": "2024-08-08T09:01:13.348471Z",
                      "startedAt": "2024-08-08T09:01:13.349442Z",
                      "finishedAt": "2024-08-08T09:01:13.358772Z"
                    }
                  ],
                  "total": 1,
                  "limit": 1,
                  "from": 144,
                  "next": null
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "tasks.get",
              "tasks.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/tasks'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.tasks.getTasks()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.get_tasks()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->getTasks();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.getTasks();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.tasks"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.GetTasks(nil);"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "ResourceResults<Task> taskResult = await client.GetTasksAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let tasks: TasksResults = client\n  .get_tasks()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.getTasks { (result) in\n    switch result {\n    case .success(let tasks):\n        print(tasks)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.getTasks();"
          }
        ]
      },
      "delete": {
        "tags": [
          "Tasks"
        ],
        "summary": "Delete tasks",
        "description": "Delete [tasks](https://docs.meilisearch.com/learn/advanced/asynchronous_operations.html) on filter",
        "operationId": "delete_tasks",
        "parameters": [
          {
            "name": "uids",
            "in": "query",
            "description": "Permits to filter tasks by their uid. By default, when the `uids` query parameter is not set, all task uids are returned. It's possible to specify several uids by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              231,
              423,
              598,
              "*"
            ]
          },
          {
            "name": "batchUids",
            "in": "query",
            "description": "Lets you filter tasks by their `batchUid`.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              231,
              423,
              598,
              "*"
            ]
          },
          {
            "name": "canceledBy",
            "in": "query",
            "description": "Permits to filter tasks using the uid of the task that canceled them. It's possible to specify several task uids by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              374,
              "*"
            ]
          },
          {
            "name": "types",
            "in": "query",
            "description": "Permits to filter tasks by their related type. By default, when `types` query parameter is not set, all task types are returned. It's possible to specify several types by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Kind"
              }
            },
            "example": [
              "documentDeletion",
              "*"
            ]
          },
          {
            "name": "statuses",
            "in": "query",
            "description": "Permits to filter tasks by their status. By default, when `statuses` query parameter is not set, all task statuses are returned. It's possible to specify several statuses by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Status"
              }
            },
            "example": [
              "succeeded",
              "failed",
              "canceled",
              "*"
            ]
          },
          {
            "name": "indexUids",
            "in": "query",
            "description": "Permits to filter tasks by their related index. By default, when `indexUids` query parameter is not set, the tasks of all the indexes are returned. It is possible to specify several indexes by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "example": [
              "movies",
              "theater",
              "*"
            ]
          },
          {
            "name": "afterEnqueuedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their enqueuedAt time. Matches tasks enqueued after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "beforeEnqueuedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their enqueuedAt time. Matches tasks enqueued before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "afterStartedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their startedAt time. Matches tasks started after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "beforeStartedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their startedAt time. Matches tasks started before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "afterFinishedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their finishedAt time. Matches tasks finished after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "beforeFinishedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their finishedAt time. Matches tasks finished before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          }
        ],
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "taskDeletion",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "400": {
            "description": "A filter is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Query parameters to filter the tasks to delete are missing. Available query parameters are: `uids`, `indexUids`, `statuses`, `types`, `canceledBy`, `beforeEnqueuedAt`, `afterEnqueuedAt`, `beforeStartedAt`, `afterStartedAt`, `beforeFinishedAt`, `afterFinishedAt`.",
                  "code": "missing_task_filters",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#missing_task_filters"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "The task uid does not exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Task :taskUid not found.",
                  "code": "task_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors/#task_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "tasks.delete",
              "tasks.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/tasks?uids=1,2'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.tasks.deleteTasks({ uids: [1, 2] })"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.delete_tasks({'uids': ['1', '2']})"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->deleteTasks((new DeleteTasksQuery())->setUids([1, 2]));"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "DeleteTasksQuery query = new DeleteTasksQuery().setUids(new int[] {1, 2})\nclient.deleteTasks(query);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.delete_tasks(uids: [1, 2])"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.DeleteTaks(&meilisearch.DeleteTasksQuery{\n  UIDS: []int64{1, 2},\n});"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.DeleteTasksAsync(new DeleteTasksQuery { Uids = new List<int> { 1, 2 } });"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let mut query = tasks::TasksDeleteQuery::new(&client);\nquery.with_uids([1, 2]);\n\nlet res = client.delete_tasks_with(&query).await.unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.deleteTasks(filter: DeleteTasksQuery(uids: [1, 2])) { (result) in\n    switch result {\n    case .success(let taskInfo):\n        print(taskInfo)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.deleteTasks(params: DeleteTasksQuery(uids: [1, 2]));"
          }
        ]
      }
    },
    "/tasks/cancel": {
      "post": {
        "tags": [
          "Tasks"
        ],
        "summary": "Cancel tasks",
        "description": "Cancel enqueued and/or processing [tasks](https://www.meilisearch.com/docs/learn/async/asynchronous_operations)",
        "operationId": "cancel_tasks",
        "parameters": [
          {
            "name": "uids",
            "in": "query",
            "description": "Permits to filter tasks by their uid. By default, when the `uids` query parameter is not set, all task uids are returned. It's possible to specify several uids by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              231,
              423,
              598,
              "*"
            ]
          },
          {
            "name": "batchUids",
            "in": "query",
            "description": "Lets you filter tasks by their `batchUid`.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              231,
              423,
              598,
              "*"
            ]
          },
          {
            "name": "canceledBy",
            "in": "query",
            "description": "Permits to filter tasks using the uid of the task that canceled them. It's possible to specify several task uids by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              374,
              "*"
            ]
          },
          {
            "name": "types",
            "in": "query",
            "description": "Permits to filter tasks by their related type. By default, when `types` query parameter is not set, all task types are returned. It's possible to specify several types by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Kind"
              }
            },
            "example": [
              "documentDeletion",
              "*"
            ]
          },
          {
            "name": "statuses",
            "in": "query",
            "description": "Permits to filter tasks by their status. By default, when `statuses` query parameter is not set, all task statuses are returned. It's possible to specify several statuses by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Status"
              }
            },
            "example": [
              "succeeded",
              "failed",
              "canceled",
              "*"
            ]
          },
          {
            "name": "indexUids",
            "in": "query",
            "description": "Permits to filter tasks by their related index. By default, when `indexUids` query parameter is not set, the tasks of all the indexes are returned. It is possible to specify several indexes by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "example": [
              "movies",
              "theater",
              "*"
            ]
          },
          {
            "name": "afterEnqueuedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their enqueuedAt time. Matches tasks enqueued after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "beforeEnqueuedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their enqueuedAt time. Matches tasks enqueued before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "afterStartedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their startedAt time. Matches tasks started after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "beforeStartedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their startedAt time. Matches tasks started before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "afterFinishedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their finishedAt time. Matches tasks finished after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          },
          {
            "name": "beforeFinishedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their finishedAt time. Matches tasks finished before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": [
              "2024-08-08T16:37:09.971Z",
              "*"
            ]
          }
        ],
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "taskCancelation",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "400": {
            "description": "A filter is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Query parameters to filter the tasks to cancel are missing. Available query parameters are: `uids`, `indexUids`, `statuses`, `types`, `canceledBy`, `beforeEnqueuedAt`, `afterEnqueuedAt`, `beforeStartedAt`, `afterStartedAt`, `beforeFinishedAt`, `afterFinishedAt`.",
                  "code": "missing_task_filters",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#missing_task_filters"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "The task uid does not exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Task :taskUid not found.",
                  "code": "task_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors/#task_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "tasks.cancel",
              "tasks.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/tasks/cancel?uids=1,2'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.tasks.cancelTasks({ uids: [1, 2] })"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.cancel_tasks({'uids': ['1', '2']})"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->cancelTasks((new CancelTasksQuery())->setUids([1, 2]));"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "CancelTasksQuery query = new CancelTasksQuery().setUids(new int[] {1, 2})\nclient.cancelTasks(query);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.cancel_tasks(uids: [1, 2])"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.CancelTasks(&meilisearch.CancelTasksQuery{\n  UIDS: []int64{1, 2},\n});"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.CancelTasksAsync(new CancelTasksQuery { Uids = new List<int> { 1, 2 } });"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let mut query = tasks::TasksCancelQuery::new(&client);\nquery.with_uids([1, 2]);\n\nlet res = client.cancel_task_with(&query).await.unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.cancelTasks(filter: CancelTasksQuery(uids: [1, 2])) { (result) in\n    switch result {\n    case .success(let taskInfo):\n        print(taskInfo)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.cancelTasks(params: CancelTasksQuery(uids: [1, 2]));"
          }
        ]
      }
    },
    "/tasks/{taskUid}": {
      "get": {
        "tags": [
          "Tasks"
        ],
        "summary": "Get a task",
        "description": "Get a [task](https://www.meilisearch.com/docs/learn/async/asynchronous_operations)",
        "operationId": "get_task",
        "parameters": [
          {
            "name": "taskUid",
            "in": "path",
            "description": "The task identifier",
            "required": true,
            "schema": {
              "type": "string",
              "format": "u-int32"
            },
            "example": 0
          }
        ],
        "responses": {
          "200": {
            "description": "Task successfully retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskView"
                },
                "example": {
                  "uid": 1,
                  "indexUid": "movies",
                  "status": "succeeded",
                  "type": "documentAdditionOrUpdate",
                  "canceledBy": null,
                  "details": {
                    "receivedDocuments": 79000,
                    "indexedDocuments": 79000
                  },
                  "error": null,
                  "duration": "PT1S",
                  "enqueuedAt": "2021-01-01T09:39:00.000000Z",
                  "startedAt": "2021-01-01T09:39:01.000000Z",
                  "finishedAt": "2021-01-01T09:39:02.000000Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "The task uid does not exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Task :taskUid not found.",
                  "code": "task_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors/#task_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "tasks.get",
              "tasks.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/tasks/1'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.tasks.getTask(1)"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.get_task(1)"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->getTask(1);"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.getTask(1);"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.task(1)"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.GetTask(1);"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "TaskInfo task = await client.GetTaskAsync(1);"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let task: Task = client\n  .get_task(1)\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.getTask(taskUid: 1) { (result) in\n      switch result {\n      case .success(let task):\n          print(task)\n      case .failure(let error):\n          print(error)\n      }\n  }"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.getTask(1);"
          }
        ]
      }
    },
    "/version": {
      "get": {
        "tags": [
          "Version"
        ],
        "summary": "Get version",
        "description": "Current version of Meilisearch.",
        "operationId": "get_version",
        "responses": {
          "200": {
            "description": "Instance is healthy",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VersionResponse"
                },
                "example": {
                  "commitSha": "b46889b5f0f2f8b91438a08a358ba8f05fc09fc1",
                  "commitDate": "2021-07-08",
                  "pkgVersion": "0.23.0"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "version",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/version'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.getVersion()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.get_version()"
          },
          {
            "lang": "php",
            "label": "PHP",
            "source": "$client->version();"
          },
          {
            "lang": "java",
            "label": "Java",
            "source": "client.getVersion();"
          },
          {
            "lang": "ruby",
            "label": "Ruby",
            "source": "client.version"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.GetVersion()"
          },
          {
            "lang": "csharp",
            "label": "C#",
            "source": "await client.GetVersionAsync();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let version: Version = client\n  .get_version()\n  .await\n  .unwrap();"
          },
          {
            "lang": "swift",
            "label": "Swift",
            "source": "client.version { (result) in\n    switch result {\n    case .success(let version):\n        print(version)\n    case .failure(let error):\n        print(error)\n    }\n}"
          },
          {
            "lang": "dart",
            "label": "Dart",
            "source": "await client.getVersion();"
          }
        ]
      }
    },
    "/webhooks": {
      "get": {
        "tags": [
          "Webhooks"
        ],
        "operationId": "get_webhooks",
        "responses": {
          "200": {
            "description": "Webhooks are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookResults"
                },
                "example": {
                  "results": [
                    {
                      "uuid": "550e8400-e29b-41d4-a716-446655440000",
                      "url": "https://your.site/on-tasks-completed",
                      "headers": {
                        "Authorization": "Bearer a-secret-token"
                      },
                      "isEditable": true
                    },
                    {
                      "uuid": "550e8400-e29b-41d4-a716-446655440001",
                      "url": "https://another.site/on-tasks-completed",
                      "isEditable": true
                    }
                  ]
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "webhooks.get",
              "webhooks.*",
              "*.get",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/webhooks'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.getWebhooks()"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.get_webhooks()"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.ListWebhooks();"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let webhooks = client.get_webhooks().await.unwrap();"
          }
        ]
      },
      "post": {
        "tags": [
          "Webhooks"
        ],
        "operationId": "post_webhook",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WebhookSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Webhook created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookWithMetadataRedactedAuthorization"
                },
                "example": {
                  "uuid": "550e8400-e29b-41d4-a716-446655440000",
                  "url": "https://your.site/on-tasks-completed",
                  "headers": {
                    "Authorization": "Bearer a-secret-token"
                  },
                  "isEditable": true
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "webhooks.create",
              "webhooks.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/webhooks' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"url\": \"WEBHOOK_TARGET_URL\",\n    \"headers\": {\n      \"authorization\": \"SECURITY_KEY\",\n      \"referer\": \"https://example.com\"\n    }\n  }'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.createWebhook({\n  url: 'WEBHOOK_TARGET_URL',\n  headers: {\n    authorization: 'SECURITY_KEY',\n    referer: 'https://example.com'\n  }\n})"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.create_webhook({\n  'url': 'https://example.com/webhook',\n  'headers': {\"Authorization\":\"\", \"X-Custom-Header\":\"test\"},\n})"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.AddWebhook(&meilisearch.AddWebhookRequest{\n  URL: \"WEBHOOK_TARGET_URL\",\n  Headers: map[string]string{\n    \"authorization\": \"SECURITY_KEY\",\n    \"referer\": \"https://example.com\"\n  },\n});"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let mut payload = meilisearch_sdk::webhooks::WebhookCreate::new(\"WEBHOOK_TARGET_URL\");\npayload\n  .insert_header(\"authorization\", \"SECURITY_KEY\")\n  .insert_header(\"referer\", \"https://example.com\");\nlet webhook = client.create_webhook(&payload).await.unwrap();"
          }
        ]
      }
    },
    "/webhooks/{uuid}": {
      "get": {
        "tags": [
          "Webhooks"
        ],
        "operationId": "get_webhook",
        "parameters": [
          {
            "name": "uuid",
            "in": "path",
            "description": "The universally unique identifier of the webhook",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Webhook found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookWithMetadataRedactedAuthorization"
                },
                "example": {
                  "uuid": "550e8400-e29b-41d4-a716-446655440000",
                  "url": "https://your.site/on-tasks-completed",
                  "headers": {
                    "Authorization": "Bearer a-secret"
                  },
                  "isEditable": true
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                }
              }
            }
          },
          "404": {
            "description": "Webhook not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "webhooks.get",
              "webhooks.*",
              "*.get",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/webhooks/WEBHOOK_UUID'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.getWebhook(WEBHOOK_UUID)"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.get_webhook('WEBHOOK_UID')"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.GetWebhook(\"WEBHOOK_UUID\");"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let webhook = client.get_webhook(\"WEBHOOK_UUID\").await.unwrap();"
          }
        ]
      },
      "delete": {
        "tags": [
          "Webhooks"
        ],
        "operationId": "delete_webhook",
        "parameters": [
          {
            "name": "uuid",
            "in": "path",
            "description": "The universally unique identifier of the webhook",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Webhook deleted successfully"
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                }
              }
            }
          },
          "404": {
            "description": "Webhook not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "webhooks.delete",
              "webhooks.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/webhooks/WEBHOOK_UUID'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.deleteWebhook(WEBHOOK_UUID)"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.delete_webhook('WEBHOOK_UID')"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.DeleteWebhook(\"WEBHOOK_UUID\");"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "client.delete_webhook(\"WEBHOOK_UUID\").await.unwrap();"
          }
        ]
      },
      "patch": {
        "tags": [
          "Webhooks"
        ],
        "operationId": "patch_webhook",
        "parameters": [
          {
            "name": "uuid",
            "in": "path",
            "description": "The universally unique identifier of the webhook",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WebhookSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Webhook updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookWithMetadataRedactedAuthorization"
                },
                "example": {
                  "uuid": "550e8400-e29b-41d4-a716-446655440000",
                  "url": "https://your.site/on-tasks-completed",
                  "headers": {
                    "Authorization": "Bearer a-secret-token"
                  },
                  "isEditable": true
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "webhooks.update",
              "webhooks.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "bash",
            "label": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/webhooks/WEBHOOK_UUID' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"header\": {\n      \"referer\": null\n    }\n  }'"
          },
          {
            "lang": "javascript",
            "label": "JavaScript",
            "source": "client.updateWebhook(WEBHOOK_UUID, {\n  headers: {\n    referer: null\n  }\n})"
          },
          {
            "lang": "python",
            "label": "Python",
            "source": "client.update_webhook('WEBHOOK_UID', {\n  'url': 'https://example.com/new-webhook',\n  'headers': {\"Authorization\":\"\", \"X-Custom-Header\":\"test\"},\n})"
          },
          {
            "lang": "go",
            "label": "Go",
            "source": "client.UpdateWebhook(\"WEBHOOK_UUID\", &meilisearch.UpdateWebhookRequest{\n  Header: map[string]string{\n    \"referer\": \"\"\n  },\n});"
          },
          {
            "lang": "rust",
            "label": "Rust",
            "source": "let mut update = meilisearch_sdk::webhooks::WebhookUpdate::new();\nupdate.remove_header(\"referer\");\nlet webhook = client\n  .update_webhook(\"WEBHOOK_UUID\", &update)\n  .await\n  .unwrap();"
          }
        ]
      }
    }
  },
  "components": {
    "schemas": {
      "Action": {
        "type": "string",
        "enum": [
          "*",
          "search",
          "documents.*",
          "documents.add",
          "documents.get",
          "documents.delete",
          "indexes.*",
          "indexes.create",
          "indexes.get",
          "indexes.update",
          "indexes.delete",
          "indexes.swap",
          "tasks.*",
          "tasks.cancel",
          "tasks.delete",
          "tasks.get",
          "settings.*",
          "settings.get",
          "settings.update",
          "stats.*",
          "stats.get",
          "metrics.*",
          "metrics.get",
          "dumps.*",
          "dumps.create",
          "snapshots.*",
          "snapshots.create",
          "version",
          "keys.create",
          "keys.get",
          "keys.update",
          "keys.delete",
          "experimental.get",
          "experimental.update",
          "export",
          "network.get",
          "network.update",
          "chatCompletions",
          "chats.*",
          "chats.get",
          "chats.delete",
          "chatsSettings.*",
          "chatsSettings.get",
          "chatsSettings.update",
          "*.get",
          "webhooks.get",
          "webhooks.update",
          "webhooks.delete",
          "webhooks.create",
          "webhooks.*",
          "indexes.compact"
        ]
      },
      "AllBatches": {
        "type": "object",
        "required": [
          "results",
          "total",
          "limit"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BatchView"
            }
          },
          "total": {
            "type": "integer",
            "format": "u-int64",
            "minimum": 0
          },
          "limit": {
            "type": "integer",
            "format": "u-int32",
            "minimum": 0
          },
          "from": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int32",
            "minimum": 0
          },
          "next": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int32",
            "minimum": 0
          }
        }
      },
      "AllTasks": {
        "type": "object",
        "required": [
          "results",
          "total",
          "limit"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TaskView"
            },
            "description": "The list of tasks that matched the filter."
          },
          "total": {
            "type": "integer",
            "format": "u-int64",
            "description": "Total number of browsable results using offset/limit parameters for the given resource.",
            "minimum": 0
          },
          "limit": {
            "type": "integer",
            "format": "u-int32",
            "description": "Limit given for the query. If limit is not provided as a query parameter, this parameter displays the default limit value.",
            "minimum": 0
          },
          "from": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int32",
            "description": "The first task uid returned.",
            "minimum": 0
          },
          "next": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int32",
            "description": "Represents the value to send in from to fetch the next slice of the results. The first item for the next slice starts at this exact number. When the returned value is null, it means that all the data have been browsed in the given order.",
            "minimum": 0
          }
        }
      },
      "AttributePatterns": {
        "type": "object",
        "required": [
          "patterns"
        ],
        "properties": {
          "patterns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "example": [
              "title",
              "overview_*",
              "release_date"
            ]
          }
        }
      },
      "BTreeMap": {
        "type": "object",
        "additionalProperties": {
          "type": "array",
          "items": {
            "type": "object",
            "required": [
              "start",
              "length"
            ],
            "properties": {
              "start": {
                "type": "integer",
                "minimum": 0
              },
              "length": {
                "type": "integer",
                "minimum": 0
              },
              "indices": {
                "type": [
                  "array",
                  "null"
                ],
                "items": {
                  "type": "integer",
                  "minimum": 0
                }
              }
            }
          }
        },
        "propertyNames": {
          "type": "string"
        }
      },
      "BatchStats": {
        "type": "object",
        "required": [
          "totalNbTasks",
          "status",
          "types",
          "indexUids"
        ],
        "properties": {
          "totalNbTasks": {
            "$ref": "#/components/schemas/u32"
          },
          "status": {
            "type": "object",
            "additionalProperties": {
              "type": "integer",
              "format": "u-int32",
              "minimum": 0
            },
            "propertyNames": {
              "type": "string",
              "description": "The status of a task.",
              "enum": [
                "enqueued",
                "processing",
                "succeeded",
                "failed",
                "canceled"
              ],
              "example": "processing"
            }
          },
          "types": {
            "type": "object",
            "additionalProperties": {
              "type": "integer",
              "format": "u-int32",
              "minimum": 0
            },
            "propertyNames": {
              "type": "string",
              "description": "The type of the task.",
              "enum": [
                "documentAdditionOrUpdate",
                "documentEdition",
                "documentDeletion",
                "settingsUpdate",
                "indexCreation",
                "indexDeletion",
                "indexUpdate",
                "indexSwap",
                "taskCancelation",
                "taskDeletion",
                "dumpCreation",
                "snapshotCreation",
                "export",
                "upgradeDatabase",
                "indexCompaction",
                "networkTopologyChange"
              ],
              "example": [
                "documentAdditionOrUpdate",
                "documentEdition",
                "documentDeletion",
                "settingsUpdate",
                "indexCreation",
                "indexDeletion",
                "indexUpdate",
                "indexSwap",
                "taskCancelation",
                "taskDeletion",
                "dumpCreation",
                "snapshotCreation",
                "export",
                "upgradeDatabase",
                "indexCompaction",
                "networkTopologyChange"
              ]
            }
          },
          "indexUids": {
            "type": "object",
            "additionalProperties": {
              "type": "integer",
              "format": "u-int32",
              "minimum": 0
            },
            "propertyNames": {
              "type": "string"
            }
          },
          "progressTrace": {
            "type": "object",
            "additionalProperties": {},
            "propertyNames": {
              "type": "string"
            }
          },
          "writeChannelCongestion": {
            "type": [
              "object",
              "null"
            ],
            "additionalProperties": {},
            "propertyNames": {
              "type": "string"
            }
          },
          "internalDatabaseSizes": {
            "type": "object",
            "additionalProperties": {},
            "propertyNames": {
              "type": "string"
            }
          }
        }
      },
      "BatchStatsView": {
        "allOf": [
          {
            "$ref": "#/components/schemas/BatchStats"
          },
          {
            "type": "object",
            "properties": {
              "embedderRequests": {
                "$ref": "#/components/schemas/EmbedderStatsView"
              }
            }
          }
        ]
      },
      "BatchView": {
        "type": "object",
        "required": [
          "uid",
          "details",
          "stats"
        ],
        "properties": {
          "uid": {
            "$ref": "#/components/schemas/u32"
          },
          "progress": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/ProgressView"
              }
            ]
          },
          "details": {
            "$ref": "#/components/schemas/DetailsView"
          },
          "stats": {
            "$ref": "#/components/schemas/BatchStatsView"
          },
          "duration": {
            "type": [
              "string",
              "null"
            ]
          },
          "startedAt": {
            "type": "string",
            "format": "date-time"
          },
          "finishedAt": {
            "type": [
              "string",
              "null"
            ],
            "format": "date-time"
          },
          "batchStrategy": {
            "type": "string"
          }
        }
      },
      "BrowseQuery": {
        "type": "object",
        "required": [
          "offset",
          "limit",
          "retrieveVectors"
        ],
        "properties": {
          "offset": {
            "type": "integer",
            "example": 150,
            "minimum": 0
          },
          "limit": {
            "type": "integer",
            "default": 20,
            "example": 1,
            "minimum": 0
          },
          "fields": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "example": [
              "title, description"
            ]
          },
          "retrieveVectors": {
            "type": "boolean",
            "example": true
          },
          "ids": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "example": [
              "cody",
              "finn",
              "brandy",
              "gambit"
            ]
          },
          "filter": {},
          "sort": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "example": [
              "title:asc",
              "rating:desc"
            ]
          }
        }
      },
      "ChatSearchParams": {
        "type": "object",
        "properties": {
          "hybrid": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/HybridQuery"
              }
            ]
          },
          "limit": {
            "type": [
              "integer",
              "null"
            ],
            "minimum": 0
          },
          "sort": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            }
          },
          "distinct": {
            "type": [
              "string",
              "null"
            ]
          },
          "matchingStrategy": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/MatchingStrategy"
              }
            ]
          },
          "attributesToSearchOn": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            }
          },
          "rankingScoreThreshold": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/RankingScoreThreshold"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "ChatSettings": {
        "type": "object",
        "properties": {
          "description": {
            "type": [
              "string",
              "null"
            ]
          },
          "documentTemplate": {
            "type": [
              "string",
              "null"
            ],
            "description": "A liquid template used to render documents to a text that can be embedded.\n\nMeillisearch interpolates the template for each document and sends the resulting text to the embedder.\nThe embedder then generates document vectors based on this text."
          },
          "documentTemplateMaxBytes": {
            "type": [
              "integer",
              "null"
            ],
            "description": "Rendered texts are truncated to this size. Defaults to 400.",
            "minimum": 0
          },
          "searchParameters": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/ChatSearchParams",
                "description": "The search parameters to use for the LLM."
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Code": {
        "type": "string",
        "enum": [
          "api_key_already_exists",
          "api_key_not_found",
          "bad_parameter",
          "bad_request",
          "database_size_limit_reached",
          "document_not_found",
          "dump_already_processing",
          "dump_not_found",
          "dump_process_failed",
          "duplicate_index_found",
          "immutable_api_key_actions",
          "immutable_api_key_created_at",
          "immutable_api_key_expires_at",
          "immutable_api_key_indexes",
          "immutable_api_key_key",
          "immutable_api_key_uid",
          "immutable_api_key_updated_at",
          "immutable_index_created_at",
          "immutable_index_updated_at",
          "import_task_already_received",
          "import_task_unknown_remote",
          "import_task_without_network_task",
          "index_already_exists",
          "index_creation_failed",
          "index_not_found",
          "index_primary_key_already_exists",
          "index_primary_key_multiple_candidates_found",
          "index_primary_key_no_candidate_found",
          "internal",
          "invalid_api_key",
          "invalid_api_key_actions",
          "invalid_api_key_description",
          "invalid_api_key_expires_at",
          "invalid_api_key_indexes",
          "invalid_api_key_limit",
          "invalid_api_key_name",
          "invalid_api_key_offset",
          "invalid_api_key_uid",
          "invalid_content_type",
          "invalid_document_csv_delimiter",
          "invalid_document_fields",
          "invalid_document_retrieve_vectors",
          "missing_document_filter",
          "missing_document_edition_function",
          "inconsistent_document_change_headers",
          "invalid_document_filter",
          "invalid_document_sort",
          "invalid_document_geo_field",
          "invalid_document_geojson_field",
          "invalid_header_value",
          "invalid_vector_dimensions",
          "invalid_vectors_type",
          "invalid_document_id",
          "invalid_document_ids",
          "invalid_document_limit",
          "invalid_document_offset",
          "invalid_search_embedder",
          "invalid_similar_embedder",
          "invalid_search_hybrid_query",
          "invalid_index_limit",
          "invalid_index_offset",
          "invalid_index_primary_key",
          "invalid_index_custom_metadata",
          "invalid_index_uid",
          "invalid_multi_search_facets",
          "invalid_multi_search_facets_by_index",
          "invalid_multi_search_facet_order",
          "invalid_multi_search_query_personalization",
          "invalid_multi_search_federated",
          "invalid_multi_search_federation_options",
          "invalid_multi_search_max_values_per_facet",
          "invalid_multi_search_merge_facets",
          "invalid_multi_search_query_facets",
          "invalid_multi_search_query_pagination",
          "invalid_multi_search_query_ranking_rules",
          "invalid_multi_search_query_position",
          "invalid_multi_search_remote",
          "invalid_multi_search_weight",
          "invalid_network_leader",
          "invalid_network_remotes",
          "invalid_network_self",
          "invalid_network_search_api_key",
          "invalid_network_write_api_key",
          "invalid_network_url",
          "invalid_search_attributes_to_search_on",
          "invalid_search_attributes_to_crop",
          "invalid_search_attributes_to_highlight",
          "invalid_similar_attributes_to_retrieve",
          "invalid_similar_retrieve_vectors",
          "invalid_search_attributes_to_retrieve",
          "invalid_search_ranking_score_threshold",
          "invalid_similar_ranking_score_threshold",
          "invalid_search_retrieve_vectors",
          "invalid_search_crop_length",
          "invalid_search_crop_marker",
          "invalid_search_facets",
          "invalid_search_semantic_ratio",
          "invalid_search_locales",
          "invalid_facet_search_exhaustive_facet_count",
          "invalid_facet_search_facet_name",
          "invalid_similar_id",
          "invalid_search_filter",
          "invalid_similar_filter",
          "invalid_search_highlight_post_tag",
          "invalid_search_highlight_pre_tag",
          "invalid_search_hits_per_page",
          "invalid_similar_limit",
          "invalid_search_limit",
          "invalid_search_matching_strategy",
          "invalid_similar_offset",
          "invalid_search_offset",
          "invalid_search_page",
          "invalid_search_q",
          "invalid_facet_search_query",
          "invalid_facet_search_name",
          "facet_search_disabled",
          "invalid_search_vector",
          "invalid_search_media",
          "invalid_search_show_matches_position",
          "invalid_search_show_ranking_score",
          "invalid_similar_show_ranking_score",
          "invalid_search_show_ranking_score_details",
          "invalid_similar_show_ranking_score_details",
          "invalid_search_sort",
          "invalid_search_distinct",
          "invalid_search_personalize",
          "invalid_search_personalize_user_context",
          "invalid_search_media_and_vector",
          "invalid_settings_displayed_attributes",
          "invalid_settings_distinct_attribute",
          "invalid_settings_proximity_precision",
          "invalid_settings_facet_search",
          "invalid_settings_prefix_search",
          "invalid_settings_faceting",
          "invalid_settings_filterable_attributes",
          "invalid_settings_pagination",
          "invalid_settings_search_cutoff_ms",
          "invalid_settings_embedders",
          "invalid_settings_ranking_rules",
          "invalid_settings_searchable_attributes",
          "invalid_settings_sortable_attributes",
          "invalid_settings_stop_words",
          "invalid_settings_non_separator_tokens",
          "invalid_settings_separator_tokens",
          "invalid_settings_dictionary",
          "invalid_settings_synonyms",
          "invalid_settings_typo_tolerance",
          "invalid_settings_localized_attributes",
          "invalid_state",
          "invalid_store_file",
          "invalid_swap_duplicate_index_found",
          "invalid_swap_indexes",
          "invalid_swap_rename",
          "invalid_task_after_enqueued_at",
          "invalid_task_after_finished_at",
          "invalid_task_after_started_at",
          "invalid_task_before_enqueued_at",
          "invalid_task_before_finished_at",
          "invalid_task_before_started_at",
          "invalid_task_canceled_by",
          "invalid_task_from",
          "invalid_task_limit",
          "invalid_task_reverse",
          "invalid_task_statuses",
          "invalid_task_types",
          "invalid_task_uids",
          "invalid_batch_uids",
          "io_error",
          "feature_not_enabled",
          "malformed_payload",
          "max_fields_limit_exceeded",
          "missing_api_key_actions",
          "missing_api_key_expires_at",
          "missing_api_key_indexes",
          "missing_authorization_header",
          "missing_content_type",
          "missing_document_id",
          "missing_facet_search_facet_name",
          "missing_index_uid",
          "missing_master_key",
          "missing_network_url",
          "missing_payload",
          "missing_search_hybrid",
          "missing_swap_indexes",
          "missing_task_filters",
          "network_version_mismatch",
          "no_space_left_on_device",
          "not_leader",
          "payload_too_large",
          "remote_bad_response",
          "remote_bad_request",
          "remote_could_not_send_request",
          "remote_invalid_api_key",
          "remote_remote_error",
          "remote_timeout",
          "too_many_search_requests",
          "task_not_found",
          "task_file_not_found",
          "batch_not_found",
          "too_many_open_files",
          "too_many_vectors",
          "unexpected_network_previous_remotes",
          "network_version_too_old",
          "unprocessed_network_task",
          "unretrievable_document",
          "unretrievable_error_code",
          "unsupported_media_type",
          "invalid_s3_snapshot_request",
          "invalid_s3_snapshot_parameters",
          "s3_snapshot_server_error",
          "vector_embedding_error",
          "not_found_similar_id",
          "invalid_document_edition_context",
          "invalid_document_edition_function_filter",
          "edit_documents_by_function_error",
          "invalid_settings_index_chat",
          "invalid_settings_vector_store",
          "invalid_export_url",
          "invalid_export_api_key",
          "invalid_export_payload_size",
          "invalid_export_indexes_patterns",
          "invalid_export_index_filter",
          "invalid_export_index_override_settings",
          "unimplemented_external_function_calling",
          "unimplemented_non_streaming_chat_completions",
          "unimplemented_multi_choice_chat_completions",
          "chat_not_found",
          "invalid_chat_setting_document_template",
          "invalid_chat_completion_org_id",
          "invalid_chat_completion_project_id",
          "invalid_chat_completion_api_version",
          "invalid_chat_completion_deployment_id",
          "invalid_chat_completion_source",
          "invalid_chat_completion_base_api",
          "invalid_chat_completion_api_key",
          "invalid_chat_completion_prompts",
          "invalid_chat_completion_system_prompt",
          "invalid_chat_completion_search_description_prompt",
          "invalid_chat_completion_search_query_param_prompt",
          "invalid_chat_completion_search_filter_param_prompt",
          "invalid_chat_completion_search_index_uid_param_prompt",
          "invalid_chat_completion_pre_query_prompt",
          "requires_enterprise_edition",
          "invalid_webhooks",
          "invalid_webhook_url",
          "invalid_webhook_headers",
          "immutable_webhook",
          "invalid_webhook_uuid",
          "webhook_not_found",
          "immutable_webhook_uuid",
          "immutable_webhook_is_editable"
        ]
      },
      "ComputedFacets": {
        "type": "object",
        "required": [
          "distribution",
          "stats"
        ],
        "properties": {
          "distribution": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "additionalProperties": {
                "type": "integer",
                "format": "u-int64",
                "minimum": 0
              },
              "propertyNames": {
                "type": "string"
              }
            },
            "propertyNames": {
              "type": "string"
            }
          },
          "stats": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/FacetStats"
            },
            "propertyNames": {
              "type": "string"
            }
          }
        }
      },
      "CreateApiKey": {
        "type": "object",
        "required": [
          "uid",
          "actions",
          "indexes"
        ],
        "properties": {
          "description": {
            "type": [
              "string",
              "null"
            ],
            "description": "A description for the key. `null` if empty.",
            "example": null
          },
          "name": {
            "type": [
              "string",
              "null"
            ],
            "description": "A human-readable name for the key. `null` if empty.",
            "example": "Indexing Products API key"
          },
          "uid": {
            "type": "string",
            "format": "uuid",
            "description": "A uuid v4 to identify the API Key. If not specified, it's generated by Meilisearch.",
            "example": null
          },
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Action"
            },
            "description": "A list of actions permitted for the key. `[\"*\"]` for all actions. The `*` character can be used as a wildcard when located at the last position. e.g. `documents.*` to authorize access on all documents endpoints.",
            "example": [
              "documents.add"
            ]
          },
          "indexes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of accessible indexes permitted for the key. `[\"*\"]` for all indexes. The `*` character can be used as a wildcard when located at the last position. e.g. `products_*` to allow access to all indexes whose names start with `products_`.",
            "example": [
              "products"
            ]
          },
          "expiresAt": {
            "type": [
              "string",
              "null"
            ],
            "format": "date-time",
            "description": "Represent the expiration date and time as RFC 3339 format. `null` equals to no expiration time."
          }
        }
      },
      "DbTaskNetwork": {
        "oneOf": [
          {
            "type": "object",
            "description": "Tasks that were duplicated from `origin`",
            "required": [
              "origin"
            ],
            "properties": {
              "origin": {
                "$ref": "#/components/schemas/Origin"
              }
            }
          },
          {
            "type": "object",
            "description": "Tasks that were duplicated as `remote_tasks`",
            "required": [
              "remote_tasks"
            ],
            "properties": {
              "remote_tasks": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/RemoteTask"
                },
                "propertyNames": {
                  "type": "string"
                }
              },
              "network_version": {
                "type": "string",
                "format": "uuid"
              }
            }
          },
          {
            "type": "object",
            "description": "Document import tasks sent in the context of `network_change`",
            "required": [
              "import_from",
              "network_change"
            ],
            "properties": {
              "import_from": {
                "$ref": "#/components/schemas/ImportData"
              },
              "network_change": {
                "$ref": "#/components/schemas/Origin"
              }
            }
          }
        ]
      },
      "DetailsExportIndexSettings": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ExportIndexSettings"
          },
          {
            "type": "object",
            "properties": {
              "matchedDocuments": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int64",
                "minimum": 0
              }
            }
          }
        ]
      },
      "DetailsView": {
        "allOf": [
          {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/Settings_Unchecked",
                "description": "[Learn more about the settings in this guide](https://www.meilisearch.com/docs/reference/api/settings)."
              }
            ]
          },
          {
            "type": "object",
            "properties": {
              "receivedDocuments": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int64",
                "description": "Number of documents received for documentAdditionOrUpdate task.",
                "minimum": 0
              },
              "indexedDocuments": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int64",
                "description": "Number of documents finally indexed for documentAdditionOrUpdate task or a documentAdditionOrUpdate batch of tasks.",
                "minimum": 0
              },
              "editedDocuments": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int64",
                "description": "Number of documents edited for editDocumentByFunction task.",
                "minimum": 0
              },
              "primaryKey": {
                "type": [
                  "string",
                  "null"
                ],
                "description": "Value for the primaryKey field encountered if any for indexCreation or indexUpdate task."
              },
              "providedIds": {
                "type": [
                  "integer",
                  "null"
                ],
                "description": "Number of provided document ids for the documentDeletion task.",
                "minimum": 0
              },
              "deletedDocuments": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int64",
                "description": "Number of documents finally deleted for documentDeletion and indexDeletion tasks.",
                "minimum": 0
              },
              "matchedTasks": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int64",
                "description": "Number of tasks that match the request for taskCancelation or taskDeletion tasks.",
                "minimum": 0
              },
              "canceledTasks": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int64",
                "description": "Number of tasks canceled for taskCancelation.",
                "minimum": 0
              },
              "deletedTasks": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int64",
                "description": "Number of tasks deleted for taskDeletion.",
                "minimum": 0
              },
              "originalFilter": {
                "type": [
                  "string",
                  "null"
                ],
                "description": "Original filter query for taskCancelation or taskDeletion tasks."
              },
              "dumpUid": {
                "type": [
                  "string",
                  "null"
                ],
                "description": "Identifier generated for the dump for dumpCreation task."
              },
              "context": {
                "type": [
                  "object",
                  "null"
                ]
              },
              "function": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "swaps": {
                "type": [
                  "array",
                  "null"
                ],
                "items": {
                  "$ref": "#/components/schemas/IndexSwap"
                }
              },
              "upgradeFrom": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "upgradeTo": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "url": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "apiKey": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "payloadSize": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "indexes": {
                "type": [
                  "object",
                  "null"
                ],
                "additionalProperties": {
                  "$ref": "#/components/schemas/DetailsExportIndexSettings"
                },
                "propertyNames": {
                  "type": "string"
                }
              },
              "oldIndexUid": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "newIndexUid": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "preCompactionSize": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "postCompactionSize": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "movedDocuments": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int64",
                "minimum": 0
              },
              "message": {
                "type": [
                  "string",
                  "null"
                ]
              }
            }
          }
        ]
      },
      "DistributionShift": {
        "type": "object",
        "description": "Describes the mean and sigma of distribution of embedding similarity in the embedding space.\n\nThe intended use is to make the similarity score more comparable to the regular ranking score.\nThis allows to correct effects where results are too \"packed\" around a certain value.",
        "required": [
          "current_mean",
          "current_sigma"
        ],
        "properties": {
          "current_mean": {
            "type": "number",
            "format": "float",
            "description": "Value where the results are \"packed\".\n\nSimilarity scores are translated so that they are packed around 0.5 instead"
          },
          "current_sigma": {
            "type": "number",
            "format": "float",
            "description": "standard deviation of a similarity score.\n\nSet below 0.4 to make the results less packed around the mean, and above 0.4 to make them more packed."
          }
        }
      },
      "DocumentDeletionByFilter": {
        "type": "object",
        "required": [
          "filter"
        ],
        "properties": {
          "filter": {}
        }
      },
      "DocumentEditionByFunction": {
        "type": "object",
        "required": [
          "function"
        ],
        "properties": {
          "filter": {
            "description": "A string containing a RHAI function."
          },
          "context": {
            "description": "A string containing a filter expression."
          },
          "function": {
            "type": "string",
            "description": "An object with data Meilisearch should make available for the editing function."
          }
        }
      },
      "EmbedderSource": {
        "type": "string",
        "enum": [
          "openAi",
          "huggingFace",
          "ollama",
          "userProvided",
          "rest",
          "composite"
        ]
      },
      "EmbedderStatsView": {
        "type": "object",
        "required": [
          "total",
          "failed"
        ],
        "properties": {
          "total": {
            "type": "integer",
            "minimum": 0
          },
          "failed": {
            "type": "integer",
            "minimum": 0
          },
          "lastError": {
            "type": [
              "string",
              "null"
            ]
          }
        }
      },
      "ErrorType": {
        "type": "string",
        "enum": [
          "internal",
          "invalid_request",
          "auth",
          "system"
        ]
      },
      "Export": {
        "type": "object",
        "properties": {
          "url": {
            "type": [
              "string",
              "null"
            ],
            "example": "https://ms-1234.heaven.meilisearch.com"
          },
          "apiKey": {
            "type": [
              "string",
              "null"
            ],
            "example": "1234abcd"
          },
          "payloadSize": {
            "type": [
              "string",
              "null"
            ],
            "example": "24MiB"
          },
          "indexes": {
            "type": [
              "object",
              "null"
            ],
            "additionalProperties": {
              "$ref": "#/components/schemas/ExportIndexSettings"
            },
            "propertyNames": {
              "type": "string"
            },
            "example": {
              "*": {
                "filter": null
              }
            }
          }
        }
      },
      "ExportIndexSettings": {
        "type": "object",
        "properties": {
          "filter": {
            "type": [
              "string",
              "null"
            ],
            "example": "genres = action"
          },
          "overrideSettings": {
            "type": [
              "boolean",
              "null"
            ],
            "example": true
          }
        }
      },
      "FacetSearchQuery": {
        "type": "object",
        "required": [
          "facet_name",
          "matching_strategy"
        ],
        "properties": {
          "facet_query": {
            "type": [
              "string",
              "null"
            ]
          },
          "facet_name": {
            "type": "string"
          },
          "q": {
            "type": [
              "string",
              "null"
            ]
          },
          "vector": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "number",
              "format": "float"
            }
          },
          "media": {},
          "hybrid": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/HybridQuery"
              }
            ]
          },
          "filter": {},
          "matching_strategy": {
            "$ref": "#/components/schemas/MatchingStrategy"
          },
          "attributes_to_search_on": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            }
          },
          "ranking_score_threshold": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/RankingScoreThreshold"
              }
            ]
          },
          "locales": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "$ref": "#/components/schemas/Locale"
            }
          },
          "exhaustive_facet_count": {
            "type": [
              "boolean",
              "null"
            ]
          }
        }
      },
      "FacetStats": {
        "type": "object",
        "required": [
          "min",
          "max"
        ],
        "properties": {
          "min": {
            "type": "number",
            "format": "double"
          },
          "max": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "FacetValuesSort": {
        "type": "string",
        "enum": [
          "alpha",
          "count"
        ]
      },
      "FacetingSettings": {
        "type": "object",
        "properties": {
          "maxValuesPerFacet": {
            "type": [
              "integer",
              "null"
            ],
            "example": 10,
            "minimum": 0
          },
          "sortFacetValuesBy": {
            "type": [
              "object",
              "null"
            ],
            "additionalProperties": {
              "$ref": "#/components/schemas/FacetValuesSort"
            },
            "propertyNames": {
              "type": "string"
            },
            "example": {
              "genre": "count"
            }
          }
        },
        "additionalProperties": false
      },
      "FederatedFacets": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/components/schemas/ComputedFacets"
        },
        "propertyNames": {
          "type": "string"
        }
      },
      "FederatedSearch": {
        "type": "object",
        "required": [
          "queries"
        ],
        "properties": {
          "queries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchQueryWithIndex"
            }
          },
          "federation": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/Federation"
              }
            ]
          }
        }
      },
      "FederatedSearchResult": {
        "allOf": [
          {
            "$ref": "#/components/schemas/HitsInfo"
          },
          {
            "type": "object",
            "required": [
              "hits",
              "processingTimeMs"
            ],
            "properties": {
              "hits": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/SearchHit"
                }
              },
              "processingTimeMs": {
                "type": "integer",
                "minimum": 0
              },
              "queryVectors": {
                "type": [
                  "object",
                  "null"
                ],
                "additionalProperties": {
                  "$ref": "#/components/schemas/Vec"
                },
                "propertyNames": {
                  "type": "integer",
                  "minimum": 0
                }
              },
              "semanticHitCount": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int32",
                "minimum": 0
              },
              "facetDistribution": {
                "type": [
                  "object",
                  "null"
                ],
                "additionalProperties": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "integer",
                    "format": "u-int64",
                    "minimum": 0
                  },
                  "propertyNames": {
                    "type": "string"
                  }
                },
                "propertyNames": {
                  "type": "string"
                }
              },
              "facetStats": {
                "type": [
                  "object",
                  "null"
                ],
                "additionalProperties": {
                  "$ref": "#/components/schemas/FacetStats"
                },
                "propertyNames": {
                  "type": "string"
                }
              },
              "facetsByIndex": {
                "$ref": "#/components/schemas/FederatedFacets"
              },
              "requestUid": {
                "type": [
                  "string",
                  "null"
                ],
                "format": "uuid"
              },
              "metadata": {
                "type": [
                  "array",
                  "null"
                ],
                "items": {
                  "$ref": "#/components/schemas/SearchMetadata"
                }
              },
              "remoteErrors": {
                "type": [
                  "object",
                  "null"
                ],
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "propertyNames": {
                  "type": "string"
                }
              }
            }
          }
        ]
      },
      "Federation": {
        "type": "object",
        "required": [
          "limit",
          "offset",
          "facetsByIndex"
        ],
        "properties": {
          "limit": {
            "type": "integer",
            "minimum": 0
          },
          "offset": {
            "type": "integer",
            "minimum": 0
          },
          "facetsByIndex": {
            "type": "object",
            "additionalProperties": {
              "type": [
                "array",
                "null"
              ],
              "items": {
                "type": "string"
              }
            },
            "propertyNames": {
              "type": "string",
              "description": "An index uid is composed of only ascii alphanumeric characters, - and _, between 1 and 400\nbytes long",
              "example": "movies"
            }
          },
          "mergeFacets": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/MergeFacets"
              }
            ]
          }
        }
      },
      "FederationOptions": {
        "type": "object",
        "required": [
          "weight"
        ],
        "properties": {
          "weight": {
            "type": "number",
            "format": "double"
          },
          "remote": {
            "type": [
              "string",
              "null"
            ]
          },
          "queryPosition": {
            "type": [
              "integer",
              "null"
            ],
            "minimum": 0
          }
        }
      },
      "FilterFeatures": {
        "type": "object",
        "properties": {
          "equality": {
            "type": "boolean"
          },
          "comparison": {
            "type": "boolean"
          }
        },
        "additionalProperties": false
      },
      "FilterableAttributesFeatures": {
        "type": "object",
        "properties": {
          "facetSearch": {
            "type": "boolean"
          },
          "filter": {
            "$ref": "#/components/schemas/FilterFeatures"
          }
        },
        "additionalProperties": false
      },
      "FilterableAttributesPatterns": {
        "type": "object",
        "required": [
          "attributePatterns"
        ],
        "properties": {
          "attributePatterns": {
            "$ref": "#/components/schemas/AttributePatterns"
          },
          "features": {
            "$ref": "#/components/schemas/FilterableAttributesFeatures"
          }
        },
        "additionalProperties": false
      },
      "FilterableAttributesRule": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/FilterableAttributesPatterns"
          }
        ]
      },
      "GetLogs": {
        "type": "object",
        "required": [
          "target",
          "mode",
          "profileMemory"
        ],
        "properties": {
          "target": {
            "type": "string",
            "description": "Lets you specify which parts of the code you want to inspect and is formatted like that: code_part=log_level,code_part=log_level\n- If the `code_part` is missing, then the `log_level` will be applied to everything.\n- If the `log_level` is missing, then the `code_part` will be selected in `info` log level.",
            "default": "info",
            "example": "milli=trace,index_scheduler,actix_web=off"
          },
          "mode": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/LogMode",
                "description": "Lets you customize the format of the logs."
              }
            ],
            "default": "Human"
          },
          "profileMemory": {
            "type": "boolean",
            "description": "A boolean to indicate if you want to profile the memory as well. This is only useful while using the `profile` mode.\nBe cautious, though; it slows down the engine a lot.",
            "default": false
          }
        }
      },
      "HealthResponse": {
        "type": "object",
        "required": [
          "status"
        ],
        "properties": {
          "status": {
            "$ref": "#/components/schemas/HealthStatus",
            "description": "The status of the instance."
          }
        }
      },
      "HealthStatus": {
        "type": "string",
        "enum": [
          "available"
        ]
      },
      "HitsInfo": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "hitsPerPage",
              "page",
              "totalPages",
              "totalHits"
            ],
            "properties": {
              "hitsPerPage": {
                "type": "integer",
                "minimum": 0
              },
              "page": {
                "type": "integer",
                "minimum": 0
              },
              "totalPages": {
                "type": "integer",
                "minimum": 0
              },
              "totalHits": {
                "type": "integer",
                "minimum": 0
              }
            }
          },
          {
            "type": "object",
            "required": [
              "limit",
              "offset",
              "estimatedTotalHits"
            ],
            "properties": {
              "limit": {
                "type": "integer",
                "minimum": 0
              },
              "offset": {
                "type": "integer",
                "minimum": 0
              },
              "estimatedTotalHits": {
                "type": "integer",
                "minimum": 0
              }
            }
          }
        ]
      },
      "HybridQuery": {
        "type": "object",
        "required": [
          "embedder"
        ],
        "properties": {
          "semanticRatio": {
            "type": "number",
            "format": "float"
          },
          "embedder": {
            "type": "string"
          }
        }
      },
      "ImportData": {
        "type": "object",
        "description": "Import data stored in a task",
        "required": [
          "remoteName",
          "documentCount"
        ],
        "properties": {
          "remoteName": {
            "type": "string",
            "description": "Remote that this task is imported from"
          },
          "indexName": {
            "type": [
              "string",
              "null"
            ],
            "description": "Index relevant to this task"
          },
          "documentCount": {
            "type": "integer",
            "format": "u-int64",
            "description": "Number of documents in this task",
            "minimum": 0
          }
        }
      },
      "IndexCreateRequest": {
        "type": "object",
        "required": [
          "uid"
        ],
        "properties": {
          "uid": {
            "$ref": "#/components/schemas/IndexUid",
            "description": "The name of the index"
          },
          "primaryKey": {
            "type": [
              "string",
              "null"
            ],
            "description": "The primary key of the index",
            "example": "id"
          }
        }
      },
      "IndexStats": {
        "type": "object",
        "description": "Stats of an `Index`, as known to the `stats` route.",
        "required": [
          "numberOfDocuments",
          "rawDocumentDbSize",
          "avgDocumentSize",
          "isIndexing",
          "fieldDistribution"
        ],
        "properties": {
          "numberOfDocuments": {
            "type": "integer",
            "format": "u-int64",
            "description": "Number of documents in the index",
            "minimum": 0
          },
          "rawDocumentDbSize": {
            "type": "integer",
            "format": "u-int64",
            "description": "Size of the documents database, in bytes.",
            "minimum": 0
          },
          "avgDocumentSize": {
            "type": "integer",
            "format": "u-int64",
            "description": "Average size of a document in the documents database.",
            "minimum": 0
          },
          "isIndexing": {
            "type": "boolean",
            "description": "Whether or not the index is currently ingesting document"
          },
          "numberOfEmbeddings": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int64",
            "description": "Number of embeddings in the index",
            "minimum": 0
          },
          "numberOfEmbeddedDocuments": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int64",
            "description": "Number of embedded documents in the index",
            "minimum": 0
          },
          "fieldDistribution": {
            "type": "object",
            "description": "Association of every field name with the number of times it occurs in the documents.",
            "additionalProperties": {
              "type": "integer",
              "format": "u-int64",
              "minimum": 0
            },
            "propertyNames": {
              "type": "string"
            }
          }
        }
      },
      "IndexSwap": {
        "type": "object",
        "required": [
          "indexes"
        ],
        "properties": {
          "indexes": {
            "type": "array",
            "items": false,
            "prefixItems": [
              {
                "type": "string"
              },
              {
                "type": "string"
              }
            ]
          },
          "rename": {
            "type": "boolean"
          }
        }
      },
      "IndexUid": {
        "type": "string",
        "description": "An index uid is composed of only ascii alphanumeric characters, - and _, between 1 and 400\nbytes long",
        "example": "movies"
      },
      "IndexView": {
        "type": "object",
        "required": [
          "uid",
          "createdAt",
          "updatedAt"
        ],
        "properties": {
          "uid": {
            "type": "string",
            "description": "Unique identifier for the index"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "An `RFC 3339` format for date/time/duration."
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "An `RFC 3339` format for date/time/duration."
          },
          "primaryKey": {
            "type": [
              "string",
              "null"
            ],
            "description": "Custom primaryKey for documents"
          }
        }
      },
      "KeyView": {
        "type": "object",
        "required": [
          "key",
          "uid",
          "actions",
          "indexes",
          "createdAt",
          "updatedAt"
        ],
        "properties": {
          "name": {
            "type": [
              "string",
              "null"
            ],
            "description": "The name of the API Key if any"
          },
          "description": {
            "type": [
              "string",
              "null"
            ],
            "description": "The description of the API Key if any"
          },
          "key": {
            "type": "string",
            "description": "The actual API Key you can send to Meilisearch"
          },
          "uid": {
            "type": "string",
            "format": "uuid",
            "description": "The `Uuid` specified while creating the key or autogenerated by Meilisearch."
          },
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Action"
            },
            "description": "The actions accessible with this key."
          },
          "indexes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The indexes accessible with this key."
          },
          "expiresAt": {
            "type": [
              "string",
              "null"
            ],
            "format": "date-time",
            "description": "The expiration date of the key. Once this timestamp is exceeded the key is not deleted but cannot be used anymore."
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "The date of creation of this API Key.",
            "readOnly": true
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "The date of the last update made on this key.",
            "readOnly": true
          }
        }
      },
      "Kind": {
        "type": "string",
        "description": "The type of the task.",
        "enum": [
          "documentAdditionOrUpdate",
          "documentEdition",
          "documentDeletion",
          "settingsUpdate",
          "indexCreation",
          "indexDeletion",
          "indexUpdate",
          "indexSwap",
          "taskCancelation",
          "taskDeletion",
          "dumpCreation",
          "snapshotCreation",
          "export",
          "upgradeDatabase",
          "indexCompaction",
          "networkTopologyChange"
        ],
        "example": [
          "documentAdditionOrUpdate",
          "documentEdition",
          "documentDeletion",
          "settingsUpdate",
          "indexCreation",
          "indexDeletion",
          "indexUpdate",
          "indexSwap",
          "taskCancelation",
          "taskDeletion",
          "dumpCreation",
          "snapshotCreation",
          "export",
          "upgradeDatabase",
          "indexCompaction",
          "networkTopologyChange"
        ]
      },
      "Locale": {
        "type": "string",
        "enum": [
          "af",
          "ak",
          "am",
          "ar",
          "az",
          "be",
          "bn",
          "bg",
          "ca",
          "cs",
          "da",
          "de",
          "el",
          "en",
          "eo",
          "et",
          "fi",
          "fr",
          "gu",
          "he",
          "hi",
          "hr",
          "hu",
          "hy",
          "id",
          "it",
          "jv",
          "ja",
          "kn",
          "ka",
          "km",
          "ko",
          "la",
          "lv",
          "lt",
          "ml",
          "mr",
          "mk",
          "my",
          "ne",
          "nl",
          "nb",
          "or",
          "pa",
          "fa",
          "pl",
          "pt",
          "ro",
          "ru",
          "si",
          "sk",
          "sl",
          "sn",
          "es",
          "sr",
          "sv",
          "ta",
          "te",
          "tl",
          "th",
          "tk",
          "tr",
          "uk",
          "ur",
          "uz",
          "vi",
          "yi",
          "zh",
          "zu",
          "afr",
          "aka",
          "amh",
          "ara",
          "aze",
          "bel",
          "ben",
          "bul",
          "cat",
          "ces",
          "dan",
          "deu",
          "ell",
          "eng",
          "epo",
          "est",
          "fin",
          "fra",
          "guj",
          "heb",
          "hin",
          "hrv",
          "hun",
          "hye",
          "ind",
          "ita",
          "jav",
          "jpn",
          "kan",
          "kat",
          "khm",
          "kor",
          "lat",
          "lav",
          "lit",
          "mal",
          "mar",
          "mkd",
          "mya",
          "nep",
          "nld",
          "nob",
          "ori",
          "pan",
          "pes",
          "pol",
          "por",
          "ron",
          "rus",
          "sin",
          "slk",
          "slv",
          "sna",
          "spa",
          "srp",
          "swe",
          "tam",
          "tel",
          "tgl",
          "tha",
          "tuk",
          "tur",
          "ukr",
          "urd",
          "uzb",
          "vie",
          "yid",
          "zho",
          "zul",
          "cmn"
        ]
      },
      "LocalizedAttributesRuleView": {
        "type": "object",
        "required": [
          "attributePatterns",
          "locales"
        ],
        "properties": {
          "attributePatterns": {
            "$ref": "#/components/schemas/AttributePatterns"
          },
          "locales": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Locale"
            }
          }
        }
      },
      "LogMode": {
        "type": "string",
        "enum": [
          "human",
          "json",
          "profile"
        ]
      },
      "MatchingStrategy": {
        "type": "string",
        "description": "This is unfortunately a duplication of the struct in <meilisearch/src/search/mod.rs>.\nThe reason why it is duplicated is because milli cannot depend on meilisearch. It would be cyclic imports.",
        "enum": [
          "last",
          "all",
          "frequency"
        ]
      },
      "MergeFacets": {
        "type": "object",
        "properties": {
          "maxValuesPerFacet": {
            "type": [
              "integer",
              "null"
            ],
            "minimum": 0
          }
        }
      },
      "MinWordSizeTyposSetting": {
        "type": "object",
        "properties": {
          "oneTypo": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int8",
            "example": 5,
            "minimum": 0
          },
          "twoTypos": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int8",
            "example": 9,
            "minimum": 0
          }
        },
        "additionalProperties": false
      },
      "Network": {
        "type": "object",
        "properties": {
          "remotes": {
            "type": [
              "object",
              "null"
            ],
            "additionalProperties": {
              "$ref": "#/components/schemas/Remote"
            },
            "propertyNames": {
              "type": "string"
            },
            "example": {
              "ms-00": {
                "url": "http://localhost:7700"
              },
              "ms-01": {
                "url": "http://localhost:7701"
              }
            }
          },
          "self": {
            "type": [
              "string",
              "null"
            ],
            "example": "ms-00"
          },
          "leader": {
            "type": [
              "string",
              "null"
            ],
            "example": "ms-00"
          },
          "previousRemotes": {
            "type": [
              "object",
              "null"
            ],
            "additionalProperties": {
              "$ref": "#/components/schemas/Remote"
            },
            "propertyNames": {
              "type": "string"
            },
            "example": {
              "ms-00": {
                "url": "http://localhost:7700"
              },
              "ms-01": {
                "url": "http://localhost:7701"
              }
            }
          }
        }
      },
      "Origin": {
        "type": "object",
        "required": [
          "remoteName",
          "taskUid"
        ],
        "properties": {
          "remoteName": {
            "type": "string"
          },
          "taskUid": {
            "type": "integer",
            "format": "u-int32",
            "minimum": 0
          },
          "networkVersion": {
            "type": "string",
            "format": "uuid"
          }
        }
      },
      "OverridePooling": {
        "type": "string",
        "enum": [
          "useModel",
          "forceCls",
          "forceMean"
        ]
      },
      "PaginationSettings": {
        "type": "object",
        "properties": {
          "maxTotalHits": {
            "type": [
              "integer",
              "null"
            ],
            "example": 250,
            "minimum": 0
          }
        },
        "additionalProperties": false
      },
      "PaginationView_IndexView": {
        "type": "object",
        "required": [
          "results",
          "offset",
          "limit",
          "total"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "uid",
                "createdAt",
                "updatedAt"
              ],
              "properties": {
                "uid": {
                  "type": "string",
                  "description": "Unique identifier for the index"
                },
                "createdAt": {
                  "type": "string",
                  "format": "date-time",
                  "description": "An `RFC 3339` format for date/time/duration."
                },
                "updatedAt": {
                  "type": "string",
                  "format": "date-time",
                  "description": "An `RFC 3339` format for date/time/duration."
                },
                "primaryKey": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "description": "Custom primaryKey for documents"
                }
              }
            }
          },
          "offset": {
            "type": "integer",
            "minimum": 0
          },
          "limit": {
            "type": "integer",
            "minimum": 0
          },
          "total": {
            "type": "integer",
            "minimum": 0
          }
        }
      },
      "PaginationView_KeyView": {
        "type": "object",
        "required": [
          "results",
          "offset",
          "limit",
          "total"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "key",
                "uid",
                "actions",
                "indexes",
                "createdAt",
                "updatedAt"
              ],
              "properties": {
                "name": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "description": "The name of the API Key if any"
                },
                "description": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "description": "The description of the API Key if any"
                },
                "key": {
                  "type": "string",
                  "description": "The actual API Key you can send to Meilisearch"
                },
                "uid": {
                  "type": "string",
                  "format": "uuid",
                  "description": "The `Uuid` specified while creating the key or autogenerated by Meilisearch."
                },
                "actions": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Action"
                  },
                  "description": "The actions accessible with this key."
                },
                "indexes": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "The indexes accessible with this key."
                },
                "expiresAt": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "format": "date-time",
                  "description": "The expiration date of the key. Once this timestamp is exceeded the key is not deleted but cannot be used anymore."
                },
                "createdAt": {
                  "type": "string",
                  "format": "date-time",
                  "description": "The date of creation of this API Key.",
                  "readOnly": true
                },
                "updatedAt": {
                  "type": "string",
                  "format": "date-time",
                  "description": "The date of the last update made on this key.",
                  "readOnly": true
                }
              }
            }
          },
          "offset": {
            "type": "integer",
            "minimum": 0
          },
          "limit": {
            "type": "integer",
            "minimum": 0
          },
          "total": {
            "type": "integer",
            "minimum": 0
          }
        }
      },
      "PaginationView_Value": {
        "type": "object",
        "required": [
          "results",
          "offset",
          "limit",
          "total"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {}
          },
          "offset": {
            "type": "integer",
            "minimum": 0
          },
          "limit": {
            "type": "integer",
            "minimum": 0
          },
          "total": {
            "type": "integer",
            "minimum": 0
          }
        }
      },
      "PatchApiKey": {
        "type": "object",
        "properties": {
          "description": {
            "type": [
              "string",
              "null"
            ],
            "example": "This key is used to update documents in the products index"
          },
          "name": {
            "type": [
              "string",
              "null"
            ],
            "example": "Indexing Products API key"
          }
        }
      },
      "Personalize": {
        "type": "object",
        "required": [
          "user_context"
        ],
        "properties": {
          "user_context": {
            "type": "string"
          }
        }
      },
      "PrefixSearchSettings": {
        "type": "string",
        "enum": [
          "indexingTime",
          "disabled"
        ]
      },
      "ProgressStepView": {
        "type": "object",
        "required": [
          "currentStep",
          "finished",
          "total"
        ],
        "properties": {
          "currentStep": {
            "type": "string"
          },
          "finished": {
            "type": "integer",
            "format": "u-int32",
            "minimum": 0
          },
          "total": {
            "type": "integer",
            "format": "u-int32",
            "minimum": 0
          }
        }
      },
      "ProgressView": {
        "type": "object",
        "required": [
          "steps",
          "percentage"
        ],
        "properties": {
          "steps": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ProgressStepView"
            }
          },
          "percentage": {
            "type": "number",
            "format": "float"
          }
        }
      },
      "ProximityPrecisionView": {
        "type": "string",
        "enum": [
          "byWord",
          "byAttribute"
        ]
      },
      "RankingRuleView": {
        "oneOf": [
          {
            "type": "string",
            "description": "Sorted by decreasing number of matched query terms.\nQuery words at the front of an attribute is considered better than if it was at the back.",
            "enum": [
              "Words"
            ]
          },
          {
            "type": "string",
            "description": "Sorted by increasing number of typos.",
            "enum": [
              "Typo"
            ]
          },
          {
            "type": "string",
            "description": "Sorted by increasing distance between matched query terms.",
            "enum": [
              "Proximity"
            ]
          },
          {
            "type": "string",
            "description": "Documents with quey words contained in more important\nattributes are considered better.",
            "enum": [
              "Attribute"
            ]
          },
          {
            "type": "string",
            "description": "Dynamically sort at query time the documents. None, one or multiple Asc/Desc sortable\nattributes can be used in place of this criterion at query time.",
            "enum": [
              "Sort"
            ]
          },
          {
            "type": "string",
            "description": "Sorted by the similarity of the matched words with the query words.",
            "enum": [
              "Exactness"
            ]
          },
          {
            "type": "object",
            "description": "Sorted by the increasing value of the field specified.",
            "required": [
              "Asc"
            ],
            "properties": {
              "Asc": {
                "type": "string",
                "description": "Sorted by the increasing value of the field specified."
              }
            }
          },
          {
            "type": "object",
            "description": "Sorted by the decreasing value of the field specified.",
            "required": [
              "Desc"
            ],
            "properties": {
              "Desc": {
                "type": "string",
                "description": "Sorted by the decreasing value of the field specified."
              }
            }
          }
        ]
      },
      "RankingScoreThreshold": {
        "type": "number",
        "format": "double"
      },
      "Remote": {
        "type": "object",
        "properties": {
          "url": {
            "type": [
              "string",
              "null"
            ],
            "example": {
              "ms-0": {
                "url": "http://localhost:7700",
                "searchApiKey": null,
                "writeApiKey": null
              },
              "ms-1": {
                "url": "http://localhost:7701",
                "searchApiKey": "foo",
                "writeApiKey": "bar"
              },
              "ms-2": {
                "url": "http://localhost:7702",
                "searchApiKey": "bar",
                "writeApiKey": "foo"
              }
            }
          },
          "searchApiKey": {
            "type": [
              "string",
              "null"
            ],
            "example": "XWnBI8QHUc-4IlqbKPLUDuhftNq19mQtjc6JvmivzJU"
          },
          "writeApiKey": {
            "type": [
              "string",
              "null"
            ],
            "example": "XWnBI8QHUc-4IlqbKPLUDuhftNq19mQtjc6JvmivzJU"
          }
        }
      },
      "RemoteTask": {
        "type": "object",
        "properties": {
          "taskUid": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/u32"
              }
            ]
          },
          "error": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/ResponseError"
              }
            ]
          }
        }
      },
      "ResponseError": {
        "type": "object",
        "required": [
          "message",
          "code",
          "type",
          "link"
        ],
        "properties": {
          "message": {
            "type": "string",
            "description": "The error message."
          },
          "code": {
            "$ref": "#/components/schemas/Code",
            "description": "The error code."
          },
          "type": {
            "$ref": "#/components/schemas/ErrorType",
            "description": "The error type."
          },
          "link": {
            "type": "string",
            "description": "A link to the documentation about this specific error."
          }
        }
      },
      "RuntimeTogglableFeatures": {
        "type": "object",
        "properties": {
          "metrics": {
            "type": [
              "boolean",
              "null"
            ]
          },
          "logsRoute": {
            "type": [
              "boolean",
              "null"
            ]
          },
          "editDocumentsByFunction": {
            "type": [
              "boolean",
              "null"
            ]
          },
          "containsFilter": {
            "type": [
              "boolean",
              "null"
            ]
          },
          "network": {
            "type": [
              "boolean",
              "null"
            ]
          },
          "getTaskDocumentsRoute": {
            "type": [
              "boolean",
              "null"
            ]
          },
          "compositeEmbedders": {
            "type": [
              "boolean",
              "null"
            ]
          },
          "chatCompletions": {
            "type": [
              "boolean",
              "null"
            ]
          },
          "multimodal": {
            "type": [
              "boolean",
              "null"
            ]
          },
          "vectorStoreSetting": {
            "type": [
              "boolean",
              "null"
            ]
          }
        }
      },
      "SearchHit": {
        "type": "object",
        "properties": {
          "_formatted": {
            "type": "object",
            "additionalProperties": true
          },
          "_matchesPosition": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/BTreeMap"
              }
            ]
          },
          "_rankingScore": {
            "type": [
              "number",
              "null"
            ],
            "format": "double"
          },
          "_rankingScoreDetails": {
            "type": [
              "object",
              "null"
            ],
            "additionalProperties": {},
            "propertyNames": {
              "type": "string"
            }
          }
        },
        "additionalProperties": {}
      },
      "SearchMetadata": {
        "type": "object",
        "required": [
          "queryUid",
          "indexUid"
        ],
        "properties": {
          "queryUid": {
            "type": "string",
            "format": "uuid"
          },
          "indexUid": {
            "type": "string"
          },
          "primaryKey": {
            "type": [
              "string",
              "null"
            ]
          },
          "remote": {
            "type": [
              "string",
              "null"
            ]
          }
        }
      },
      "SearchQuery": {
        "type": "object",
        "required": [
          "offset",
          "limit",
          "retrieve_vectors",
          "crop_length",
          "show_matches_position",
          "show_ranking_score",
          "show_ranking_score_details",
          "highlight_pre_tag",
          "highlight_post_tag",
          "crop_marker",
          "matching_strategy"
        ],
        "properties": {
          "q": {
            "type": [
              "string",
              "null"
            ]
          },
          "vector": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "number",
              "format": "float"
            }
          },
          "media": {},
          "hybrid": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/HybridQuery"
              }
            ]
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "minimum": 0
          },
          "limit": {
            "type": "integer",
            "default": 20,
            "minimum": 0
          },
          "page": {
            "type": [
              "integer",
              "null"
            ],
            "minimum": 0
          },
          "hits_per_page": {
            "type": [
              "integer",
              "null"
            ],
            "minimum": 0
          },
          "attributes_to_retrieve": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "uniqueItems": true
          },
          "retrieve_vectors": {
            "type": "boolean"
          },
          "attributes_to_crop": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            }
          },
          "crop_length": {
            "type": "integer",
            "default": 10,
            "minimum": 0
          },
          "attributes_to_highlight": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "uniqueItems": true
          },
          "show_matches_position": {
            "type": "boolean"
          },
          "show_ranking_score": {
            "type": "boolean"
          },
          "show_ranking_score_details": {
            "type": "boolean"
          },
          "filter": {},
          "sort": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            }
          },
          "distinct": {
            "type": [
              "string",
              "null"
            ]
          },
          "facets": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            }
          },
          "highlight_pre_tag": {
            "type": "string",
            "default": "<em>"
          },
          "highlight_post_tag": {
            "type": "string",
            "default": "</em>"
          },
          "crop_marker": {
            "type": "string",
            "default": ""
          },
          "matching_strategy": {
            "$ref": "#/components/schemas/MatchingStrategy"
          },
          "attributes_to_search_on": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            }
          },
          "ranking_score_threshold": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/RankingScoreThreshold"
              }
            ]
          },
          "locales": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "$ref": "#/components/schemas/Locale"
            }
          },
          "personalize": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/Personalize"
              }
            ]
          }
        }
      },
      "SearchQueryWithIndex": {
        "type": "object",
        "description": "A `SearchQuery` + an index UID and optional FederationOptions.",
        "required": [
          "indexUid",
          "retrieveVectors",
          "cropLength",
          "showRankingScore",
          "showRankingScoreDetails",
          "showMatchesPosition",
          "highlightPreTag",
          "highlightPostTag",
          "cropMarker",
          "matchingStrategy"
        ],
        "properties": {
          "indexUid": {
            "$ref": "#/components/schemas/IndexUid"
          },
          "q": {
            "type": [
              "string",
              "null"
            ]
          },
          "vector": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "number",
              "format": "float"
            }
          },
          "media": {},
          "hybrid": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/HybridQuery"
              }
            ]
          },
          "offset": {
            "type": [
              "integer",
              "null"
            ],
            "minimum": 0
          },
          "limit": {
            "type": [
              "integer",
              "null"
            ],
            "minimum": 0
          },
          "page": {
            "type": [
              "integer",
              "null"
            ],
            "minimum": 0
          },
          "hitsPerPage": {
            "type": [
              "integer",
              "null"
            ],
            "minimum": 0
          },
          "attributesToRetrieve": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "uniqueItems": true
          },
          "retrieveVectors": {
            "type": "boolean"
          },
          "attributesToCrop": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            }
          },
          "cropLength": {
            "type": "integer",
            "minimum": 0
          },
          "attributesToHighlight": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "uniqueItems": true
          },
          "showRankingScore": {
            "type": "boolean"
          },
          "showRankingScoreDetails": {
            "type": "boolean"
          },
          "showMatchesPosition": {
            "type": "boolean"
          },
          "filter": {},
          "sort": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            }
          },
          "distinct": {
            "type": [
              "string",
              "null"
            ]
          },
          "facets": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            }
          },
          "highlightPreTag": {
            "type": "string"
          },
          "highlightPostTag": {
            "type": "string"
          },
          "cropMarker": {
            "type": "string"
          },
          "matchingStrategy": {
            "$ref": "#/components/schemas/MatchingStrategy"
          },
          "attributesToSearchOn": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            }
          },
          "rankingScoreThreshold": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/RankingScoreThreshold"
              }
            ]
          },
          "locales": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "$ref": "#/components/schemas/Locale"
            }
          },
          "federationOptions": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/FederationOptions"
              }
            ]
          }
        }
      },
      "SearchResult": {
        "allOf": [
          {
            "$ref": "#/components/schemas/HitsInfo"
          },
          {
            "type": "object",
            "required": [
              "hits",
              "query",
              "processingTimeMs"
            ],
            "properties": {
              "hits": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/SearchHit"
                }
              },
              "query": {
                "type": "string"
              },
              "queryVector": {
                "type": [
                  "array",
                  "null"
                ],
                "items": {
                  "type": "number",
                  "format": "float"
                }
              },
              "processingTimeMs": {
                "type": "integer",
                "minimum": 0
              },
              "facetDistribution": {
                "type": [
                  "object",
                  "null"
                ],
                "additionalProperties": {},
                "propertyNames": {
                  "type": "string"
                }
              },
              "facetStats": {
                "type": [
                  "object",
                  "null"
                ],
                "additionalProperties": {
                  "$ref": "#/components/schemas/FacetStats"
                },
                "propertyNames": {
                  "type": "string"
                }
              },
              "requestUid": {
                "type": [
                  "string",
                  "null"
                ],
                "format": "uuid"
              },
              "metadata": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "$ref": "#/components/schemas/SearchMetadata"
                  }
                ]
              },
              "semanticHitCount": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int32",
                "minimum": 0
              }
            }
          }
        ]
      },
      "SearchResultWithIndex": {
        "allOf": [
          {
            "$ref": "#/components/schemas/SearchResult"
          },
          {
            "type": "object",
            "required": [
              "indexUid"
            ],
            "properties": {
              "indexUid": {
                "type": "string"
              }
            }
          }
        ]
      },
      "SearchResults": {
        "type": "object",
        "required": [
          "results"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchResultWithIndex"
            }
          }
        }
      },
      "SettingEmbeddingSettings": {
        "type": "object",
        "description": "\"Technical\" type that is required due to utoipa.\n\nWe did not find a way to implement [`utoipa::ToSchema`] for the [`Setting`] enum,\nbut most types can use the `value_type` macro parameter to workaround that issue.\n\nHowever that type is used in the settings route, including through the macro that auto-generate\nall the settings route, so we can't remap the `value_type`.",
        "properties": {
          "inner": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "object",
                "properties": {
                  "source": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "$ref": "#/components/schemas/EmbedderSource",
                        "description": "The source used to provide the embeddings.\n\nWhich embedder parameters are available and mandatory is determined by the value of this setting.\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings.\n\n# Defaults\n\n- Defaults to `openAi`"
                      }
                    ]
                  },
                  "model": {
                    "type": [
                      "string",
                      "null"
                    ],
                    "description": "The name of the model to use.\n\n# Mandatory\n\n- This parameter is mandatory for source `ollama`\n\n# Availability\n\n- This parameter is available for sources `openAi`, `huggingFace`, `ollama`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings.\n\n# Defaults\n\n- For source `openAi`, defaults to `text-embedding-3-small`\n- For source `huggingFace`, defaults to `BAAI/bge-base-en-v1.5`"
                  },
                  "revision": {
                    "type": [
                      "string",
                      "null"
                    ],
                    "description": "The revision (commit SHA1) of the model to use.\n\nIf unspecified, Meilisearch picks the latest revision of the model.\n\n# Availability\n\n- This parameter is available for source `huggingFace`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings\n\n# Defaults\n\n- When `model` is set to default, defaults to `617ca489d9e86b49b8167676d8220688b99db36e`\n- Otherwise, defaults to `null`"
                  },
                  "pooling": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "$ref": "#/components/schemas/OverridePooling",
                        "description": "The pooling method to use.\n\n# Availability\n\n- This parameter is available for source `huggingFace`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings\n\n# Defaults\n\n- Defaults to `useModel`\n\n# Compatibility Note\n\n- Embedders created before this parameter was available default to `forceMean` to preserve the existing behavior."
                      }
                    ]
                  },
                  "apiKey": {
                    "type": [
                      "string",
                      "null"
                    ],
                    "description": "The API key to pass to the remote embedder while making requests.\n\n# Availability\n\n- This parameter is available for source `openAi`, `ollama`, `rest`\n\n#  Reindexing\n\n-  Changing the value of this parameter never regenerates embeddings\n\n# Defaults\n\n- For source `openAi`, the key is read from `OPENAI_API_KEY`, then `MEILI_OPENAI_API_KEY`.\n- For other sources, no bearer token is sent if this parameter is not set.\n\n# Note\n\n- This setting is partially hidden when returned by the settings"
                  },
                  "dimensions": {
                    "type": [
                      "string",
                      "null"
                    ],
                    "description": "The expected dimensions of the embeddings produced by this embedder.\n\n# Mandatory\n\n- This parameter is mandatory for source `userProvided`\n\n# Availability\n\n- This parameter is available for source `openAi`, `ollama`, `rest`, `userProvided`\n\n#  Reindexing\n\n-  When the source is `openAi`, changing the value of this parameter always regenerates embeddings\n-  For other sources, changing the value of this parameter never regenerates embeddings\n\n# Defaults\n\n- For source `openAi`, the dimensions is the maximum allowed by the model.\n- For sources `ollama` and `rest`, the dimensions are inferred by embedding a sample text."
                  },
                  "binaryQuantized": {
                    "type": [
                      "boolean",
                      "null"
                    ],
                    "description": "Whether to binary quantize the embeddings of this embedder.\n\nBinary quantized embeddings are smaller than regular embeddings, which improves\ndisk usage and retrieval speed, at the cost of relevancy.\n\n# Availability\n\n- This parameter is available for all embedders\n\n#  Reindexing\n\n-  When set to `true`, embeddings are not regenerated, but they are binary quantized, which takes time.\n\n# Defaults\n\n- Defaults to `false`\n\n# Note\n\nAs binary quantization is a destructive operation, it is not possible to disable again this setting after\nfirst enabling it. If you are unsure of whether the performance-relevancy tradeoff is right for you,\nwe recommend to use this parameter on a test index first."
                  },
                  "documentTemplate": {
                    "type": [
                      "boolean",
                      "null"
                    ],
                    "description": "A liquid template used to render documents to a text that can be embedded.\n\nMeillisearch interpolates the template for each document and sends the resulting text to the embedder.\nThe embedder then generates document vectors based on this text.\n\n# Availability\n\n- This parameter is available for source `openAi`, `huggingFace`, `ollama` and `rest\n\n#  Reindexing\n\n-  When modified, embeddings are regenerated for documents whose rendering through the template produces a different text."
                  },
                  "documentTemplateMaxBytes": {
                    "type": [
                      "integer",
                      "null"
                    ],
                    "description": "Rendered texts are truncated to this size.\n\n# Availability\n\n- This parameter is available for source `openAi`, `huggingFace`, `ollama` and `rest`\n\n#  Reindexing\n\n-  When increased, embeddings are regenerated for documents whose rendering through the template produces a different text.\n-  When decreased, embeddings are never regenerated\n\n# Default\n\n- Defaults to 400",
                    "minimum": 0
                  },
                  "url": {
                    "type": [
                      "string",
                      "null"
                    ],
                    "description": "URL to reach the remote embedder.\n\n# Mandatory\n\n- This parameter is mandatory for source `rest`\n\n# Availability\n\n- This parameter is available for source `openAi`, `ollama` and `rest`\n\n#  Reindexing\n\n-  When modified for source `openAi`, embeddings are never regenerated\n-  When modified for sources `ollama` and `rest`, embeddings are always regenerated"
                  },
                  "indexingFragments": {
                    "type": [
                      "object",
                      "null"
                    ],
                    "description": "Template fragments that will be reassembled and sent to the remote embedder at indexing time.\n\n# Availability\n\n- This parameter is available for sources `rest`.\n\n#  Reindexing\n\n-  When a fragment is deleted by passing `null` to its name, the corresponding embeddings are removed from documents.\n-  When a fragment is modified, the corresponding embeddings are regenerated if their rendered version changes.",
                    "additionalProperties": {},
                    "propertyNames": {
                      "type": "string"
                    }
                  },
                  "searchFragments": {
                    "type": [
                      "object",
                      "null"
                    ],
                    "description": "Template fragments that will be reassembled and sent to the remote embedder at search time.\n\n# Availability\n\n- This parameter is available for sources `rest`.\n\n#  Reindexing\n\n-  Changing the value of this parameter never regenerates embeddings",
                    "additionalProperties": {},
                    "propertyNames": {
                      "type": "string"
                    }
                  },
                  "request": {
                    "description": "Template request to send to the remote embedder.\n\n# Mandatory\n\n- This parameter is mandatory for source `rest`\n\n# Availability\n\n- This parameter is available for source `rest`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings"
                  },
                  "response": {
                    "description": "Template response indicating how to find the embeddings in the response from the remote embedder.\n\n# Mandatory\n\n- This parameter is mandatory for source `rest`\n\n# Availability\n\n- This parameter is available for source `rest`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings"
                  },
                  "headers": {
                    "type": [
                      "object",
                      "null"
                    ],
                    "description": "Additional headers to send to the remote embedder.\n\n# Availability\n\n- This parameter is available for source `rest`\n\n#  Reindexing\n\n-  Changing the value of this parameter never regenerates embeddings",
                    "additionalProperties": {
                      "type": "string"
                    },
                    "propertyNames": {
                      "type": "string"
                    }
                  },
                  "searchEmbedder": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "$ref": "#/components/schemas/SubEmbeddingSettings"
                      }
                    ]
                  },
                  "indexingEmbedder": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "$ref": "#/components/schemas/SubEmbeddingSettings"
                      }
                    ]
                  },
                  "distribution": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "$ref": "#/components/schemas/DistributionShift",
                        "description": "Affine transformation applied to the semantic score to make it more comparable to the ranking score.\n\n# Availability\n\n- This parameter is available for all embedders\n\n#  Reindexing\n\n-  Changing the value of this parameter never regenerates embeddings"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            ]
          }
        }
      },
      "Settings_Checked": {
        "type": "object",
        "description": "Holds all the settings for an index. `T` can either be `Checked` if they represents settings\nwhose validity is guaranteed, or `Unchecked` if they need to be validated. In the later case, a\ncall to `check` will return a `Settings<Checked>` from a `Settings<Unchecked>`.",
        "properties": {
          "displayedAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Fields displayed in the returned documents.",
            "example": [
              "id",
              "title",
              "description",
              "url"
            ]
          },
          "searchableAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Fields in which to search for matching query words sorted by order of importance.",
            "example": [
              "title",
              "description"
            ]
          },
          "filterableAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "$ref": "#/components/schemas/FilterableAttributesRule"
            },
            "description": "Attributes to use for faceting and filtering. See [Filtering and Faceted Search](https://www.meilisearch.com/docs/learn/filtering_and_sorting/search_with_facet_filters).",
            "example": [
              "release_date",
              "genre"
            ]
          },
          "sortableAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Attributes to use when sorting search results.",
            "example": [
              "release_date"
            ]
          },
          "rankingRules": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of ranking rules sorted by order of importance. The order is customizable.\n[A list of ordered built-in ranking rules](https://www.meilisearch.com/docs/learn/relevancy/relevancy).",
            "example": [
              "words",
              "typo",
              "proximity",
              "attribute",
              "exactness"
            ]
          },
          "stopWords": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of words ignored when present in search queries.",
            "example": [
              "the",
              "a",
              "them",
              "their"
            ]
          },
          "nonSeparatorTokens": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of characters not delimiting where one term begins and ends.",
            "example": [
              " ",
              "\n"
            ]
          },
          "separatorTokens": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of characters delimiting where one term begins and ends.",
            "example": [
              "S"
            ]
          },
          "dictionary": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of strings Meilisearch should parse as a single term.",
            "example": [
              "iPhone pro"
            ]
          },
          "synonyms": {
            "type": [
              "object",
              "null"
            ],
            "description": "List of associated words treated similarly. A word associated to an array of word as synonyms.",
            "additionalProperties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "propertyNames": {
              "type": "string"
            },
            "example": {
              "he": [
                "she",
                "they",
                "them"
              ],
              "phone": [
                "iPhone",
                "android"
              ]
            }
          },
          "distinctAttribute": {
            "type": [
              "string",
              "null"
            ],
            "description": "Search returns documents with distinct (different) values of the given field.",
            "example": "sku"
          },
          "proximityPrecision": {
            "type": [
              "string",
              "null"
            ],
            "description": "Precision level when calculating the proximity ranking rule.",
            "example": "byAttribute"
          },
          "typoTolerance": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/TypoSettings",
                "description": "Customize typo tolerance feature."
              }
            ]
          },
          "faceting": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/FacetingSettings",
                "description": "Faceting settings."
              }
            ]
          },
          "pagination": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/PaginationSettings",
                "description": "Pagination settings."
              }
            ]
          },
          "embedders": {
            "type": [
              "object",
              "null"
            ],
            "description": "Embedder required for performing semantic search queries.",
            "additionalProperties": {
              "$ref": "#/components/schemas/SettingEmbeddingSettings"
            },
            "propertyNames": {
              "type": "string"
            }
          },
          "searchCutoffMs": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int64",
            "description": "Maximum duration of a search query.",
            "example": 50,
            "minimum": 0
          },
          "localizedAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "$ref": "#/components/schemas/LocalizedAttributesRuleView"
            },
            "example": 50
          },
          "facetSearch": {
            "type": [
              "boolean",
              "null"
            ],
            "example": true
          },
          "prefixSearch": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/PrefixSearchSettings"
              }
            ]
          },
          "chat": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/ChatSettings",
                "description": "Customize the chat prompting."
              }
            ]
          },
          "vectorStore": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/VectorStoreBackend"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Settings_Unchecked": {
        "type": "object",
        "description": "Holds all the settings for an index. `T` can either be `Checked` if they represents settings\nwhose validity is guaranteed, or `Unchecked` if they need to be validated. In the later case, a\ncall to `check` will return a `Settings<Checked>` from a `Settings<Unchecked>`.",
        "properties": {
          "displayedAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Fields displayed in the returned documents.",
            "example": [
              "id",
              "title",
              "description",
              "url"
            ]
          },
          "searchableAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Fields in which to search for matching query words sorted by order of importance.",
            "example": [
              "title",
              "description"
            ]
          },
          "filterableAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "$ref": "#/components/schemas/FilterableAttributesRule"
            },
            "description": "Attributes to use for faceting and filtering. See [Filtering and Faceted Search](https://www.meilisearch.com/docs/learn/filtering_and_sorting/search_with_facet_filters).",
            "example": [
              "release_date",
              "genre"
            ]
          },
          "sortableAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Attributes to use when sorting search results.",
            "example": [
              "release_date"
            ]
          },
          "rankingRules": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of ranking rules sorted by order of importance. The order is customizable.\n[A list of ordered built-in ranking rules](https://www.meilisearch.com/docs/learn/relevancy/relevancy).",
            "example": [
              "words",
              "typo",
              "proximity",
              "attribute",
              "exactness"
            ]
          },
          "stopWords": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of words ignored when present in search queries.",
            "example": [
              "the",
              "a",
              "them",
              "their"
            ]
          },
          "nonSeparatorTokens": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of characters not delimiting where one term begins and ends.",
            "example": [
              " ",
              "\n"
            ]
          },
          "separatorTokens": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of characters delimiting where one term begins and ends.",
            "example": [
              "S"
            ]
          },
          "dictionary": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of strings Meilisearch should parse as a single term.",
            "example": [
              "iPhone pro"
            ]
          },
          "synonyms": {
            "type": [
              "object",
              "null"
            ],
            "description": "List of associated words treated similarly. A word associated to an array of word as synonyms.",
            "additionalProperties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "propertyNames": {
              "type": "string"
            },
            "example": {
              "he": [
                "she",
                "they",
                "them"
              ],
              "phone": [
                "iPhone",
                "android"
              ]
            }
          },
          "distinctAttribute": {
            "type": [
              "string",
              "null"
            ],
            "description": "Search returns documents with distinct (different) values of the given field.",
            "example": "sku"
          },
          "proximityPrecision": {
            "type": [
              "string",
              "null"
            ],
            "description": "Precision level when calculating the proximity ranking rule.",
            "example": "byAttribute"
          },
          "typoTolerance": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/TypoSettings",
                "description": "Customize typo tolerance feature."
              }
            ]
          },
          "faceting": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/FacetingSettings",
                "description": "Faceting settings."
              }
            ]
          },
          "pagination": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/PaginationSettings",
                "description": "Pagination settings."
              }
            ]
          },
          "embedders": {
            "type": [
              "object",
              "null"
            ],
            "description": "Embedder required for performing semantic search queries.",
            "additionalProperties": {
              "$ref": "#/components/schemas/SettingEmbeddingSettings"
            },
            "propertyNames": {
              "type": "string"
            }
          },
          "searchCutoffMs": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int64",
            "description": "Maximum duration of a search query.",
            "example": 50,
            "minimum": 0
          },
          "localizedAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "$ref": "#/components/schemas/LocalizedAttributesRuleView"
            },
            "example": 50
          },
          "facetSearch": {
            "type": [
              "boolean",
              "null"
            ],
            "example": true
          },
          "prefixSearch": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/PrefixSearchSettings"
              }
            ]
          },
          "chat": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/ChatSettings",
                "description": "Customize the chat prompting."
              }
            ]
          },
          "vectorStore": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/VectorStoreBackend"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "SimilarQuery": {
        "type": "object",
        "required": [
          "id",
          "offset",
          "limit",
          "embedder",
          "retrieve_vectors",
          "show_ranking_score",
          "show_ranking_score_details",
          "ranking_score_threshold"
        ],
        "properties": {
          "id": {
            "type": "string"
          },
          "offset": {
            "type": "integer",
            "minimum": 0
          },
          "limit": {
            "type": "integer",
            "minimum": 0
          },
          "filter": {},
          "embedder": {
            "type": "string"
          },
          "attributes_to_retrieve": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "uniqueItems": true
          },
          "retrieve_vectors": {
            "type": "boolean"
          },
          "show_ranking_score": {
            "type": "boolean"
          },
          "show_ranking_score_details": {
            "type": "boolean"
          },
          "ranking_score_threshold": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "SimilarResult": {
        "allOf": [
          {
            "$ref": "#/components/schemas/HitsInfo"
          },
          {
            "type": "object",
            "required": [
              "hits",
              "id",
              "processingTimeMs"
            ],
            "properties": {
              "hits": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/SearchHit"
                }
              },
              "id": {
                "type": "string"
              },
              "processingTimeMs": {
                "type": "integer",
                "minimum": 0
              }
            }
          }
        ]
      },
      "Stats": {
        "type": "object",
        "required": [
          "databaseSize",
          "usedDatabaseSize",
          "indexes"
        ],
        "properties": {
          "databaseSize": {
            "type": "integer",
            "format": "u-int64",
            "description": "The disk space used by the database, in bytes.",
            "minimum": 0
          },
          "usedDatabaseSize": {
            "type": "integer",
            "format": "u-int64",
            "description": "The size of the database, in bytes.",
            "minimum": 0
          },
          "lastUpdate": {
            "type": [
              "string",
              "null"
            ],
            "format": "date-time",
            "description": "The date of the last update in the RFC 3339 formats. Can be `null` if no update has ever been processed."
          },
          "indexes": {
            "type": "object",
            "description": "The stats of every individual index your API key lets you access.",
            "additionalProperties": {
              "$ref": "#/components/schemas/IndexStats"
            },
            "propertyNames": {
              "type": "string"
            }
          }
        }
      },
      "Status": {
        "type": "string",
        "description": "The status of a task.",
        "enum": [
          "enqueued",
          "processing",
          "succeeded",
          "failed",
          "canceled"
        ],
        "example": "processing"
      },
      "SubEmbeddingSettings": {
        "type": "object",
        "properties": {
          "source": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/EmbedderSource",
                "description": "The source used to provide the embeddings.\n\nWhich embedder parameters are available and mandatory is determined by the value of this setting.\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings.\n\n# Defaults\n\n- Defaults to `openAi`"
              }
            ]
          },
          "model": {
            "type": [
              "string",
              "null"
            ],
            "description": "The name of the model to use.\n\n# Mandatory\n\n- This parameter is mandatory for source `ollama`\n\n# Availability\n\n- This parameter is available for sources `openAi`, `huggingFace`, `ollama`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings.\n\n# Defaults\n\n- For source `openAi`, defaults to `text-embedding-3-small`\n- For source `huggingFace`, defaults to `BAAI/bge-base-en-v1.5`"
          },
          "revision": {
            "type": [
              "string",
              "null"
            ],
            "description": "The revision (commit SHA1) of the model to use.\n\nIf unspecified, Meilisearch picks the latest revision of the model.\n\n# Availability\n\n- This parameter is available for source `huggingFace`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings\n\n# Defaults\n\n- When `model` is set to default, defaults to `617ca489d9e86b49b8167676d8220688b99db36e`\n- Otherwise, defaults to `null`"
          },
          "pooling": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/OverridePooling",
                "description": "The pooling method to use.\n\n# Availability\n\n- This parameter is available for source `huggingFace`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings\n\n# Defaults\n\n- Defaults to `useModel`\n\n# Compatibility Note\n\n- Embedders created before this parameter was available default to `forceMean` to preserve the existing behavior."
              }
            ]
          },
          "apiKey": {
            "type": [
              "string",
              "null"
            ],
            "description": "The API key to pass to the remote embedder while making requests.\n\n# Availability\n\n- This parameter is available for source `openAi`, `ollama`, `rest`\n\n#  Reindexing\n\n-  Changing the value of this parameter never regenerates embeddings\n\n# Defaults\n\n- For source `openAi`, the key is read from `OPENAI_API_KEY`, then `MEILI_OPENAI_API_KEY`.\n- For other sources, no bearer token is sent if this parameter is not set.\n\n# Note\n\n- This setting is partially hidden when returned by the settings"
          },
          "dimensions": {
            "type": [
              "string",
              "null"
            ],
            "description": "The expected dimensions of the embeddings produced by this embedder.\n\n# Mandatory\n\n- This parameter is mandatory for source `userProvided`\n\n# Availability\n\n- This parameter is available for source `openAi`, `ollama`, `rest`, `userProvided`\n\n#  Reindexing\n\n-  When the source is `openAi`, changing the value of this parameter always regenerates embeddings\n-  For other sources, changing the value of this parameter never regenerates embeddings\n\n# Defaults\n\n- For source `openAi`, the dimensions is the maximum allowed by the model.\n- For sources `ollama` and `rest`, the dimensions are inferred by embedding a sample text."
          },
          "documentTemplate": {
            "type": [
              "boolean",
              "null"
            ],
            "description": "A liquid template used to render documents to a text that can be embedded.\n\nMeillisearch interpolates the template for each document and sends the resulting text to the embedder.\nThe embedder then generates document vectors based on this text.\n\n# Availability\n\n- This parameter is available for source `openAi`, `huggingFace`, `ollama` and `rest\n\n#  Reindexing\n\n-  When modified, embeddings are regenerated for documents whose rendering through the template produces a different text."
          },
          "documentTemplateMaxBytes": {
            "type": [
              "integer",
              "null"
            ],
            "description": "Rendered texts are truncated to this size.\n\n# Availability\n\n- This parameter is available for source `openAi`, `huggingFace`, `ollama` and `rest`\n\n#  Reindexing\n\n-  When increased, embeddings are regenerated for documents whose rendering through the template produces a different text.\n-  When decreased, embeddings are never regenerated\n\n# Default\n\n- Defaults to 400",
            "minimum": 0
          },
          "url": {
            "type": [
              "string",
              "null"
            ],
            "description": "URL to reach the remote embedder.\n\n# Mandatory\n\n- This parameter is mandatory for source `rest`\n\n# Availability\n\n- This parameter is available for source `openAi`, `ollama` and `rest`\n\n#  Reindexing\n\n-  When modified for source `openAi`, embeddings are never regenerated\n-  When modified for sources `ollama` and `rest`, embeddings are always regenerated"
          },
          "indexingFragments": {
            "type": [
              "object",
              "null"
            ],
            "description": "Template fragments that will be reassembled and sent to the remote embedder at indexing time.\n\n# Availability\n\n- This parameter is available for sources `rest`.\n\n#  Reindexing\n\n-  When a fragment is deleted by passing `null` to its name, the corresponding embeddings are removed from documents.\n-  When a fragment is modified, the corresponding embeddings are regenerated if their rendered version changes.",
            "additionalProperties": {},
            "propertyNames": {
              "type": "string"
            }
          },
          "searchFragments": {
            "type": [
              "object",
              "null"
            ],
            "description": "Template fragments that will be reassembled and sent to the remote embedder at search time.\n\n# Availability\n\n- This parameter is available for sources `rest`.\n\n#  Reindexing\n\n-  Changing the value of this parameter never regenerates embeddings",
            "additionalProperties": {},
            "propertyNames": {
              "type": "string"
            }
          },
          "request": {
            "description": "Template request to send to the remote embedder.\n\n# Mandatory\n\n- This parameter is mandatory for source `rest`\n\n# Availability\n\n- This parameter is available for source `rest`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings"
          },
          "response": {
            "description": "Template response indicating how to find the embeddings in the response from the remote embedder.\n\n# Mandatory\n\n- This parameter is mandatory for source `rest`\n\n# Availability\n\n- This parameter is available for source `rest`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings"
          },
          "headers": {
            "type": [
              "object",
              "null"
            ],
            "description": "Additional headers to send to the remote embedder.\n\n# Availability\n\n- This parameter is available for source `rest`\n\n#  Reindexing\n\n-  Changing the value of this parameter never regenerates embeddings",
            "additionalProperties": {
              "type": "string"
            },
            "propertyNames": {
              "type": "string"
            }
          }
        },
        "additionalProperties": false
      },
      "SummarizedTaskView": {
        "type": "object",
        "required": [
          "taskUid",
          "status",
          "type",
          "enqueuedAt"
        ],
        "properties": {
          "taskUid": {
            "type": "integer",
            "format": "u-int32",
            "description": "The task unique identifier.",
            "minimum": 0
          },
          "indexUid": {
            "type": [
              "string",
              "null"
            ],
            "description": "The index affected by this task. May be `null` if the task is not linked to any index."
          },
          "status": {
            "$ref": "#/components/schemas/Status",
            "description": "The status of the task."
          },
          "type": {
            "$ref": "#/components/schemas/Kind",
            "description": "The type of the task."
          },
          "enqueuedAt": {
            "type": "string",
            "format": "date-time",
            "description": "The date on which the task was enqueued."
          },
          "customMetadata": {
            "type": [
              "string",
              "null"
            ]
          }
        }
      },
      "SwapIndexesPayload": {
        "type": "object",
        "required": [
          "indexes",
          "rename"
        ],
        "properties": {
          "indexes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IndexUid"
            },
            "description": "Array of the two indexUids to be swapped"
          },
          "rename": {
            "type": "boolean",
            "description": "If set to true, instead of swapping the left and right indexes it'll change the name of the first index to the second"
          }
        }
      },
      "TaskView": {
        "type": "object",
        "required": [
          "uid",
          "status",
          "type",
          "enqueuedAt"
        ],
        "properties": {
          "uid": {
            "type": "integer",
            "format": "u-int32",
            "description": "The unique sequential identifier of the task.",
            "example": 4312,
            "minimum": 0
          },
          "batchUid": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int32",
            "description": "The unique identifier of the index where this task is operated.",
            "example": "movies",
            "minimum": 0
          },
          "indexUid": {
            "type": [
              "string",
              "null"
            ]
          },
          "status": {
            "$ref": "#/components/schemas/Status"
          },
          "type": {
            "$ref": "#/components/schemas/Kind",
            "description": "The type of the task."
          },
          "canceledBy": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int32",
            "description": "The uid of the task that performed the taskCancelation if the task has been canceled.",
            "example": 4326,
            "minimum": 0
          },
          "details": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/DetailsView"
              }
            ]
          },
          "error": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/ResponseError"
              }
            ]
          },
          "duration": {
            "type": [
              "string",
              "null"
            ],
            "description": "Total elasped time the engine was in processing state expressed as a `ISO-8601` duration format.",
            "example": null
          },
          "enqueuedAt": {
            "type": "string",
            "description": "An `RFC 3339` format for date/time/duration.",
            "example": "2024-08-08_14:12:09.393Z"
          },
          "startedAt": {
            "type": "string",
            "description": "An `RFC 3339` format for date/time/duration.",
            "example": "2024-08-08_14:12:09.393Z"
          },
          "finishedAt": {
            "type": "string",
            "description": "An `RFC 3339` format for date/time/duration.",
            "example": "2024-08-08_14:12:09.393Z"
          },
          "network": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/DbTaskNetwork"
              }
            ]
          },
          "customMetadata": {
            "type": [
              "string",
              "null"
            ]
          }
        }
      },
      "TypoSettings": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": [
              "boolean",
              "null"
            ],
            "example": true
          },
          "minWordSizeForTypos": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/MinWordSizeTyposSetting"
              }
            ]
          },
          "disableOnWords": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "example": [
              "iPhone",
              "phone"
            ],
            "uniqueItems": true
          },
          "disableOnAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "example": [
              "uuid",
              "url"
            ],
            "uniqueItems": true
          },
          "disableOnNumbers": {
            "type": [
              "boolean",
              "null"
            ],
            "example": true
          }
        },
        "additionalProperties": false
      },
      "Unchecked": {
        "default": null
      },
      "UpdateIndexRequest": {
        "type": "object",
        "properties": {
          "primaryKey": {
            "type": [
              "string",
              "null"
            ],
            "description": "The new primary key of the index"
          },
          "uid": {
            "type": [
              "string",
              "null"
            ],
            "description": "The new uid of the index (for renaming)"
          }
        }
      },
      "UpdateStderrLogs": {
        "type": "object",
        "required": [
          "target"
        ],
        "properties": {
          "target": {
            "type": "string",
            "description": "Lets you specify which parts of the code you want to inspect and is formatted like that: code_part=log_level,code_part=log_level\n- If the `code_part` is missing, then the `log_level` will be applied to everything.\n- If the `log_level` is missing, then the `code_part` will be selected in `info` log level.",
            "default": "info",
            "example": "milli=trace,index_scheduler,actix_web=off"
          }
        }
      },
      "Vec": {
        "type": "array",
        "items": {
          "type": "number",
          "format": "float"
        }
      },
      "VectorStoreBackend": {
        "type": "string",
        "enum": [
          "stable",
          "experimental"
        ]
      },
      "VersionResponse": {
        "type": "object",
        "required": [
          "commitSha",
          "commitDate",
          "pkgVersion"
        ],
        "properties": {
          "commitSha": {
            "type": "string",
            "description": "The commit used to compile this build of Meilisearch."
          },
          "commitDate": {
            "type": "string",
            "description": "The date of this build."
          },
          "pkgVersion": {
            "type": "string",
            "description": "The version of Meilisearch."
          }
        }
      },
      "WebhookResults": {
        "type": "object",
        "required": [
          "results"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WebhookWithMetadataRedactedAuthorization"
            }
          }
        }
      },
      "WebhookSettings": {
        "type": "object",
        "properties": {
          "url": {
            "type": [
              "string",
              "null"
            ],
            "example": "https://your.site/on-tasks-completed"
          },
          "headers": {
            "type": [
              "object",
              "null"
            ],
            "additionalProperties": {
              "type": "string"
            },
            "propertyNames": {
              "type": "string"
            },
            "example": {
              "Authorization": "Bearer a-secret-token"
            }
          }
        }
      },
      "WebhookWithMetadataRedactedAuthorization": {
        "allOf": [
          {
            "$ref": "#/components/schemas/WebhookSettings"
          },
          {
            "type": "object",
            "required": [
              "uuid",
              "isEditable"
            ],
            "properties": {
              "uuid": {
                "type": "string",
                "format": "uuid"
              },
              "isEditable": {
                "type": "boolean"
              }
            }
          }
        ]
      },
      "u32": {
        "type": "integer",
        "format": "u-int32",
        "minimum": 0
      }
    },
    "securitySchemes": {
      "Bearer": {
        "type": "http",
        "scheme": "bearer",
        "bearerFormat": "Uuidv4, string or JWT",
        "description": "An API key is a token that you provide when making API calls. Include the token in a header parameter called `Authorization`.\nExample: `Authorization: Bearer 8fece4405662dd830e4cb265e7e047aab2e79672a760a12712d2a263c9003509`"
      }
    }
  },
  "tags": [
    {
      "name": "Stats",
      "description": "Stats gives extended information and metrics about indexes and the Meilisearch database."
    },
    {
      "name": "Tasks",
      "description": "The tasks route gives information about the progress of the [asynchronous operations](https://docs.meilisearch.com/learn/advanced/asynchronous_operations.html).",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/tasks"
      }
    },
    {
      "name": "Batches",
      "description": "The /batches route gives information about the progress of batches of asynchronous operations.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/batches"
      }
    },
    {
      "name": "Indexes",
      "description": "An index is an entity that gathers a set of [documents](https://www.meilisearch.com/docs/learn/getting_started/documents) with its own [settings](https://www.meilisearch.com/docs/reference/api/settings). Learn more about indexes.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/indexes"
      }
    },
    {
      "name": "Documents",
      "description": "Documents are objects composed of fields that can store any type of data. Each field contains an attribute and its associated value. Documents are stored inside [indexes](https://www.meilisearch.com/docs/learn/getting_started/indexes).",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/learn/getting_started/documents"
      }
    },
    {
      "name": "Facet Search",
      "description": "The `/facet-search` route allows you to search for facet values. Facet search supports prefix search and typo tolerance. The returned hits are sorted lexicographically in ascending order. You can configure how facets are sorted using the sortFacetValuesBy property of the faceting index settings.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/facet_search"
      }
    },
    {
      "name": "Similar documents",
      "description": "The /similar route uses AI-powered search to return a number of documents similar to a target document.\n\nMeilisearch exposes two routes for retrieving similar documents: POST and GET. In the majority of cases, POST will offer better performance and ease of use.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/similar"
      }
    },
    {
      "name": "Settings",
      "description": "Use the /settings route to customize search settings for a given index. You can either modify all index settings at once using the update settings endpoint, or use a child route to configure a single setting.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/settings"
      }
    },
    {
      "name": "Compact an index",
      "description": "The /compact route uses compacts the database to reorganize and make it smaller and more efficient.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/compact"
      }
    },
    {
      "name": "Search",
      "description": "Meilisearch exposes two routes to perform searches:\n\n- A POST route: this is the preferred route when using API authentication, as it allows [preflight request](https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request) caching and better performance.\n- A GET route: the usage of this route is discouraged, unless you have good reason to do otherwise (specific caching abilities for example)",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/search"
      }
    },
    {
      "name": "Snapshots",
      "description": "The snapshots route allows the creation of database snapshots. Snapshots are .snapshot files that can be used to launch Meilisearch.\nCreating a snapshot is also referred to as exporting it, whereas launching Meilisearch with a snapshot is referred to as importing it.\nDuring a snapshot export, all indexes of the current instance are exportedtogether with their documents and settingsand saved as a single .snapshot file.\nDuring a snapshot import, all indexes contained in the indicated .snapshot file are imported along with their associated documents and settings.\nSnapshot imports are performed at launch using an option.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/snapshots"
      }
    },
    {
      "name": "Dumps",
      "description": "The `dumps` route allows the creation of database dumps.\nDumps are `.dump` files that can be used to launch Meilisearch. Dumps are compatible between Meilisearch versions.\nCreating a dump is also referred to as exporting it, whereas launching Meilisearch with a dump is referred to as importing it.\nDuring a [dump export](https://www.meilisearch.com/docs/reference/api/dump#create-a-dump), all indexes of the current instance are\nexportedtogether with their documents and settingsand saved as a single `.dump` file. During a dump import,\nall indexes contained in the indicated `.dump` file are imported along with their associated documents and settings.\nAny existing index with the same uid as an index in the dump file will be overwritten.\nDump imports are [performed at launch](https://www.meilisearch.com/docs/learn/advanced/dumps#importing-a-dump) using an option.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/dump"
      }
    },
    {
      "name": "Keys",
      "description": "Manage API `keys` for a Meilisearch instance. Each key has a given set of permissions.\nYou must have the master key or the default admin key to access the keys route. More information about the keys and their rights.\nAccessing any route under `/keys` without having set a master key will result in an error.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/keys"
      }
    },
    {
      "name": "Logs",
      "description": "Everything about retrieving or customizing logs.\nCurrently [experimental](https://www.meilisearch.com/docs/learn/experimental/overview).",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/learn/experimental/log_customization"
      }
    },
    {
      "name": "Multi-search",
      "description": "The `/multi-search` route allows you to perform multiple search queries on one or more indexes by bundling them into a single HTTP request. Multi-search is also known as federated search.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/multi_search"
      }
    },
    {
      "name": "Experimental features",
      "description": "The `/experimental-features` route allows you to activate or deactivate some of Meilisearch's experimental features.\n\nThis route is **synchronous**. This means that no task object will be returned, and any activated or deactivated features will be made available or unavailable immediately.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/experimental_features"
      }
    },
    {
      "name": "Export",
      "description": "The `/export` route allows you to trigger an export process to a remote Meilisearch instance.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/export"
      }
    },
    {
      "name": "Network",
      "description": "The `/network` route allows you to describe the topology of a network of Meilisearch instances.\n\nThis route is **synchronous**. This means that no task object will be returned, and any change to the network will be made available immediately.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/network"
      }
    },
    {
      "name": "Webhooks",
      "description": "The `/webhooks` route allows you to register endpoints to be called once tasks are processed.",
      "externalDocs": {
        "url": "https://www.meilisearch.com/docs/reference/api/webhooks"
      }
    }
  ]
}